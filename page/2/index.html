<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sparkle&#39;s Space">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sparkle's Space</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（七）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-24 10:08:06" itemprop="dateCreated datePublished" datetime="2023-11-24T10:08:06+08:00">2023-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-25 14:36:41" itemprop="dateModified" datetime="2023-11-25T14:36:41+08:00">2023-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这一章我们介绍中断，可以说操作系统就是依靠中断运行的</p>
<h1 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h1><p>中断分类见下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img1.png" alt="img"></p>
<p>部分中断和异常的向量号见下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img2.png" alt="img"></p>
<h1 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h1><p>中断描述符表（Interrupt Descriptor Table,IDT）里面存储的不仅只有中断描述符、还有任务门描述符和陷阱门描述符。它和GDT是并列关系。</p>
<h2 id="门结构"><a href="#门结构" class="headerlink" title="门结构"></a>门结构</h2><p>这里我们先介绍一下新的概念————门结构，门结构本质上就是段描述符，但是普通的段描述符指向一个段，而门结构指向一串代码（程序）。</p>
<p>一共有4种门结构，如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img3.png" alt="img"></p>
<ol>
<li><p>注意4种门结构的都属于系统段(S&#x3D;0)，并且它们的Type类型都是固定的（D&#x3D;1代表32位）。</p>
</li>
<li><p>任务门用于和TTS(Task Status Segment)搭配提供任务切换机制,任务门可存在与GDT、LDT和IDT中，任务门在现代操作系统中已经很少用了</p>
<ul>
<li><p>TTS结构简介：</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img4.png" alt="img"></p>
<p>  TTS结构的关键是多出来三个对应不同特权级的栈（不同的特权级使用不同的栈），以及上一任务指针（指向上一个任务，可以在任务嵌套中完成新任务后返回到旧任务里）</p>
</li>
</ul>
</li>
<li><p>中断门（重点关注），中段门包含了中断处理程序所在段的段选择子和段内偏移地址，中断门只允许存在IDT中。使用中断门时eflags中的IF会自动置0关闭中断，避免中断嵌套（当然只对外部中断有效）</p>
</li>
<li><p>陷阱门，陷阱门也只允许存在IDT中，一般用于调试。使用陷阱门时不会自动关闭中断</p>
</li>
<li><p>调用门，调用门用于给用户进程提升特权级，只能存在于GDT和LDT中，不会出现在IDT里</p>
</li>
</ol>
<h2 id="IDTR和lidt"><a href="#IDTR和lidt" class="headerlink" title="IDTR和lidt"></a>IDTR和lidt</h2><p>IDT地址不限制，存放在哪里都可以，但是必须把它的地方放入IDTR中。（类似GDTR）</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img5.png" alt="img"></p>
<p>IDTR里高32位存放IDT的基址，低16位存放IDT界限，也就是说IDT最大只能是2^16&#x3D;64KB，每一个描述符大小8字节，最多可以有64KB&#x2F;8B&#x3D;8192个表项（处理器只支持256个中断，所以大多数位置是空的）。</p>
<p>更新IDTR的指令如下：</p>
<pre><code>lidt 48位内存数据
</code></pre>
<h2 id="中断处理过程及保护"><a href="#中断处理过程及保护" class="headerlink" title="中断处理过程及保护"></a>中断处理过程及保护</h2><p>中断处理过程如下图所示（未涉及特权级验证）：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img6.png" alt="img"></p>
<p>中断处理过程中的保护指的就是特权级验证，每个门结构都有门栏(门结构的DPL)和门框(目标代码段的DPL)。</p>
<ul>
<li><p>对于软中断的特权级检查要求： <code>门框(目标代码段的DPL) &lt; CPL &lt;= 门栏(门结构的DPL)</code></p>
</li>
<li><p>对于外部中断和异常的特权级检查要求： <code>门框(目标代码段的DPL) &lt; CPL</code></p>
</li>
</ul>
<p>中断开启时，eflags中的NT（NT用于任务嵌套，关闭NT表示当前是在中断处理环境，避免任务嵌套）、TF（TF用于单步调试，关闭TF避免一步一中断）、IF（避免外部中断导致的中断嵌套）都是自动置0</p>
<h2 id="中断发生的压栈"><a href="#中断发生的压栈" class="headerlink" title="中断发生的压栈"></a>中断发生的压栈</h2><p>中断发生后要跳转到中断处理程序，跳转到中断处理程序就一定要经历压栈（保存当前程序地址）</p>
<p>中断压栈的第一步:判断是否发生了特权级转换，因为如果发生了特权级转换，根据TTS结构不同特权级使用不同栈，我们必须使用不同的栈而非当前的栈。</p>
<p>如果发生了特权级转换，就使用新的特权级对应的栈，压栈过程如下图(ABCD)所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img7.png" alt="img"></p>
<p>也就是依次压入：SS_old、ESP_old、EFLAGS、CS_old、EIP_old、ERROR_CODE</p>
<p>压入SS_old、ESP_old是为了中断结束返回后可以复原原本的栈，压入CS_old、EIP_old是为了中断结束返回后可以返回到原本的代码段，压入ERROR_CODE这一步骤并非是每个中断都有的(只有异常才会有)</p>
<p>中断处理程序结束后，我们调用iret(interrput return)返回，iret会依次弹出栈里3个32位数据赋值给EIP,CS,EFLAGS。这就要求我们在调用iret前必须手动操作栈顶指针跳过ERROR_CODE（有的话才跳过，没有就不用）。调用完iret后还需讲SS_old赋值给SS、ESP_old赋值给ESP，恢复旧特权级的栈。</p>
<p>如果在中断压栈的第一步判断没有发生特权级转换，那就不用那么麻烦，只需要省略上诉步骤中SS_old、ESP_old的压栈和出栈即可。</p>
<p><strong>PS：在中断返回后也会进行一次特权级检查，如果检查到特权级转换，就会将DS、ES、FS、GS的内容全部置0，以放置特权级恢复后任然可以访问高特权级资源</strong></p>
<h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><p>错误码一般只在异常发生时才会有，用来指明哪个段上发生了中断</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img8.png" alt="img"></p>
<p>选择子用来指明段，EXT表示中断源是否是外部硬件，IDT表示选择子是否是指向IDT（IDT&#x3D;1表示指向IDT，IDT&#x3D;0时表示指向GDT&#x2F;LDT），TI（只在IDT&#x3D;0时有意义）表示选择子是否指向GDT（TI&#x3D;0时指向GDT，TI&#x3D;1时指向LDT）</p>
<p>有时候中断的发生与特定的段无关，此时错误码就全为0</p>
<h1 id="可编程中断控制器8259A"><a href="#可编程中断控制器8259A" class="headerlink" title="可编程中断控制器8259A"></a>可编程中断控制器8259A</h1><p>从之前的图可以看出外部设备向CPU传入中断向量号时还需要经过一个中断代理芯片，也就是8259A。其实外部设备并不知道什么中断向量号，外部设备只在需要的时候发出中断信号，其他的琐事全部都交给8259A处理</p>
<h2 id="8259A的结构以及工作流程"><a href="#8259A的结构以及工作流程" class="headerlink" title="8259A的结构以及工作流程"></a>8259A的结构以及工作流程</h2><h3 id="8259A需要处理的事情"><a href="#8259A需要处理的事情" class="headerlink" title="8259A需要处理的事情"></a>8259A需要处理的事情</h3><ol>
<li><p>维护一个中断信号队列（CPU只给出一个引脚用于接受外部中断向量，多个外部设备同时发出中断请求时，8259A就要维护一个中断消息队列）</p>
</li>
<li><p>中断优先级裁决（多个中断请求总要有个优先级吧，由8259A判断）</p>
</li>
<li><p>构造中断向量号（外部设备并不知道中断向量号，是8259A构造中断向量号并发送给CPU）</p>
</li>
</ol>
<h3 id="8259A级联结构"><a href="#8259A级联结构" class="headerlink" title="8259A级联结构"></a>8259A级联结构</h3><p>一片8259A有8个引脚用于接受，一个引脚用于发送，也就是说只能处理8个中断。但是我们可以通过多片8259A进行级联来处理多个中断，最好的情况是用9片8259A(1片主片，8片从片)进行级联，来处理共64个中断号，级联示意图如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img9.png" alt="img"></p>
<p>但我们的个人电脑一般只采用两片8259A级联，只能处理15个中断，示意图如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img10.png" alt="img"></p>
<h3 id="8259A内部结构"><a href="#8259A内部结构" class="headerlink" title="8259A内部结构"></a>8259A内部结构</h3><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img11.png" alt="img"></p>
<p><strong>PS图中所有寄存器均是8位，也就和8259A的8个IRQ(Interrupt ReQuest)引脚一一对应。比如IRR寄存器&#x3D;0x06,代表的意思就是8259A的IRQ1和IRQ2引脚收到了中断请求</strong></p>
<ol>
<li><p>IMR（中断屏蔽寄存器）：哪个位为1，就代表屏蔽了相应引脚的中断信号</p>
</li>
<li><p>IRR（中断请求寄存器）：哪些位为1，就代表有哪些引脚接收到了中断信号，维护了一个消息队列</p>
</li>
<li><p>RP(优先权判别器)：负责从IRR里取出优先权高的中断信息送入ISR和控制电路（默认接口号越低优先权越高）</p>
</li>
<li><p>ISR（中断服务寄存器）：哪个位为1，代表当前正在执行的中断（同一时间只能执行一个中断）。处于ISR中的当前正执行中断是有可能被RP换下来的</p>
</li>
<li><p>控制电路：负责和CPU沟通，通过INT送入中断向量号(初始中断向量号+该中断的接口号)，通过INTA接受CPU的回应</p>
</li>
</ol>
<h3 id="8259A工作流程"><a href="#8259A工作流程" class="headerlink" title="8259A工作流程"></a>8259A工作流程</h3><p>完整流程如下：</p>
<p>某个外设发送中断信号，IMR先检查有没有被屏蔽，没有则送入IRR排队去。PR从IRR中选一个优先级最大并且通知控制电路，控制电路向CPU发送INTR信号（有活干了），CPU收到后回复INTA信号（我准备好了）。8259A收到信号后立即将刚刚选出来的送入ISR（当前就执行这个了）同时将它从IRR中去除（不在排队队列）。</p>
<p>过一会CPU再次发送INTA信号(给我中断向量号)，控制电路计算中断向量号(其实中断向量号+引脚接口号)通过INTR信号发给CPU。</p>
<p>CPU执行完毕后通过INTA信号发送EOI(End of Interrupt)通知,8259A收到EOI后将ISR中相应位置0(你已经执行完了)</p>
<p><strong>PS：上诉流程是8259A的手工模式。如果是自动模式，则当CPU向8259A要中断号时，ISR相应位置就置0了（直接赶人，相信CPU一定会完成的）</strong></p>
<h3 id="我们要做的工作"><a href="#我们要做的工作" class="headerlink" title="我们要做的工作"></a>我们要做的工作</h3><ol>
<li><p>构造好IDT（类似构造GDT）</p>
</li>
<li><p>提供中断向量号</p>
</li>
</ol>
<h2 id="8259A的编程"><a href="#8259A的编程" class="headerlink" title="8259A的编程"></a>8259A的编程</h2><p>8259A提供给程序员操作的寄存器一共有7个ICW1<del>4（Initialization Command Words）和OCW1</del>3（Operation Command Word）如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img12.png" alt="img"></p>
<p>ICW1~ICW4 4个寄存器结构如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img13.png" alt="img"></p>
<ol>
<li><p>ICW1</p>
<ul>
<li>IC4置1代表使用ICW4，置0则代表不使用ICW4（x86要求必须要用ICW4）</li>
<li>SNGL为1表示单片，为0代表使用级联</li>
<li>ADI 用于8085，x86不需要此位</li>
<li>LTIM 用来设置中断检查方式，为0表示边沿触发，为1表示电平触发</li>
<li>第4位是标识符，固定为1</li>
<li>5~7位 用于8085，x86不需要此位</li>
</ul>
</li>
<li><p>ICW2</p>
<p> ICW2用来设置起始中断向量号</p>
<ul>
<li>第3<del>7位由程序员填入，第0</del>2位硬件会根据引脚号自动填入（IQR0就是000，IQR1就是001）</li>
</ul>
</li>
<li><p>ICW3(主片)</p>
<p> ICW3用来表示级联方式，只有设置了级联才需要ICW3。对于ICW3寄存器主片和从片有不同的用途</p>
<ul>
<li>ICW3哪一位为1，就代表主片的哪一个引脚接入了从片</li>
</ul>
</li>
<li><p>ICW3(从片)</p>
<ul>
<li>第0~2位用来表示该从片接入的是主片的哪一个引脚。当主片发送信号时，从片通过比较该寄存器的值和信号来确定该信号是不是发送给自己的</li>
</ul>
</li>
<li><p>ICW4</p>
<p> 只有开启了IC4，ICW4才有意义</p>
<ul>
<li>7~5位未定义</li>
<li>SFNM为0表示全嵌套模式，SFNM为1表示特殊全嵌套模式</li>
<li>BUF表示芯片是否在缓冲模式，1为缓冲模式</li>
<li>M&#x2F;S只有在BUF为缓冲模式时才有意义，1表示是主片，0表示是从片</li>
<li>AEOI表示自动结束中断，AEOI&#x3D;1时表示设置自动结束中断，AEOI&#x3D;0时表示手动模式</li>
<li>uPM表示微处理器类型，uPM为1表示旧的处理器，为1表示x86系列</li>
</ul>
</li>
</ol>
<p>OCW1~OCW3 3个寄存器结构如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img14.png" alt="img"></p>
<ol>
<li><p>OCW1</p>
<ul>
<li>OCW1用来设置屏蔽中断，OCW1哪一位为1就屏蔽掉响应引脚的中断，相当于IMR&#x3D;OCW1</li>
</ul>
</li>
<li><p>OCW2</p>
<p> OCW2用来设置中断结束方式和优先级模式</p>
<ul>
<li><p>第4~3位是标识符，固定为00</p>
</li>
<li><p>SL表示是否启用L2~L0三位，这三位是配合其他模式一起使用的</p>
</li>
<li><p>R表示优先级控制方式<br>  R&#x3D;0表示固定优先级，接口号越低优先级越高。R&#x3D;1表示循环优先级，一开始的优先级是:IR0&gt;IR1&gt;IR2&gt;IR3&gt;IR4&gt;IR5&gt;IR6&gt;IR7。当执行完IR0后就变成了IR1&gt;IR2&gt;IR3&gt;IR4&gt;IR5&gt;IR6&gt;IR7&gt;IR0。当R&#x3D;1时如果SL&#x3D;0，则以L2~L0设置的接口号为最低优先级，然后依次排序下去，例如R&#x3D;1，SL&#x3D;1时L2~L0&#x3D;110，则优先级IR7&gt;IR0&gt;IR1&gt;IR2&gt;IR3&gt;IR4&gt;IR5&gt;IR6</p>
</li>
<li><p>EOI表示中断结束命令位<br>  令EOI为1，则ISR寄存器里最高优先级位清0（处理掉当前中断）。如果EOI&#x3D;1时SL&#x3D;1，则将ISR寄存器里L2~L1指定的位值0。<br>  那么EOI是由谁设置为1的？EOI是在手动结束模式里程序员主动置0的。如果是自动结束模式，则无用</p>
</li>
</ul>
</li>
<li><p>OCW3</p>
<ul>
<li>用不到！懒得看，就记得4~3位是标识符，固定为01</li>
</ul>
</li>
</ol>
<p>我们一共要操纵7个寄存器，那我们是不是需要7个端口号？其实我们对每一片8259A只用两个端口号，端口分别如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img15.png" alt="img"></p>
<p>首先主片和从片的端口号是分开的。</p>
<p>以主片为例：</p>
<p>初始化时写入奇地址0x21的连续三个数据一定依次是ICW2、ICW3、ICW4（因为它们有严格的写入顺序，且中间不能插入其他事务），初始化后写入奇地址0x21就只能是OCW1了</p>
<p>而偶地址0x20里要写入的三个寄存器则可以通过标识符分辨</p>
<h1 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h1><h2 id="当前文件布局"><a href="#当前文件布局" class="headerlink" title="当前文件布局"></a>当前文件布局</h2><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img16.png" alt="img"></p>
<h2 id="（简易版思路）"><a href="#（简易版思路）" class="headerlink" title="（简易版思路）"></a>（简易版思路）</h2><p>简易版中我们的中断程序只做了两件事：</p>
<ol>
<li><p>打印“interrupt occur”</p>
</li>
<li><p>给8259A发送EOI</p>
</li>
</ol>
<p>具体编码思路如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img17.png" alt="img"></p>
<h2 id="（改进版思路）"><a href="#（改进版思路）" class="headerlink" title="（改进版思路）"></a>（改进版思路）</h2><p>我们嫌弃简易版的中断程序太过简单，而且我们打算实现中断处理程序的注册和异常名的注册（没注册就不能使用），所以我们在原有的基础上做了改进。</p>
<p>修改了两个文件：Kernel.S  </p>
<ul>
<li><p>interrupt.c<br>  添加了idt_table[33]用于注册中断程序入口<br>  添加了intr_name[33]用于注册异常名<br>  添加了general_intr_handler()负责处理一般中断程序<br>  添加了负责 中断处理程序注册 和 异常名注册 的exception_init()</p>
</li>
<li><p>kernel.S<br>  原本的中断处理程序改为调用 idt_table[i] 里注册的中断处理程序</p>
</li>
</ul>
<p>改进部分逻辑图如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img18.png" alt="img"></p>
<p>当前情况很奇妙。interrupt.c负责初始化中断描述符表，interrupt.c负责实现一般中断处理程序。但是中断描述符表里的中断处理程序地址却是指向kernel.S。想要调用中断处理程序，就得把权力交给kernel.S，由kernel.S负责调用位于interrupt.c的一般中断处理程序。</p>
<p>为什么要这么麻烦，还要经过kernel.S的转接，我interrupt.c直接全程负责不行吗？kernel.S在这负责实现的一个功能是给33个中断例程入口相邻的地址(这应该是通过.c实现不了的)</p>
<h2 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h2><ul>
<li><p>kernel&#x2F;global.h</p>
<pre><code>  #ifndef __KERNEL_GLOBAL_H__
  #define __KERNEL_GLOBAL_H__


  #define RPL0 0
  #define RPL1 1
  #define RPL2 2
  #define RPL3 3

  #define TI_GDT 0
  #define TI_LDT 1

  //构造选择子
  #define SELECTOR_K_CODE ((1&lt;&lt;3)+(TI_GDT&lt;&lt;2)+RPL0)
  #define SELECTOR_K_DATA ((2&lt;&lt;3)+(TI_GDT&lt;&lt;2)+RPL0)
  #define SELECTOR_K_STACK SELECTOR_K_DATA
  #define SELECTOR_K_GS ((3&lt;&lt;3)+(TI_GDT&lt;&lt;2)+RPL0)

  //IDT描述符属性
  #define IDT_DSEC_P 1
  #define IDT_DSEC_DPL0 0
  #define IDT_DSEC_DPL3 3
  #define IDT_DESC_32_TYPE 0xE    //32位门
  #define IDT_DESC_16_TYPE 0x6    //16位的门，没用到

  #define IDT_DESC_ATTR_DPL0 ((IDT_DSEC_P&lt;&lt;7)+(IDT_DSEC_DPL0&lt;&lt;5)+IDT_DESC_32_TYPE)
  #define IDT_DESC_ATTR_DPL3 ((IDT_DSEC_P&lt;&lt;7)+(IDT_DSEC_DPL3&lt;&lt;5)+IDT_DESC_32_TYPE)

  #endif
</code></pre>
</li>
<li><p>lib&#x2F;kernel&#x2F;io.h</p>
<pre><code>  #ifndef __LIB_KERNEL_IO_H__
  #define __LIB_KERNEL_IO_H__

  #include&quot;stdint.h&quot;

  //向端口port写入一个字节data
  static inline void outb(uint16_t port,uint8_t data)&#123;
      asm volatile(&quot;outb %b0,%w1&quot;::&quot;a&quot;(data),&quot;Nd&quot;(port));
  &#125;

  //将addr处起始的word_cnt个字节写入端口port
  static inline void outsw(uint16_t port,const void* addr,uint32_t word_cnt)&#123;
      asm volatile(&quot;cld; rep outsw&quot;:&quot;+S&quot;(addr),&quot;+c&quot;(word_cnt):&quot;d&quot;(port));
  &#125;

  //从端口port读入一个字节返回
  static inline uint8_t inb(uint16_t port)&#123;
      uint8_t data;
      asm volatile(&quot;inb %w1,%b0&quot;:&quot;=a&quot;(data):&quot;Nd&quot;(port));
      return data;
  &#125;

  //将端口port读入的word_cnt个字节写入addr
  static inline void insw(uint16_t port,const void* addr,uint32_t word_cnt)&#123;
      asm volatile(&quot;cld; rep insw&quot;:&quot;+D&quot;(addr),&quot;+c&quot;(word_cnt):&quot;d&quot;(port):&quot;memory&quot;);
  &#125;

  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;init.h</p>
<p>  #ifndef <strong>KERNEL_INIT_H</strong><br>  #define <strong>KERNEL_INIT_H</strong></p>
<p>  void init_all();</p>
<p>  #endif</p>
</li>
<li><p>kernel&#x2F;init.c</p>
<pre><code>  #include &quot;init.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;

  void init_all()&#123;
      put_str(&quot;init_all\n&quot;);
      idt_init();
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;interrupt.h</p>
<pre><code>  #ifndef __KERNEL_INTERRUPT_H__
  #define __KERNEL_INTERRUPT_H__

  typedef void* intr_handler;

  void idt_init();

  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;interrupt.c</p>
<pre><code>  #include &quot;interrupt.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;global.h&quot;
  #include &quot;print.h&quot;
  #include &quot;io.h&quot;

  #define IDT_DESC_CNT 0x21  //定义了33个中断例程
  #define PIC_M_CTRL 0x20
  #define PIC_M_DATA 0x21
  #define PIC_S_CTRL 0xa0
  #define PIC_S_DATA 0xa1




  struct gate_desc&#123;
      uint16_t func_offset_low_word;
      uint16_t selector;
      uint8_t dcount;
      uint8_t attribute;
      uint16_t func_offset_high_word;
  &#125;;

  char* intr_name[IDT_DESC_CNT]; //用于保存异常名字
  intr_handler idt_table[IDT_DESC_CNT];//用于保存C版本的中断程序


  static struct gate_desc idt[IDT_DESC_CNT];

  extern intr_handler intr_entry_table[IDT_DESC_CNT];
  //c语言通过[bits 32]了解到该数组一个元素4字节，所以能正确定位

  //一般中断处理函数
  static void general_intr_handler(uint8_t vec_nr)&#123;
      if(vec_nr==0x27 || vec_nr == 0x2f)&#123;
          //0x27是伪中断，0x2f是保留项，不用处理
          return;
      &#125;

      put_str(&quot;int vector: 0x&quot;);
      put_int(vec_nr);
      put_char(&#39;\n&#39;);
  &#125;

  //完成一般中断处理函数的注册和异常名称的注册
  static void execption_init(void)&#123;
      int i;
      for(i=0;i&lt;IDT_DESC_CNT;i++)&#123;
          idt_table[i]=general_intr_handler;
          intr_name[i]=&quot;unknow&quot;;
      &#125;
      intr_name[0] = &quot;#DE Divide Error&quot;;
      intr_name[1] = &quot;#DB Debug Exception&quot;;
      intr_name[2] = &quot;NMI Interrupt&quot;;
      intr_name[3] = &quot;#BP Breakpoint Exception&quot;;
      intr_name[4] = &quot;#OF Overflow Exception&quot;;
      intr_name[5] = &quot;#BR BOUND Range Exceeded Exception&quot;;
      intr_name[6] = &quot;#UD Invalid Opcode Exception&quot;;
      intr_name[7] = &quot;#NM Device Not Available Exception&quot;;
      intr_name[8] = &quot;#DF Double Fault Exception&quot;;
      intr_name[9] = &quot;Coprocessor Segment Overrun&quot;;
      intr_name[10] = &quot;#TS Invalid TSS Exception&quot;;
      intr_name[11] = &quot;#NP Segment Not Present&quot;;
      intr_name[12] = &quot;#SS Stack Fault Exception&quot;;
      intr_name[13] = &quot;#GP General Protection Exception&quot;;
      intr_name[14] = &quot;#PF Page-Fault Exception&quot;;
      // intr_name[15] 第15项是intel保留项，未使用
      intr_name[16] = &quot;#MF x87 FPU Floating-Point Error&quot;;
      intr_name[17] = &quot;#AC Alignment Check Exception&quot;;
      intr_name[18] = &quot;#MC Machine-Check Exception&quot;;
      intr_name[19] = &quot;#XF SIMD Floating-Point Exception&quot;;
  &#125;



  static void pic_init(void)&#123;
      //初始化主片
      outb(PIC_M_CTRL,0x11);
      outb(PIC_M_DATA,0x20);
      outb(PIC_M_DATA,0x04);
      outb(PIC_M_DATA,0x01);

      //初始化从片
      outb(PIC_S_CTRL,0x11);
      outb(PIC_S_DATA,0x28);
      outb(PIC_S_DATA,0x02);
      outb(PIC_S_DATA,0x01);

      //打开主片上的IR0,直接受时钟中断
      outb(PIC_M_DATA, 0xfe);
      outb(PIC_S_DATA, 0xff);

      put_str(&quot;    pic_init done\n&quot;);
  &#125;

  static void make_idt_desc(struct gate_desc* p_gdesc,uint8_t attr,intr_handler function)&#123;
      p_gdesc-&gt;func_offset_low_word=(uint32_t)function &amp; 0x0000ffff;
      p_gdesc-&gt;selector=SELECTOR_K_CODE;
      p_gdesc-&gt;dcount=0;
      p_gdesc-&gt;attribute=attr;
      p_gdesc-&gt;func_offset_high_word=((uint32_t)function &amp; 0xffff0000)&gt;&gt;16;
  &#125;

  static void idt_desc_init(void)&#123;
      int i;
      for(i=0;i&lt;IDT_DESC_CNT;i++)&#123;
          make_idt_desc(&amp;idt[i],IDT_DESC_ATTR_DPL0,intr_entry_table[i]);
      &#125;
      put_str(&quot;  ide_desc_init done\n&quot;);
  &#125;


  static void load_idt(uint64_t idt_operand)&#123;
      asm volatile(&quot;lidt %0&quot;::&quot;m&quot;(idt_operand));
      put_str(&quot;idt_init done\n&quot;);
  &#125;



  void idt_init()&#123;
      put_str(&quot;idt_init start\n&quot;);

      idt_desc_init();
      execption_init(); //完成一般中断处理函数的注册和异常名称的注册
      pic_init();


      uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt &lt;&lt; 16));
      load_idt(idt_operand);
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;kernel.S</p>
<pre><code>  [bits 32]

  %define ERROR_CODE nop    ;对于压入错误码的异常不执行任何操纵
  %define ZERO push 0       ;没有压入错误码的中断push 0保证宏定义一致性

  extern put_str 
  extern idt_table

  section .data
  global intr_entry_table
  intr_entry_table:


  ;使用多行宏定义去构造33个中断例程
  ;多行宏定义可以带参数，在宏定义内部用%1,%2依次引用
  %macro VECTOR 2 
  section .text
  intr%1entry:

      %2
      
      ;上下文保护
      push ds
      push es
      push fs
      push gs
      pushad   ;储存8个通用寄存器
      
      ;向主片和从片发送EOI
      mov al,0x20
      out 0xa0,al
      out 0x20,al
      
      push %1   ;压入中断号，调用C的中断处理函数
      call [idt_table + %1*4] 

      jmp intr_exit
  section .data
      dd intr%1entry  
      
  %endmacro

  section .text
  intr_exit:
  ;恢复上下文环境
      add esp,4  ;处理栈中的中断号的参数
      popad
      pop gs
      pop fs
      pop es
      pop ds
      add esp,4
      iretd      ;弹出四字节的EIP和四字节的CS

  VECTOR 0x0 ,ZERO
  VECTOR 0X1 ,ZERO
  VECTOR 0X2 ,ZERO
  VECTOR 0x3 ,ZERO
  VECTOR 0X4 ,ZERO
  VECTOR 0X5 ,ZERO
  VECTOR 0x6 ,ZERO
  VECTOR 0X7 ,ZERO
  VECTOR 0X8 ,ERROR_CODE
  VECTOR 0x9 ,ZERO
  VECTOR 0XA ,ERROR_CODE
  VECTOR 0XB ,ERROR_CODE
  VECTOR 0XC ,ERROR_CODE
  VECTOR 0XD ,ERROR_CODE
  VECTOR 0XE ,ERROR_CODE
  VECTOR 0XF ,ZERO
  VECTOR 0X10 ,ZERO
  VECTOR 0X11 ,ERROR_CODE
  VECTOR 0x12 ,ZERO
  VECTOR 0X13 ,ZERO
  VECTOR 0X14 ,ZERO
  VECTOR 0x15 ,ZERO
  VECTOR 0X16 ,ZERO
  VECTOR 0X17 ,ZERO
  VECTOR 0X18 ,ZERO
  VECTOR 0X19 ,ZERO
  VECTOR 0X1A ,ZERO
  VECTOR 0X1B ,ZERO
  VECTOR 0X1C ,ZERO
  VECTOR 0X1D ,ZERO
  VECTOR 0X1E ,ERROR_CODE                               ;处理器自动推错误码
  VECTOR 0X1F ,ZERO
  VECTOR 0X20 ,ZERO
</code></pre>
</li>
<li><p>kernel&#x2F;main.c</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;

  void main(void)&#123;
      put_str(&quot;I am kernel\n&quot;);
      init_all();
      asm volatile (&quot;sti&quot;); //sti作用是IF=1，即打开中断
      while(1);
  &#125;
</code></pre>
</li>
<li><p>shortcut</p>
<pre><code>  #第七章常用Linux命令

  gcc -m32 -I lib/kernel/ -I kernel/ -c -fno-builtin -o build/main.o kernel/main.c
  #-fno-builtin 作用是禁止编译器将一些内置函数,替换为更高效的指令。

  nasm -f elf -o build/print.o lib/kernel/print.S

  nasm -f elf -o build/kernel.o kernel/kernel.S

  gcc -m32 -I lib/kernel/ -I lib/ -I kernel/ -c -fno-builtin -o build/interrupt.o kernel/interrupt.c

  gcc -m32 -I lib/kernel/ -I lib/ -I kernel/ -c -fno-builtin -o build/init.o kernel/init.c

  ld -m elf_i386 -Ttext 0xc0001500 -e main -o build/kernel.bin build/main.o build/init.o build/interrupt.o build/print.o build/kernel.o

  dd if=/home/sparkle2/codeset/build/kernel.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=200 seek=9 conv=notrunc
</code></pre>
</li>
</ul>
<h2 id="调试思路："><a href="#调试思路：" class="headerlink" title="调试思路："></a>调试思路：</h2><p>本章调试难点是我们不知道中断啥时候会发生，导致无法调试。解决方法如下：</p>
<p>我们在bochs调试时可以用<code>show int</code>打开中断信息打印，它将会打印出中断发生时的信息(包括执行了n条指令后遇到该中断)，得到<code>n</code>就是我们调试的关键。我们可以使用<code>sba n-1</code>指令，让系统执行总共n-1条指令后停止。接下来再用<code>s</code>单步调试，就可以实现准确定位到中断发生地点。<strong>PS：可以用<code>r</code>查看寄存器，也可以用<code>print-stack</code>查看栈</strong></p>
<h1 id="可编程计数器-定时器8253"><a href="#可编程计数器-定时器8253" class="headerlink" title="可编程计数器&#x2F;定时器8253"></a>可编程计数器&#x2F;定时器8253</h1><p>通过定时器8253可以控制时钟中断的频率</p>
<h2 id="8253内部结构"><a href="#8253内部结构" class="headerlink" title="8253内部结构"></a>8253内部结构</h2><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img19.png" alt="img"></p>
<ol>
<li><p>8253内部有三个计数器，三个计数器独立工作。</p>
</li>
<li><p>连接计数器的三个引脚：CLK输入时钟脉冲、GATE用于控制是否工作、OUT用于输出信号</p>
</li>
<li><p>控制字寄存器(8位)用于设置计时器的工作模式</p>
</li>
<li><p>计时器内部有三个16位寄存器</p>
<ul>
<li><p>计数初值寄存器：8253采用倒计时，该寄存器用于存放初始值（不会因为倒计时而改变）</p>
</li>
<li><p>减法计数器：8253的核心部件，从计数初值寄存器里取出初值后每一个时钟脉冲就自减1，为0时向OUT引脚发出计时结束信号。然后再从计数初值寄存器里取值进行新一轮计数</p>
</li>
<li><p>输出锁存器：当你想要查看当前计数时，减法计数器可不会停下来给你看，但是输出锁存器可以帮你完成任务</p>
</li>
</ul>
</li>
</ol>
<p>三个计数器的功能和端口如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img20.png" alt="img"></p>
<p>我们的目标是控制时钟中断频率，所以我们只需要修改计时器0即可</p>
<h2 id="8253控制字寄存器：控制字格式"><a href="#8253控制字寄存器：控制字格式" class="headerlink" title="8253控制字寄存器：控制字格式"></a>8253控制字寄存器：控制字格式</h2><p>8253一个控制字寄存器(端口0x43)用来控制三个计数器，控制字格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img21.png" alt="img"></p>
<h2 id="计数器工作模式和工作原理"><a href="#计数器工作模式和工作原理" class="headerlink" title="计数器工作模式和工作原理"></a>计数器工作模式和工作原理</h2><p>计数器六种工作模式总结：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img22.png" alt="img"></p>
<p>计数器启动必须满足两个条件：(1)GATE为高电平，这是硬件控制，(2)计数值初值已写入减法计数器，这是软件控制。我们把满足条件1等待条件2的称为软件启动；满足条件2等待条件1的称为硬件启动。</p>
<p>在这六种工作模式中，我们要用到的只用工作模式2，下面仔细讲解利用工作模式2实现控制时钟中断的原理：</p>
<p>计时器的工作频率固定是1.19318MHz，也就是说1秒钟计时器会减119318次1。计时器的初值寄存器默认为0（即2^16&#x3D;65536）,每计数65536就会引发一次OUT输出(计时器0的OUT输出对应引发时钟中断)。那么时钟中断的默认频率就应该是119318&#x2F;65536&#x3D;18.206HZ。</p>
<p>我们的目标是修改时钟中断的频率，可得公式<code>时钟中断频率=119318/计时器的初值寄存器的值</code></p>
<h2 id="编码修改时钟中断频率为100HZ"><a href="#编码修改时钟中断频率为100HZ" class="headerlink" title="编码修改时钟中断频率为100HZ"></a>编码修改时钟中断频率为100HZ</h2><ol>
<li><p>往控制寄存器端口0x43中写入控制字</p>
</li>
<li><p>往计时器0端口0x40写入计数初值</p>
</li>
</ol>
<p>代码如下：</p>
<p>新增加device目录专门用来存储设备相关代码</p>
<ul>
<li><p>device&#x2F;timer.c</p>
<pre><code>  #include &quot;timer.h&quot;
  #include &quot;io.h&quot;
  #include &quot;print.h&quot;

  #define IRQ0_FREQUENCY          100
  #define INPUT_FREQUENCY         1193180
  #define COUNTER0_VALUE          INPUT_FREQUENCY/IRQ0_FREQUENCY

  #define COUNTER0_PORT           0x40
  #define COUNTER0_SELECTOR       0
  #define COUNTER0_MODE           2
  #define READ_WRITE_LATCH        3
  #define PIT_CONTROL_PORT        0x43


  static void frequency_set(uint8_t counter_port,uint8_t counter_selector,uint8_t rwl,uint8_t counter_mode,uint16_t counter_value)&#123;

      //写入控制字
      outb(PIT_CONTROL_PORT,(uint8_t)((counter_selector&lt;&lt;6)|(rwl&lt;&lt;4)|(counter_mode&lt;&lt;1)));

      //写入计数器初值寄存器
      outb(counter_port,(uint8_t)counter_value);
      outb(counter_port,(uint8_t)(counter_value&gt;&gt;8));
  &#125;


  void timer_init()&#123;
      put_str(&quot;timer_init start\n&quot;);
      frequency_set(COUNTER0_PORT,COUNTER0_SELECTOR,READ_WRITE_LATCH,COUNTER0_MODE,COUNTER0_VALUE);
      put_str(&quot;timer_init done\n&quot;);
  &#125;
</code></pre>
</li>
<li><p>device&#x2F;timer.h</p>
<pre><code>  #ifndef __DEVICE_TIMER_H__
  #define __DEVICE_TIMER_H__

  void timer_init();

  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;init.c</p>
<pre><code>  #include &quot;init.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;timer.h&quot;

  void init_all()&#123;
      put_str(&quot;init_all\n&quot;);
      idt_init();
      timer_init();
  &#125;
</code></pre>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/21/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/21/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（六）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-21 09:09:48" itemprop="dateCreated datePublished" datetime="2023-11-21T09:09:48+08:00">2023-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-23 19:24:48" itemprop="dateModified" datetime="2023-11-23T19:24:48+08:00">2023-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="函数调用约定简介"><a href="#函数调用约定简介" class="headerlink" title="函数调用约定简介"></a>函数调用约定简介</h1><p>什么是函数调用？调用者和被调用者关于以下事情的共用约定：</p>
<ol>
<li><p>参数的传递顺序（从左到右入栈？还是从右到左入栈？）</p>
</li>
<li><p>参数的传递方式（栈中？还是寄存器中）</p>
</li>
<li><p>是调用者保存寄存器环境？还是被调用者保存寄存器环境？</p>
</li>
</ol>
<p>下图是常见的调用约定简述，注意我们采用的是cdecl，所以只关注cdecl也行：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img1.png" alt="img"></p>
<p>cdecl的特点如下：</p>
<ol>
<li><p>参数保存在栈里并，从右到左入栈</p>
</li>
<li><p>函数返回后，由调用者执行<code>add esp,x</code>来收回栈空间</p>
</li>
</ol>
<h1 id="汇编语言和C语言混合编程"><a href="#汇编语言和C语言混合编程" class="headerlink" title="汇编语言和C语言混合编程"></a>汇编语言和C语言混合编程</h1><p>汇编语言和C语言混合编程可以分为以下两大类:</p>
<ol>
<li><p>单独的汇编文件和单独的C文件分别编译成目标文件(.o)后,一起链接成可执行文件</p>
</li>
<li><p>在C语言里内嵌汇编语言,又叫内联汇编</p>
</li>
</ol>
<p>接下来的部分旨在理解第一类方法，第二类方法将在后续中详细讲解</p>
<h2 id="理解系统调用"><a href="#理解系统调用" class="headerlink" title="理解系统调用"></a>理解系统调用</h2><p>Linux的系统调用同一使用中断入口int 0x80，eax寄存器存储子功能号，共有348个系统调用(不同Linux版本不一样)。当参数大于五个时，用栈存放参数；当参数小于五个时，依次往寄存器ebx,ecx,edx,esi,edi存储参数</p>
<p>调用系统调用的方式有以下两种：</p>
<ol>
<li><p>将系统调用封装成C库函数,通过库函数进行系统调用，操作简单</p>
</li>
<li><p>不依赖任何库，直接通过汇编指令进行系统调用</p>
</li>
</ol>
<p><strong>PS:第一种方法封装的C库函数本质上也是用汇编实现的</strong><br>先简单介绍一下系统调用sys_write，该系统调用的功能是把buf区的len个字节写入file，中断号0x80，子功能号4(放入eax)，参数顺序依次是file，buf，len</p>
<p>我们模拟两种调用方式的代码如下：</p>
<pre><code>;SimuWrite.S: 模拟sys_write的两种调用方式
section .data
str_c_lib: db &quot;c lib say：hello world&quot;,0xa
str_c_lib_len equ $-str_c_lib

str_syscall: db &quot;syscall say:hello world&quot;,0xa
str_syscall_len equ $-str_syscall


section .code:
global _start   ;将_start声明为全局变量，对于外部文件可见
_start:
;---------------模拟C库函数进行系统调用-------------------
push str_c_lib_len
push str_c_lib
push 1        ;文件描述符1表示标准输出(指向屏幕)

call simu_write
add esp,12
;---------------模拟C库函数进行系统调用-------------------    



;---------------跳过C库函数直接进行系统调用------------------- 
mov eax,4
mov ebx,1
mov ecx,str_syscall
mov edx,str_syscall_len
int 0x80
;---------------跳过C库函数直接进行系统调用------------------- 


;退出程序
mov eax,1
int 0x80

;-------------------模拟write的C库函数--------------
simu_write: 
    push ebp
    mov ebp,esp
    mov eax,4
    mov ebx,[ebp+8]
    mov ecx,[ebp+12]
    mov edx,[ebp+16]
    int 0x80
    pop ebp
    ret 
;-------------------模拟write的C库函数--------------
</code></pre>
<p>用以下命令编译链接成可执行文件,并运行：</p>
<pre><code>nasm -f elf -o SimuWrite.o SimuWrite.S
ld -m elf_i386 -o SimuWrite.bin SimuWrite.S
cd ./SimuWrite.bin
</code></pre>
<h2 id="C和汇编相互协作"><a href="#C和汇编相互协作" class="headerlink" title="C和汇编相互协作"></a>C和汇编相互协作</h2><p>请看下图两文件，C和汇编相互协作实现字符串打印功能：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img2.png" alt="img"></p>
<p>调用关系如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img3.png" alt="img"></p>
<h1 id="实现自己的打印函数"><a href="#实现自己的打印函数" class="headerlink" title="实现自己的打印函数"></a>实现自己的打印函数</h1><h2 id="显卡端口控制介绍"><a href="#显卡端口控制介绍" class="headerlink" title="显卡端口控制介绍"></a>显卡端口控制介绍</h2><p>之前我们一直都是通过直接写入显存的方式来在屏幕上显示字符，但现在起我们要通过显卡端口操作的方式来显示字符</p>
<p>下图是所有有关显卡端口的寄存器：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img4.png" alt="img"></p>
<p>看上去有很多，但我们只关注其中一个寄存器组，也就是：CRT Controller Registers</p>
<ol>
<li><p>CRT组有两个寄存器Address Register和Data Register，该怎么使用呢？CRT有许多子功能(子寄存器)，当我们需要使用某一个子功能(子寄存器)时，就往AddressRegister写入该子功能(寄存器)所在的地址，然后就可以从DataRegister读出&#x2F;写入相应的内容了。CRT子功能(子寄存器)地址见下图：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img5.png" alt="img"></p>
<p> <strong>PS：重点关注索引为0Eh和0Fh的Cursor Location Register，这是我们本章需要使用的</strong></p>
</li>
<li><p>Address Register和Data Register的地址都有一位x是未知的，它取决于Input&#x2F;Output Address Select字段，但不用太担心，该字段默认为1，也就是说，Addr和Data寄存器地址默认为0x3d4h和0x3d5h</p>
</li>
</ol>
<h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><p>首先我们创建一个kernel文件夹和lib文件夹，kernel文件夹用于存放和内核相关代码，lib则是用于存放我们实现的库函数。其中，lib里又分为文件夹kernel和user，反别存储给内核用的库函数和给用户程序用的库函数。</p>
<h3 id="实现打印一个字符的库函数-put-char"><a href="#实现打印一个字符的库函数-put-char" class="headerlink" title="实现打印一个字符的库函数 put_char()"></a>实现打印一个字符的库函数 put_char()</h3><p>实现put_char()的基本思路如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img6.png" alt="img"></p>
<ol>
<li><p>codeset&#x2F;lib&#x2F;kernel&#x2F;stdint.h(standard int用于定义一些我们自己的标准的数据类型)</p>
<pre><code> #ifndef __LIB_STDINT_H__
 #define __LIB_STDINT_H__
 //加入路径方便编译器寻找

 typedef signed char int8_t;
 typedef signed short int int16_t;
 typedef signed int int32_t;
 typedef signed long long int int64_t;
 typedef unsigned char uint8_t;
 typedef unsigned short int uint16_t;
 typedef unsigned int uint32_t;
 typedef unsigned long long int uint64_t;

 #endif
</code></pre>
</li>
<li><p>codeset&#x2F;lib&#x2F;kernel&#x2F;print.h(自定义打印函数print的头文件，负责声明函数)</p>
<pre><code> #ifndef __LIB_KERNEL_PRINT_H
 #define __LIB_KERNEL_PRINT_H

 #include &quot;stdint.h&quot;
 // 用&quot;&quot;引用的头文件一般是自己编写的，编译器将会在当前目录寻找目标
 //用&lt;&gt;引用的头文件，编译器将会在系统预先设置的默认路径里寻找目标

 void put_char(uint8_t char_asci);

 #endif
</code></pre>
</li>
<li><p>codeset&#x2F;kernel&#x2F;print.S(汇编代码实现的打印函数本体put_char)</p>
<pre><code> TI_GDT  equ 0
 RPL0    equ 0
 SELECTOR_VIDEO equ (0x3)&lt;&lt;3+TI_GDT+RPL0


 [bits 32]
 section .text

 global put_char

 ;将栈里一个字符打印到屏幕上
 put_char:   
     pushad
         
     mov ax,SELECTOR_VIDEO 
     mov gs,ax
     ;这边将gs重新赋选择子的原因是，当用户进程从内核返回时,寄存器(DS、ES、FS、GS)有可能都被为了安全而置0
     ;而我们每一次调用print时都给gs重新赋值，就不怕遇到上述问题了
     
 ;-------------获取光标位置，存入bx---------------------------
     
     ;高八位
     mov dx,0x03d4
     mov al,0x0e
     out dx,al
     mov dx,0x03d5 
     in  al,dx
     mov ah,al 
     
     ;低八位
     mov dx,0x03d4
     mov al,0x0f
     out dx,al
     mov dx,0x03d5
     in al,dx
     
     mov bx,ax 
 ;-------------获取光标位置，存入bx---------------------------
 

 ;-------------取出参数判断并处理--------------------------- 
     mov ecx,[esp+36]  
     cmp cl,0x0d;回车 
     jz .is_carriage_return
     cmp cl,0x0a;换行
     jz .is_line_feed
     cmp cl,0x8;删除
     jz .is_backspace
     jmp .put_other
 ;-------------取出参数判断并处理--------------------------- 


 ;-------------处理删除--------------------------- 
 .is_backspace: 
     dec bx
     shl bx,1    ;一个字符占用2字节,光标位置&lt;&lt;1=光标地址
     mov byte [gs:bx],0x20
     inc bx
     mov byte [gs:bx],0x07
     shr bx,1
     jmp .set_cursor
 ;-------------处理删除---------------------------  

 ;-------------处理其他字符--------------------------- 
 .put_other:
     shl bx,1
     mov byte [gs:bx],cl
     inc bx
     mov byte [gs:bx],0x07
     shr bx,1
     inc bx
     cmp bx,2000
     jl .set_cursor
 ;-------------处理其他字符---------------------------  

 ;-------------处理回车/换行字符---------------------------
 .is_line_feed:
 .is_carriage_return:
     mov si,80
     xor dx,dx
     mov ax,bx
     div si
     sub bx,dx
 .is_carriage_return_end:
     add bx,80
     cmp bx,2000
 .is_line_feed_end:
     jl .set_cursor 

 ;-------------处理回车/换行字符--------------------------- 

 ;-------------处理换屏---------------------------
 .roll_screen:    
     cld
     
     ;将屏幕的1~24行复制到0~23行 
     mov ecx,960
     mov esi,0xc008ba00
     mov edi,0xc008b000
     rep movsd       
     
     ;将屏幕的第24行清空
     mov ecx,80
     mov ebx,3840
 .clear:
     mov word [gs:ebx],0x0720
     add ebx,2
     loop .clear 
     mov bx,1920
 ;-------------处理换屏---------------------------


 ;-------------设置光标位置---------------------------
 .set_cursor:
     mov dx,0x03d4
     mov al,0x0e
     out dx,al
     mov dx,0x03d5
     mov al,bh
     out dx,al
     
     mov dx,0x03d4
     mov al,0x0f
     out dx,al
     mov dx,0x03d5
     mov al,bl
     out dx,al
 
 ;-------------设置光标位置---------------------------        
 .put_char_done:
     popad
     ret
</code></pre>
</li>
<li><p>codeset&#x2F;kernel&#x2F;main.c</p>
<pre><code> #include &quot;print.h&quot;

 void main(void)&#123;
     put_char(&#39;k&#39;);
     put_char(&#39;e&#39;);
     put_char(&#39;r&#39;);
     put_char(&#39;n&#39;);
     put_char(&#39;e&#39;);
     put_char(&#39;l&#39;);
     put_char(&#39;\n&#39;);
     put_char(&#39;1&#39;);
     put_char(&#39;2&#39;);
     put_char(&#39;\b&#39;);
     put_char(&#39;3&#39;);
     while(1);
 &#125;
</code></pre>
</li>
<li><p>编译并连接文件</p>
<pre><code> nasm -f elf -o lib/kernel/print.o lib/kernel/print.S
 # 将 汇编代码print.S 以elf文件的格式编译成 print.o

 gcc -m32 -I lib/kernel/ -c -o kernel/main.o kernel/main.c
 # 将 C代码main.c 以32位文件的格式编译成 main.o,并指定了头文件目录

 ld -m elf_i386 -Ttext 0xc0001500 -e main -o kernel/kernel.bin kernel/main.o lib/kernel/print.o
 # 使用elf_i386的文件格式链接 main.o和print.o 成 kernel.bin。并指定起始虚拟地址0xc0001500，以及代码入口地址main
 # 链接顺序必须满足&quot;调用在前，实现在后&quot;
</code></pre>
<p> 注意：引用头文件和链接不是一件事，引用头文件相当于将头文件内容复制到引用的位置并展开，链接则是对多个文件的地址进行统一编排。</p>
</li>
</ol>
<h3 id="实现打印字符串和打印整数的库函数-put-str-put-int"><a href="#实现打印字符串和打印整数的库函数-put-str-put-int" class="headerlink" title="实现打印字符串和打印整数的库函数 put_str() put_int()"></a>实现打印字符串和打印整数的库函数 put_str() put_int()</h3><p>掌握了put_char后，实现put_str()和put_int()也就方便了许多</p>
<p>完整代码如下：</p>
<ol>
<li><p>codeset&#x2F;lib&#x2F;kernel&#x2F;stdint.h(standard int用于定义一些我们自己的标准的数据类型)</p>
<p> 该文件不做修改，和上面一样</p>
</li>
<li><p>codeset&#x2F;lib&#x2F;kernel&#x2F;print.h(自定义打印函数print的头文件，负责声明函数)</p>
<pre><code> #ifndef __LIB_KERNEL_PRINT_H__
 #define __LIB_KERNEL_PRINT_H__

 #include &quot;stdint.h&quot;

 void put_char(uint8_t char_asci); 
 void put_str(char* message);
 void put_int(uint32_t num);

 #endif
</code></pre>
</li>
<li><p>codeset&#x2F;kernel&#x2F;print.S(汇编代码实现的打印函数本体put_char、put_str、put_int)</p>
<pre><code> TI_GDT  equ 0
 RPL0    equ 0
 SELECTOR_VIDEO equ (0x3)&lt;&lt;3+TI_GDT+RPL0 


 section .data
     put_int_buffer dq 0 ;定位8字节缓冲区用于把数字转换到字符


 [bits 32]
 section .text
 ;---------------------put_char-----------------------------------
 global put_char

 ;将栈里一个字符打印到屏幕上
 put_char:   
     pushad
         
     mov ax,SELECTOR_VIDEO 
     mov gs,ax
     
 ;-------------获取光标位置，存入bx---------------------------
     
     ;高八位
     mov dx,0x03d4
     mov al,0x0e
     out dx,al
     mov dx,0x03d5 
     in  al,dx
     mov ah,al 
     
     ;低八位
     mov dx,0x03d4
     mov al,0x0f
     out dx,al
     mov dx,0x03d5
     in al,dx
     
     mov bx,ax 
 ;-------------获取光标位置，存入bx---------------------------
 

 ;-------------取出参数判断并处理--------------------------- 
     mov ecx,[esp+36]  
     cmp cl,0x0d;回车 
     jz .is_carriage_return
     cmp cl,0x0a;换行
     jz .is_line_feed
     cmp cl,0x8;删除
     jz .is_backspace
     jmp .put_other
 ;-------------取出参数判断并处理--------------------------- 


 ;-------------处理删除--------------------------- 
 .is_backspace: 
     dec bx
     shl bx,1
     mov byte [gs:bx],0x20
     inc bx
     mov byte [gs:bx],0x07
     shr bx,1
     jmp .set_cursor
 ;-------------处理删除---------------------------  

 ;-------------处理其他字符--------------------------- 
 .put_other:
     shl bx,1
     mov byte [gs:bx],cl
     inc bx
     mov byte [gs:bx],0x07
     shr bx,1
     inc bx
     cmp bx,2000
     jl .set_cursor
 ;-------------处理其他字符---------------------------  

 ;-------------处理回车/换行字符---------------------------
 .is_line_feed:
 .is_carriage_return:
     mov si,80
     xor dx,dx
     mov ax,bx
     div si
     sub bx,dx
 .is_carriage_return_end:
     add bx,80
     cmp bx,2000
 .is_line_feed_end:
     jl .set_cursor 

 ;-------------处理回车/换行字符--------------------------- 

 ;-------------处理换屏---------------------------
 .roll_screen:    
     cld
     
     ;将屏幕的1~24行复制到0~23行 
     mov ecx,960
     mov esi,0xc008ba00
     mov edi,0xc008b000
     rep movsd       
     
     ;将屏幕的第24行清空
     mov ecx,80
     mov ebx,3840
 .clear:
     mov word [gs:ebx],0x0720
     add ebx,2
     loop .clear 
     mov bx,1920
 ;-------------处理换屏---------------------------


 ;-------------设置光标位置---------------------------
 .set_cursor:
     mov dx,0x03d4
     mov al,0x0e
     out dx,al
     mov dx,0x03d5
     mov al,bh
     out dx,al
     
     mov dx,0x03d4
     mov al,0x0f
     out dx,al
     mov dx,0x03d5
     mov al,bl
     out dx,al
 
 ;-------------设置光标位置---------------------------        
 .put_char_done:
     popad
     ret
 ;---------------------put_char----------------------------------- 
     
     
 ;---------------------put_str-----------------------------------
 ;以栈中参数为起点打印字符，直到遇见“\0”
 global put_str
 put_str:
     push ebx
     push ecx
     xor ecx,ecx
     mov ebx,[esp+12]
 .goon:
     mov cl,[ebx]
     cmp cl,0
     jz .str_over
     push ecx
     call put_char
     add esp,4   ;负责清理栈空间
     inc ebx
     jmp .goon
 .str_over:
     pop ecx
     pop ebx
     ret 
 ;---------------------put_str-----------------------------------


 ;---------------------put_int-----------------------------------
 ;将栈中的32为int整数打印出来
 global put_int
 put_int:
     pushad 

 ;---------------------将整数的每一位变成ASCII码形式放入put_int_buff----------
     mov ebp,esp
     mov eax,[ebp+36]
     
     mov edi,7 
     mov ebx,put_int_buffer
     mov ecx,8
     
 .16based_4bits:
     mov edx,eax
     and edx,0x0f
     cmp edx,9
     jg .is_AToF 
     add edx,&#39;0&#39; 
     jmp .store

 .is_AToF:
     sub edx,10
     add edx,&#39;A&#39;

 .store:
     mov [ebx+edi],dl
     dec edi
     shr eax,4
     loop .16based_4bits
 ;---------------------将整数的每一位变成ASCII码形式放入put_int_buff----------
 
 
 ;---------------------跳过put_int_buff前面多余的0-------------------
 .ready_to_print:
     inc edi
 .skip_prefix_0:
     cmp edi,8
     je .full0

 .go_on_skip:
     mov cl,[put_int_buffer+edi]
     inc edi
     cmp cl,&#39;0&#39;
     je .skip_prefix_0
     dec edi
     jmp .put_each_num
     
 ;---------------------跳过put_int_buff前面多余的0-------------------


 ;-----------------------将put_int_buff剩下的数字打印出来--------------
 .full0:
     mov cl,&#39;0&#39;
 .put_each_num:
     push ecx
     call put_char
     add esp,4
     inc edi
     mov cl,[put_int_buffer+edi]
     cmp edi,8
     jl .put_each_num
     
     popad
     ret
 ;-----------------------将put_int_buff剩下的数字打印出来--------------


 ;---------------------put_int-----------------------------------
</code></pre>
</li>
<li><p>codeset&#x2F;kernel&#x2F;main.c</p>
<pre><code> #include &quot;print.h&quot;

 void main(void)&#123;
     put_char(&#39;k&#39;);
     put_char(&#39;e&#39;);
     put_char(&#39;r&#39;);
     put_char(&#39;n&#39;);
     put_char(&#39;e&#39;);
     put_char(&#39;l&#39;);
     put_char(&#39;\n&#39;);
     put_char(&#39;1&#39;);
     put_char(&#39;2&#39;);
     put_char(&#39;\b&#39;);
     put_char(&#39;3&#39;);
     put_char(&#39;\n&#39;);
     put_str(&quot;I am kernel\n&quot;);
     put_int(0x00000000);
     put_char(&#39;\n&#39;);
     put_int(0x12345678);
     put_char(&#39;\n&#39;);
     put_int(0x06aef2);
     put_char(&#39;\n&#39;);
     while(1);
 &#125;
</code></pre>
</li>
</ol>
<h1 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h1><p>内联汇编就是在C代码里镶嵌汇编代码，让C可以做更底层的事(掌管寄存器)</p>
<h2 id="AT-T-语法简介"><a href="#AT-T-语法简介" class="headerlink" title="AT&amp;T 语法简介"></a>AT&amp;T 语法简介</h2><p>汇编语言有两种语法：Intel语法和AT&amp;T语法。镶嵌在C代码里的汇编语言只能使用AT&amp;T语法</p>
<p>Winodws和Dos下的汇编一般都是Intel语法(也是我们之前用的)，Unix和Linux内核中的汇编代码则一般使用AT&amp;T语法(我们现在要学的)</p>
<p>Intel语法和AT&amp;T的汇编分格区别主要如下（重点关注前3个）：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img7.png" alt="img"> </p>
<p>AT&amp;T的寻址方式和Intel差别较大，但是AT&amp;T所有寻址方式都可用下式概括：</p>
<pre><code>base_address(offset_address,index,size)

;相当于是 base_address+offset_address+index*size
;base_address是基址,offset_addr是偏移地址,size只能是1、2、4、8的长度
;base_address、offset_address、index*size三个部分可以任意组合，不一定要全部用到
</code></pre>
<p>实例：</p>
<ul>
<li><p>直接寻址：</p>
<pre><code>  mov $6,var          ;只有base_address,var相当于是base_address,其他部分省略
</code></pre>
</li>
<li><p>寄存器间接寻址：</p>
<pre><code>  mov (%eax),%bx      ;只有offset_address,eax就是从当offset_address
</code></pre>
</li>
<li><p>寄存器相对寻址：</p>
<pre><code>  mov -4(%ebx),%al    ;组合使用offset_address和base_address,相当于地址`-4+ebx`指向的内容负责到寄存器al里
</code></pre>
</li>
<li><p>变址寻址：</p>
<pre><code>  ;相当于任意使用三部分的组合
  movl %eax,(,%esi,2)                 ;将eax写入esi*2所指向的内存

  movl %eax,(%ebx,%esi,2)             ;将eax写入ebx+esi*2所指向的内存

  movl %eax,base_value(,%esi,2)       ;将eax写入base_value+esi*2所指向的内存

  movl %eax,base_value(%ebx,%esi,2)   ;将eax写入base_value+ebx+esi*2所指向的内存
</code></pre>
</li>
</ul>
<h2 id="基本内联汇编"><a href="#基本内联汇编" class="headerlink" title="基本内联汇编"></a>基本内联汇编</h2><p>基本内敛汇编是最简单的内联形式，格式如下：</p>
<pre><code>asm [volatile] (&quot;assembly code&quot;)
</code></pre>
<p>asm是声明内联汇编表达式，<code>[volatile]</code>是可选关键字（告诉GCC：不要修改&#x2F;优化我的代码，请原样保留）</p>
<p>“assembly code”是我们所写的汇编代码，它必须满足以下格式要求：</p>
<ol>
<li><p>指令必须用””括起来，无论是一条指令还是多条指令</p>
</li>
<li><p>一对引号之间不能跨行，跨行需要在结尾用’&#39;转义</p>
</li>
<li><p>多条指令之间用’;’隔开</p>
</li>
</ol>
<p>实例：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img8.png" alt="img"> </p>
<p><strong>PS：观察上图，我们在”assembly code”中是可以引用C的变量的，但必须声明为全局变量。这是基本内联汇编的局限性，它能力不够，所以我们还需要扩展内联汇编</strong></p>
<h2 id="扩展内联汇编"><a href="#扩展内联汇编" class="headerlink" title="扩展内联汇编"></a>扩展内联汇编</h2><h3 id="扩展内联汇编格式总览"><a href="#扩展内联汇编格式总览" class="headerlink" title="扩展内联汇编格式总览"></a>扩展内联汇编格式总览</h3><p>扩展内联汇编的格式如下：</p>
<pre><code>asm [volatile] (&quot;assembly code&quot;:output:input:clobber/modify)
</code></pre>
<p>output用来指定汇编代码数据如何传输给C代码使用；input用来指定C代码数据如何传输给汇编代码使用；clobber&#x2F;modify用来通知gcc有哪些资源被隐式更改了，需要提前保护起来。</p>
<p>（）里的四个部分都是可选的，如果不使用该部分必须保留’:’</p>
<p>output格式如下：</p>
<pre><code>&quot;操作符修饰符约束名&quot;（C变量名）  ;操作数修饰符  和  约束名 是两个不同的部分，但是它们要贴在一起写
</code></pre>
<p>input格式如下：</p>
<pre><code>&quot;[操作符修饰符]约束名&quot;（C变量名）  ;操作数修饰符是可选的
</code></pre>
<h3 id="约束名"><a href="#约束名" class="headerlink" title="约束名"></a>约束名</h3><p>约束名有四种：寄存器约束、内存约束、立即数约束、通用约束</p>
<h4 id="寄存器约束"><a href="#寄存器约束" class="headerlink" title="寄存器约束"></a>寄存器约束</h4><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img9.png" alt="img"> </p>
<p>实例请看下图（第一图基本内联汇编示例，第二图是扩展内联汇编示例）</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img10.png" alt="img"> </p>
<ol>
<li><p>扩展内联汇编示例中的output部分中使用了操作数修饰符’&#x3D;’，这里先忽视它，当作没看到；</p>
</li>
<li><p>“assembly code”里寄存器前缀用了”%%”,这是因为和占位符<code>%</code>起冲突,占位符会在后面介绍，总之在”assembly code”里寄存器前缀得用”%%”</p>
</li>
<li><p>output里的<code>&quot;=a&quot;(out_sum)</code>功能相当于基本汇编里的<code>movl %eax,out_sum</code></p>
</li>
<li><p>input里的<code>&quot;a&quot;(in_a),&quot;b&quot;(in_b)</code>相当于基本汇编里的<code>movl in_a,%eax ;  movl in_b,%ebx</code></p>
</li>
</ol>
<h4 id="内存约束"><a href="#内存约束" class="headerlink" title="内存约束"></a>内存约束</h4><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img11.png" alt="img"></p>
<p>C语言代码里的局部变量本身就是存在内存里的，用寄存器约束相当于把内存里的值取到寄存器里进行操作，而使用内存约束则是直接对内存空间进行操作</p>
<p>实例：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img12.png" alt="img"></p>
<p><strong>PS：%b0相当于是对al的引用，%1相当于是对内存in_b的引用，这涉及到占位符，后面细说</strong></p>
<h4 id="立即数约束-and-通用约束"><a href="#立即数约束-and-通用约束" class="headerlink" title="立即数约束 and 通用约束"></a>立即数约束 and 通用约束</h4><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img13.png" alt="img"></p>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><h4 id="序号占位符"><a href="#序号占位符" class="headerlink" title="序号占位符"></a>序号占位符</h4><p>格式是<code>%0~9</code>，按照output和intput中的操作数从左到右出现次序从0开始编号，一直到9，也就是说最多支持10个序号占位符</p>
<p>占位符相当于是对相应操作符的引用</p>
<p>为了可以更加细致的操作寄存器，引入了一个参数（机器模式）来控制具体的寄存器究竟是eax？还是ax？还是ah？还是al?</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img8.png" alt="img"> </p>
<p>实例1：</p>
<pre><code>asm(&quot;inc %h0&quot;::&quot;a&quot;(in_a))
;%0代表寄存器eax，%h0代表寄存器ah，%b0代表寄存器al
</code></pre>
<p>实例2：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img14.png" alt="img"></p>
<h4 id="名称占位符"><a href="#名称占位符" class="headerlink" title="名称占位符"></a>名称占位符</h4><p>不怎么用，看看图自己理解去吧：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img15.png" alt="img"></p>
<h3 id="操作数修饰符"><a href="#操作数修饰符" class="headerlink" title="操作数修饰符"></a>操作数修饰符</h3><p>output里有三种可选的操作数修饰符（重点关注），input里只有一种操作数修饰符（看不懂就不要看）：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/img16.png" alt="img"></p>
<h3 id="clobber-modify"><a href="#clobber-modify" class="headerlink" title="clobber&#x2F;modify"></a>clobber&#x2F;modify</h3><p>clobber&#x2F;modify是用来通知GCC哪些内容（内存&#x2F;寄存器）会被我修改掉，你要保护好；但是clobber&#x2F;modify只需要通知隐式的修改，在input和output标明的部分无需专门再去声明。</p>
<p>实例：</p>
<pre><code>asm(&quot;movl %%eax,%0; movl %%eax,%%ebx&quot;:&quot;=m&quot;(ret_value)::&quot;bx&quot;)
;output里对内存的修改是显示的，不同通知；对bx的修改是gcc不知道的，要通知，多个通知之间用&#39;,&#39;隔开
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/15/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/15/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（五）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-15 11:40:48" itemprop="dateCreated datePublished" datetime="2023-11-15T11:40:48+08:00">2023-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 22:50:44" itemprop="dateModified" datetime="2023-12-30T22:50:44+08:00">2023-12-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本章我们用C语言编写一个简易内核并编译链接，然后用loader程序加载该内核并初始化</p>
<p>进行这章之前要将gcc降级为gcc-4.4，如何给gcc降级请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/wu11zhike/article/details/83865549?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">ubuntu 16.04 gcc高低版本切换</a></p>
<h1 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h1><p>接触虚拟内存之前我们要知道如何获取物理内存，我们先学习使用BIOS中断int 0x15的三个子功能来获取物理内存</p>
<h2 id="利用BIOS中断0x15子功能0xe820来获取内存"><a href="#利用BIOS中断0x15子功能0xe820来获取内存" class="headerlink" title="利用BIOS中断0x15子功能0xe820来获取内存"></a>利用BIOS中断0x15子功能0xe820来获取内存</h2><p>0xe820功能最强大也最复杂，它会遍历主机上的所有内存并以ARDS（Address Range Descriptor Structure）的形式按照类型连续返回主机上的内存</p>
<ol>
<li><p>ARDS结构</p>
<p> ARDS的结构如下图（上图是ARDS，下图是ARDS中Type字段的描述）：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img1.png" alt="img"></p>
<p> <strong>PS：图中我们发现基地址和长度都是用64位表示的，但我们是32位CPU，所以说我们只关注低32位即可</strong></p>
<p> 为什么该子功能会按类型来返回内存信息？原因是这段内存可能是系统的ROM、或者是ROM用到了这部分内存、或者由于某些原因这段内存不适合标准设备使用。但这些我们都不用理会，我们只需要知道在返回的所有ARDS结构中，范围最大的内存一定是操作系统可使用的部分（也就是我们在主板上配置的物理内存容量）</p>
</li>
<li><p>0xe820调用说明</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img2.png" alt="img"></p>
</li>
</ol>
<h2 id="利用BIOS中断0x15子功能0xe801来获取内存"><a href="#利用BIOS中断0x15子功能0xe801来获取内存" class="headerlink" title="利用BIOS中断0x15子功能0xe801来获取内存"></a>利用BIOS中断0x15子功能0xe801来获取内存</h2><p>0xe801用法比较简单，但是功能并不强大；分别检测低15MB和16MB~4GB的内存，最大支持检测4GB（对32位CPU来说刚好够用）</p>
<ol>
<li><p>0xe801调用说明</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img3.png" alt="img"></p>
</li>
<li><p>对0xe801功能的疑惑解答</p>
<p> 为什么要划分为前15MB和16MB以上？原因是为了兼容80286(80286寻址空间是16MB)。</p>
<p> 下图是0xe801调用的实例：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img4.png" alt="img"></p>
<p> 我们发现，实际物理内存总是比检测到的内存多1MB，因为为了兼容80286系统导致系统中有一块保留的但不可视也不可用的1MB内存空洞，我们无需管那么所，我们只要知道用0xe801检测出来的内存空间要加上1MB才是实际的物理内存</p>
</li>
</ol>
<h2 id="利用BIOS中断0x15子功能0xe88来获取内存"><a href="#利用BIOS中断0x15子功能0xe88来获取内存" class="headerlink" title="利用BIOS中断0x15子功能0xe88来获取内存"></a>利用BIOS中断0x15子功能0xe88来获取内存</h2><p>最简单，但是最大只能检测64MB大小的内存，调用说明如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img5.png" alt="img"></p>
<h2 id="实战代码："><a href="#实战代码：" class="headerlink" title="实战代码："></a>实战代码：</h2><p>我们在原有的loader.S文件里添加了获取内存的代码，代码如下:</p>
<pre><code>;loader.S 负责构建gpt后，查看物理内存
%include &quot;boot.inc&quot;
SECTION loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
jmp loader_start                      		   ;跳跃到代码区


    ;构建gpt及其内部的描述符
    ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
    ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
    GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                dd 0x00000000 

    CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                dd DESC_CODE_HIGH4

    ;这边数据段和栈段共用一个段
    ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
    ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
    ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
    ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
    DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                        dd DESC_DATA_HIGH4

    VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                dd DESC_VIDEO_HIGH4     	  
                    
    GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
    GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

    times 60 dq 0                              ;预留60个 四字型 描述符
    
    ;------------------------数据段更新部分-----------------------------------
                    
    ;total_men_bytes用来存储检测出来的内存大小，loader.bin我们装载在0x900起始地址,当前位置偏移文件头0x203字节(前面的数据定义占据512字节，jmp指令占据3字节)
    ;也就是说total_men_bytes在内存地址0xb03（后面用`mov ax,total_men_bytes`指令检测正确性）
    total_mem_bytes dd 0  
    
    ;gdt指针
    gdt_ptr         dw GDT_LIMIT
                    dd GDT_BASE
    
    ;ards_buf是存放ARDS的缓冲区，之所以要244个字节是为了实现地址对齐,ards_nr是记录ARDS的数量
    ;total_men_bytes4+gdt_ptr6+ards_buf244+ards_nr2=256字节
    ards_buf times 244  db  0
    ards_nr             dw  0               
    
    ;----------------------------------------------------------------------------
    ;构造16位的段选择子
    SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
    SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
    SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0


    loadermsg db   &#39;welcome to loader zone!&#39;                  ;loadermsg 加载区显示字符
    
    
    
;以下代码则是开始查内存
loader_start:
;--------------------------------- 代码段更新 -----------------------------    
    mov eax,total_mem_bytes ;该条指令用于调试时验证total_men_bytes的真正地址，结果确实是0xb03
    
    ;使用0xe820的子功能进行内存查询
    mov eax,0xe820
    xor ebx,ebx
    mov ecx,20 
    mov edx,0x534d4150
    mov di,ards_buf
    
.e820_men_get_loop:    
    int 0x15
    jc .e801_failed_so_try_e801 
    mov eax,0xe820
    add di,cx
    inc word [ards_nr]
    mov ecx,20
    cmp ebx,0
    jnz .e820_men_get_loop   

    ;使用冒泡排序找出内存最大值
    mov cx,[ards_nr]
    xor edx,edx  ;edx用于冒泡排序中存储内存最大值  
    mov esi,ards_buf 
.seek_max_men: 
    mov eax,[esi] 
    add eax,[esi+8] 
    cmp eax,edx
    jb .pass_swap
    mov edx,eax
.pass_swap:
    add esi,20
    loop .seek_max_men
    jmp .men_get_ok
    
    
;0xe820失败，使用0xe801测试内存   
.e801_failed_so_try_e801:   
    mov ax,0xE801
    int 0x15
    jc .e801_failed_so_try_88 
    mov ax,1024
    mul cx
    shl edx,16
    and eax,0x0000FFFF
    or edx,eax 
    add edx,0x100000
    mov esi,edx
    xor eax,eax
    mov ax,bx
    mov ecx,0x10000
    mul ecx
    add esi,eax 
    mov edx,esi
    jmp .men_get_ok


;0xe801失败，使用0x88测试内存
.e801_failed_so_try_88:
    mov ah,0x88
    int 0x15
    jc .error_hlt
    and eax,0x0000FFFF
    mov cx,0x400
    mul cx
    shl edx,16
    or edx,eax
    add edx,0x100000 
    jmp .men_get_ok

.error_hlt:
    jmp $
    
.men_get_ok:    
    mov [total_mem_bytes],edx      
;---------------------------------------------------------------------------------    
    
    ;这段和之前一样，调用BIOS提供的int10功能显示字符
    mov sp,LOADER_BASE_ADDR					
    mov bp,loadermsg                                           
    mov cx,23     
    mov ax,cs                                                 
    mov es,ax                                                 
    mov ax,0x1301                                             
    mov bx,0x001f                                           
    mov dx,0x1800                                             
    int 0x10

    ; --------------------------------- 设置进入保护模式 -----------------------------
    ; 1 打开A20 gate 
    in al,0x92                
    or al,0000_0010b
    out 0x92,al

    ; 2 加载gdt
    lgdt [gdt_ptr] 

    ; 3 将cr0 的 pe位置1
    mov eax,cr0                
    or  eax,0x00000001              
    mov cr0,eax
    
    ;-------------------------------- 已经打开保护模式 ---------------------------------------
    jmp dword SELECTOR_CODE:p_mode_start                       
    ;前面是16位指令，后面是32位指令，CPU由于流水线技术无法直接处理混合在一起的二者，利用无转跳指令刷新一下流水线即可
    ;dword指定访问数据为32位，进入了保护模式后，操作数变为32位，这里声明选择子和偏移量都是32位操作数

[bits 32]
p_mode_start: 
    ;是初始化段选择子
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax
    
    ;测试显存段
    mov byte [gs:160],&#39;P&#39; 
    
    jmp $     
</code></pre>
<p><strong>PS：在这里学到一个以前不了解的汇编知识，假如我有个标号loader_start:，这个标号里面还有个标号.error_hit:则第二个标号的全称其实是loader_start.error_hit,它属于是第一个标号的子标号只能在loader_start的作用范围内使用.error_hit这个标号的名字，否则要使用全称</strong>     </p>
<h1 id="启用分页机制"><a href="#启用分页机制" class="headerlink" title="启用分页机制"></a>启用分页机制</h1><h2 id="为什么要分页？"><a href="#为什么要分页？" class="headerlink" title="为什么要分页？"></a>为什么要分页？</h2><p>我们只有4GB的内存空间，但我们想让每一个程序都拥有（或者以为自己拥有）4GB的内存空间，于是有了分页机制。</p>
<ol>
<li><p>分页机制是在内存分段的基础上进行的</p>
</li>
<li><p>分页机制的核心思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续</p>
</li>
<li><p>一个程序它申请4GB的内存空间，实际上它并不是每时每刻都需要全部的4GB内存空间，大部分时候它都只在使用其中一两小部分的内存空间。我们将该4GB的内存空间分成好多个等大小的块（页），然后根据一个映射规则将当前有用到的块映射到物理内存中，这样4GB的物理内存就可以同时被接受多个程序享用。</p>
</li>
</ol>
<h2 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h2><ol>
<li><p>分页</p>
<p> 内存分段机制下的内存访问示意图如下：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img6.png" alt="img"></p>
<p> 我们在实模式下提供段基址，或者是在保护模式下提供的选择子加上另外提供的偏移量，在段部件的处理下形成了线性地址。在还没开启分页机制的情况下，这个线性地址就是真实的物理地址</p>
<p> 分页机制下的内存访问示意图如下：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img7.png" alt="img"></p>
<p> 如果打开了分页机制，线性地址还要经过页部件(负责检索页表的部件)的处理，然后才变成了真正的物理地址。我们把没经过页部件处理的线性地址叫做虚拟地址</p>
<p> 分页机制的作用在于：</p>
<ul>
<li><p>将线性地址转换成物理地址</p>
</li>
<li><p>用大小相等的页代替大小不相等的段</p>
</li>
</ul>
<p> 如下图所示：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img8.png" alt="img"></p>
<p> 在分段的基础上，将虚拟空间中的段划分为一块块大小相等的页然后映射到任意物理地址空间里</p>
</li>
<li><p>映射</p>
<p> 我们把存储映射关系的数据结构叫做页表（页表也是存储在内存中），页表中的每一项叫做页表项(记录着页对应的物理地址)，一个页表项需要4字节的大小来描述，页表与物理内存之间的关系如下图所示：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img9.png" alt="img"></p>
<p> 线性地址和物理地址之间的映射有多种可选择的方案</p>
<p> 比如最简单的是逐字节映射，虚拟空间中的每一个字节对应到物理空间地址上的每一个字节，那么4GB的虚拟空间对应的页表就得有4G个页表项，每个页表项需要4字节，则一共需要16GB空间大小的页表。为了扩展4GB的内存空间而使用了16GB内存空间这明显是不合适的，所以我们要找到一个合适的映射关系，使得分页机机制即能实现，也不会占用太大的额外内存空间。</p>
<p> 最终决定的合适的映射方案是：每4KB大小的空间作为一页。也就是说4GB的内存空间一共可以划分成4GB&#x2F;4KB&#x3D;1M个页，一张页表就得含有1M个页表项，总大小为4MB（就空间耗费而言可以接受）</p>
</li>
<li><p>从线性地址到物理地址</p>
<p> 现在我们如何从线性地址定位到物理地址呢？</p>
<ul>
<li><p>首先页表是存在内存中的，页表的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页表的位置了</p>
</li>
<li><p>然后我们要定位到具体的页表项，<code>取出线性地址的高20位作为索引*4（因为每个页表项占据4字节）+CR3中页表的起始物理地址=目标页表项的地址</code>。找到了页表项也就相当于找到了该页对应的物理地址</p>
</li>
<li><p>最后我们把<code>线性地址低12位作为偏移量+页物理地址=线性地址对应的真正物理地址</code></p>
</li>
</ul>
<p> 线性地址到物理地址转换的全过程如图所示：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img10.png" alt="img"></p>
</li>
</ol>
<h2 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h2><p>一级页表的大小有4MB，这个大小虽然可以接受但不够灵活，我们需要保证内存里有一整块连续的4MB空间。而且每一个进程对应一个页表，当电脑同时运行多个进程的同时页表就会占据很大的空间。我们希望能更节约空间，于是有了二级页表机制</p>
<p>二级页表将原本一共有1M个页表项的大页表分成1k个每个包含1K个页表项的小页表。小页表的空间是1K*4&#x3D;4K，刚好小页表的大小也是一个页。这样这些1K个小页表就可以灵活得分散到内存空间各个地方里了。但是为了找到这些小页表，我们需要一张页目录(页表的页表),页目录的每一项叫做页目录项（一个页目录项大小也是4字节，一共是1K项），每一项记录着对应小页表的物理地址。真巧！页目录的大小刚刚好也是1K*4&#x3D;4K(就是一个页的大小)。</p>
<p>二级页表内存分布如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img11.png" alt="img"></p>
<p>这样做有什么好处吗？我们发现二级页表并没有让真正的页表所占用空间变少（只是把它们拆散了），反而多出了一个4KB大小的页目录。但实际上，这样做以后，小页表不仅不需要连续的大空间，而且也可以像普通的页一样在使用频率少的情况下被从内存换到磁盘上，只在需要用的时候才取回来。用4KB空间换取的灵活能带来更多好处。</p>
<p>如何从线性地址定位到物理地址（二级页表）？</p>
<ul>
<li><p>同样也是放在内存中的页目录变成了起点，页目录的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页目录的位置了</p>
</li>
<li><p>我们先取线性地址的高10位*4（页目录项也是4字节）定位到页目录中相对应的页目录项，找到了页目录项就相当于找到了对应页表的物理地址</p>
</li>
<li><p>将线性地址的中间10位*4+对应页表的物理地址找到了页表项，找到了页表项就相当于找到了页的物理地址</p>
</li>
<li><p>将线性地址的最后12位+页的物理地址&#x3D;线性地址对应的真正物理地址</p>
</li>
</ul>
<p>线性地址到物理地址（二级页表）转换的全过程如图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img12.png" alt="img"></p>
<h2 id="页目录项、页表项以及CR0格式"><a href="#页目录项、页表项以及CR0格式" class="headerlink" title="页目录项、页表项以及CR0格式"></a>页目录项、页表项以及CR0格式</h2><p>页目录项和页表项的格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img13.png" alt="img"></p>
<p>页目录基址寄存器(CR3)格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img14.png" alt="img"></p>
<ol>
<li><p>为什么页目录项的页表物理地址只有20位而不是32位？因为内存是以4KB每页为单位划分的，因此只要20位地址就可以找到对应的页表了</p>
</li>
<li><p>为什么页表的物理页地址也只有20位？这20位足够索引到内存中的对应页了，剩下的12位是段内偏移量由线性地址的最后12位组成</p>
</li>
<li><p>AVL是Available位，表示可用，是给软件看的。操作系统可以不管该位</p>
</li>
<li><p>G，全局位。G&#x3D;1，则代表缓存在TLB（页表缓冲寄存器）中了，可以不用经过地址转换，直接通过TLB取值</p>
</li>
<li><p>PAT（Page Attribute Table）此位比较复杂，直接置0即可</p>
</li>
<li><p>D(Dirty)脏位，CPU对一个页进行写操作时，对应的页表项D位置1，表示该页已被修改过</p>
</li>
<li><p>A（Accessd）访问位，每当CPU访问过该页时，对应的A位置1。过一段时间后由操作系统同一置0，操作系统可以通过置0的频率来判断该页是否被经常使用</p>
</li>
<li><p>PCD(Page-level Cache Disable)页表高速缓冲禁止位，别管那么多，置0就行</p>
</li>
<li><p>PWT（Page-level Write-Through）页级通写位，别管那么多，置0就行</p>
</li>
<li><p>US（User&#x2F;Supervisor）普通用户&#x2F;超级用户位，为1表示User级，任意特权程序可访问。为0表示Supervisor级，特权级别3的程序不可访问</p>
</li>
<li><p>RW（Read&#x2F;Write）1表示可读可写，0表示可读不可写</p>
</li>
<li><p>P（Present） 存在位，P&#x3D;0表示该表不在物理内存中</p>
</li>
</ol>
<h2 id="启用分页机制-1"><a href="#启用分页机制-1" class="headerlink" title="启用分页机制"></a>启用分页机制</h2><p>启用分页机制要做三件事：</p>
<ol>
<li><p>准备好页目录以及页表</p>
</li>
<li><p>将页目录地址写入控制寄存器cr3</p>
</li>
<li><p>寄存器cr0的PG位置1</p>
</li>
</ol>
<h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><h3 id="明确分页模型："><a href="#明确分页模型：" class="headerlink" title="明确分页模型："></a>明确分页模型：</h3><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img15.png" alt="img"></p>
<p>我们只打算把物理内存的低端1MB空间拿来存放内核，而一张页表就可以表示4MB空间，也就是说，其实我们需要的只要<code>一张页表里的256个PTE</code>就够了。所以我们先暂时只申请1个页目录和255个页表(为什么少一个后面提到了)，用来存放内核。</p>
<p>页目录PD的三个重要映射：</p>
<ol>
<li><p>PD[0]指向 第0张页表：<br> 因为开启分页机制前我们正在用线性地址运行处于物理地址低端1MB的代码，而开启分页机制后，线性地址变成了会自动经过页部件转化的虚拟地址，要想保证处于物理地址低端1MB的代码继续正常运行，我们就必须让虚拟空间的低端1MB映射物理地址的低端1MB，<code>PD[0]指向第0张页表</code>这个操作保证了代码正常运行。</p>
</li>
<li><p>PD[1023]指向了页目录起始地址：<br> 这是为了实现能通过虚拟地址修改该页表和页目录的操作，后续会详细讲解，这边就当浪费一个PDE</p>
</li>
<li><p>PD[768]~PD[1022]指向了255个页表：<br> 这儿就是实现将虚拟空间高端1GB里的1MB内核地址映射到物理空间里低端1MB内核地址的关键</p>
</li>
</ol>
<h3 id="具体代码展示："><a href="#具体代码展示：" class="headerlink" title="具体代码展示："></a>具体代码展示：</h3><p>首先是修改boot.inc头文件，在里面添加页目录和页表相关宏：</p>
<pre><code>;--------------loader和kernel----------------

LOADER_BASE_ADDR equ 0x900
;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

LOADER_START_SECTOR equ 0x2
;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区

;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------
;为了方便我们将64位的gdt描述符分为高32位和低32位来定义，下面代码定义的都是低32位


;二进制数据中间的&#39;_&#39;符号没有任何意义，仅仅只是为了让程序员看得更清楚，编译器会自动忽略
;命名中的DESC是描述的意思
DESC_G_4K equ 1_00000000000000000000000b ;第23位G 表示4K或者1MB位 段界限的单位值 此时为1则为4k 
DESC_D_32 equ 1_0000000000000000000000b  ;第22位D/B位 表示地址值用32位EIP寄存器 操作数与指令码32位
DESC_L    equ 0_000000000000000000000b   ;第21位 设置成0表示32位代码段而非64位代码段
DESC_AVL  equ 0_00000000000000000000b    ;第20位 CPU不用此位设置为0


;LIMIT代表段界限，我们打算在GPT里加入三个段：代码段、数据段、显存段(就是将之前显存的位置单独划分一个成一个段)
;我们对4GB的内存空间采用平坦模式，也就是说基址=0，偏移量最大范围=4GB（除了显存段外，显存段任然放置在0xB8000~0xBFFFF）
;DESC_LIMIT_CODE2代表定义代码段的段界限(第二部分)
DESC_LIMIT_CODE2  equ  1111_0000000000000000b   ;平坦模型要满足最大段界限*粒度=4GB，换算可知段界限必须为0xFFFFF,也就是全为1
DESC_LIMIT_DATA2  equ  DESC_LIMIT_CODE2         ;相同的值  数据段与代码段段界限相同
DESC_LIMIT_VIDEO2 equ	0000_0000000000000000b	;第16-19位 显存段任然放置在0xB8000~0xBFFFF，段基址应该为0xbffff,
                                                ;段界限应该为(0xbffff-0xb8000)/4k=7(高4位为0)


DESC_P            equ 	1_000000000000000b	  
DESC_DPL_0        equ  00_0000000000000b         
DESC_DPL_1        equ  01_0000000000000b	  
DESC_DPL_2        equ  10_0000000000000b
DESC_DPL_3        equ  11_0000000000000b
DESC_S_sys        equ  0_000000000000b           
DESC_S_CODE       equ  1_000000000000b        
DESC_S_DATA       equ  DESC_S_CODE


;这边存在一个问题，根据书本上的Type格式图里从3~0位数据段的排序应该是xwea，而代码部分则按照xewa的顺序，需要进一步确认
DESC_TYPE_CODE    equ  1000_00000000b            ;第9-11位表示该段状态 1000 可执行 不允许可读 已访问位0
;x=1 e=0 w=0 a=0
DESC_TYPE_DATA    equ  0010_00000000b            ;第9-11位type段   0010  可写  
;x=0 e=0 w=1 a=0



;代码段描述符高位4字节初始化 (0x00共8位 &lt;&lt;24 共32位初始化0) 
;4KB为单位 Data段32位操作数 初始化的部分段界限 最高权限操作系统代码段 P存在表示 状态 
DESC_CODE_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \
DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00

;数据段描述符高位4字节初始化
DESC_DATA_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00

;显存段描述符高位4字节初始ua
DESC_VIDEO_HIGH4   equ (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B  ;书本上末尾是0，但显存段段基址应该为0xbffff，也就是说这边末尾应该是B 



;-------------------- 选择子属性 --------------------------------
RPL0    equ 00b
RPL1    equ 01b
RPL2    equ 10b
RPL3    equ 11b
TI_GDT  equ 000b
TI_LDT  equ 100b


;-----------------------页目录和页表属性---------------------------------------     
PAGE_DIR_TABLE_POS equ 0x100000

PG_P    equ 1b
PG_RW_R equ 00b
PG_RW_W equ 10b
PG_US_S equ 000b
PG_US_U equ 100b
</code></pre>
<p>loader.S完成构建页表、页目录、以及启动分页机制：</p>
<pre><code>;loader.S 负责完成构建页表、页目录、以及启动分页机制
%include &quot;boot.inc&quot;
SECTION loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
jmp loader_start                      		   ;跳跃到代码区


    ;构建gpt及其内部的描述符
    ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
    ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
    GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                dd 0x00000000 

    CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                dd DESC_CODE_HIGH4

    ;这边数据段和栈段共用一个段
    ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
    ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
    ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
    ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
    DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                        dd DESC_DATA_HIGH4

    VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                dd DESC_VIDEO_HIGH4     	  
                    
    GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
    GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

    times 60 dq 0                              ;预留60个 四字型 描述符
    
    ;gdt指针
    gdt_ptr         dw GDT_LIMIT
                    dd GDT_BASE  
    
    ;构造16位的段选择子
    SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
    SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
    SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0  
    
    
loader_start:   
    ; --------------------------------- 设置进入保护模式 -----------------------------
    ; 1 打开A20 gate 
    in al,0x92                
    or al,0000_0010b
    out 0x92,al

    ; 2 加载gdt
    lgdt [gdt_ptr] 

    ; 3 将cr0 的 pe位置1
    mov eax,cr0                
    or  eax,0x00000001              
    mov cr0,eax
    
    ;-------------------------------- 已经打开保护模式 ---------------------------------------
    jmp dword SELECTOR_CODE:p_mode_start                       
    ;前面是16位指令，后面是32位指令，CPU由于流水线技术无法直接处理混合在一起的二者，利用无转跳指令刷新一下流水线即可
    ;dword指定访问数据为32位，进入了保护模式后，操作数变为32位，这里声明选择子和偏移量都是32位操作数


[bits 32]
p_mode_start: 
    ;是初始化段选择子
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax
    
    ;测试显存段
    mov byte [gs:160],&#39;P&#39; 
    
    ;开始构建页表以及页目录
    call setup_page 
    
    ;如果我们开启了分页机制，所有线性地址都将变成虚拟地址，为了保证gdt能正常运作，我们需要在它的线性基址上+0xc0000000(也就是上升到3GB以上的1MB内核空间)
    ;3GB以上的1MB内核空间会映射回原来的低端1MB物理地址，保证代码正常运行
    ;sgdt将GDTR里面的内容取出到gdt_ptr
    sgdt [gdt_ptr]
    
    ;将显存段的位置移动到内核中
    mov ebx,[gdt_ptr+2]
    or dword [ebx+0x18+4],0xc0000000
    
    ;修改gdt_base的位置
    add dword [gdt_ptr+2],0xc0000000

    ;修改栈顶指针位置
    add esp,0xc0000000
    
    ;向cr3传入页目录地址
    mov eax,PAGE_DIR_TABLE_POS
    mov cr3,eax
    
    ;在cr0里开启分页
    mov eax,cr0
    or eax,0x80000000
    mov cr0,eax
    
    
    lgdt [gdt_ptr] 
    
    ;测试显存段能否正常工作，本质上是测试GDT能否正常工作
    mov eax,SELECTOR_VIDEO
    mov gs,eax
    mov byte [gs:160],&#39;V&#39;

    ;文件末尾，让它死循环
    jmp $  
    

setup_page:
;建立页表以及页目录   

    ;先把页目录清0
    mov esi,0
    mov ecx,4096
.clear_page_dir:   
    mov byte [PAGE_DIR_TABLE_POS+esi],0
    inc esi
    loop .clear_page_dir
                            
                            
    ;建立页目录，令页目录中的第0项和第768项指向第一个页表，令页目录中的第1023项指向自己   
    mov edx,PAGE_DIR_TABLE_POS
    or edx,PG_P|PG_RW_W|PG_US_U
    add edx,0x1000   
    
    mov [PAGE_DIR_TABLE_POS+0x00],edx
    mov [PAGE_DIR_TABLE_POS+768*4],edx
    
    sub edx,0x1000
    mov [PAGE_DIR_TABLE_POS+4092],edx  
    
    
    ;建立剩下的第769~1022一共254个页目录 
    mov edx,PG_P|PG_RW_W|PG_US_U 
    add edx,PAGE_DIR_TABLE_POS
    add edx,0x2000
    mov ecx,254    
    mov esi,769
.set_page_dir:       
    mov [PAGE_DIR_TABLE_POS+esi*4],edx
    inc esi      
    add edx,0x1000
    loop .set_page_dir 
    
    
    
    ;构建第一个页表
    mov ebx,PAGE_DIR_TABLE_POS
    add ebx,0x1000 
    xor edx,edx
    or edx,PG_P|PG_RW_W|PG_US_U   
    mov esi,0   
    mov ecx,256
.set_page_table:
    mov [ebx+esi*4],edx
    inc esi
    add edx,0x1000
    loop .set_page_table  

    ret
    
</code></pre>
<h3 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h3><ol>
<li><p>使用<code>xp &#39;内存地址&#39;</code>查看几个关键节点映射是否正确</p>
</li>
<li><p>使用<code>info gdt</code> 查看新的gdt有没有被正常装载</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img16.png" alt="img"></p>
</li>
<li><p>使用<code>info tab</code>查看映射关系</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img17.png" alt="img"></p>
<p> 我们可以从图中看出五条映射，第1条映射是 <code>虚拟空间低端1MB-&gt;PD[0]-&gt;第0张页表-&gt;物理空间低端1MB</code>，第2条映射是 <code>虚拟空间3GB之上的内核1MB-&gt;PD[768]-&gt;第0张页表-&gt;物理空间低端1MB</code>，前面这两条映射都比较好理解。第3条映射、第4条映射、第5条映射比较奇怪，如果虚地址高10位全为1，就会检索到PD[1023]。由于我们把PD[1023]指向页目录起始地址（但硬件不这么认为，硬件认为PD[1023]指向的一定是页表，硬件就把页目录当成了页表处理），就引发了这三条奇怪的映射，这三条映射也是我们通过虚拟地址访问并改变页目录页表的关键。</p>
<p> 第三条映射：虚地址高10位全为1、虚地址中10位全为0，就把PD[0]当成自己的页表项，最终指向物理页地址0x101000</p>
<p> 第五条映射：虚地址高10位全为1、虚地址中10位全为1，就把PD[1023]当成自己的页表项,最终指向物理页地址0x100000</p>
<p> 第四条映射：虚地址高10位全为1、虚地址中10位处于一定范围内，就把PD[768]~PD[1022]当成自己的页表项目，最终指向物理地址0x101000及以上空间</p>
<p> 总结出不变的规律：</p>
<ul>
<li>要获取页目录表物理地址：让虚位高20位地址全为1，低12位全为0，即0xfffff000。这就是页目录自身的起始物理地址</li>
<li>要访问页目录中的页目录项，即获取页表物理地址：使虚拟地址为0xfffffxxx,其中xxx是页目录项的索引*4</li>
<li>访问页表中的页表项:虚拟地址公式为 0x3ff&lt;&lt;22+中间10位&lt;&lt;12+低12位（中间10位是页表的索引，低12位为页表内的偏移地址）</li>
</ul>
</li>
</ol>
<h3 id="TLB更新方法"><a href="#TLB更新方法" class="headerlink" title="TLB更新方法"></a>TLB更新方法</h3><p>TLB(Translation Lookaside Buffer)用来缓冲页目录，CPU访问内存时先用虚拟地址检测TLB，如果命中则无需再去页目录查找，如果没命中则去页表查找并更新TLB，TLB结构如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img18.png" alt="img"></p>
<p>TLB对程序员不可见，但可用两种方法间接更新：</p>
<ol>
<li><p>重新加载CR3</p>
</li>
<li><p>使用指令invlpg,例如<code>invlpg [0x1234]</code>可以更新虚拟地址0x1234对应的条目</p>
</li>
</ol>
<h1 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h1><h2 id="加载内核的步骤"><a href="#加载内核的步骤" class="headerlink" title="加载内核的步骤"></a>加载内核的步骤</h2><p>我们将告别汇编，用C编写内核文件kernel.bin,用C编写将会和之前有以下区别：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img19.png" alt="img"></p>
<p>加载内核要做的事如下：</p>
<ol>
<li><p>用C编写并使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里</p>
</li>
<li><p>修改loader.S，负责把kernel.bin文件加载到合适的位置(执行完第三步kernel.bin就没用了)</p>
</li>
<li><p>修改loader.S，负责初始化内核，即通过elf头文件信息 将kernel.bin文件里的每个段分别放置在elf头文件指定位置(elf中包含头文件，我们总不能把头文件里的元信息也放置到CPU上执行，所以需要拆解)</p>
</li>
<li><p>跳转到kernel的程序入口地址，loader.S交出最后一棒接力棒</p>
</li>
</ol>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>我们要讲内核加载到内存的哪里？请看下图低端1MB内存布局里三个打勾的位置：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img33.png" alt="img"></p>
<p>三个打勾的位置将会是我们内核存放的地方（加载在0x7c00的MBR的工作已经做完了，可以被覆盖。加载在0x900的loader里面包含gdt设置，不能被覆盖），从上述加载内核的步骤看我们需要两个地方来存储内核。</p>
<p>第一个地方存储kernel.bin(对应第2步)</p>
<p>第二个地方存储被loader.S处理后的真正的内核映像文件(对应第三步)</p>
<p>kernel.bin应尽量位于高地址，给不断增长的kernel映像文件腾出空间。预计kernel.bin不会超过100kb，计划存储在0x70000（0x70000~0x9fbff有190KB）。</p>
<p>kernel被处理后的映像文件应该尽量放在低地址同时不能覆盖loader。预计loader大小不会超过2000字节,0x900+2000&#x3D;0x10d0,取一个整数为kernel的映像文件地址0x1500。</p>
<p>上述我们说的都是物理地址，由于我们开启了分页机制后，写代码时里要将物理地址转化为虚拟地址，相应的两个虚拟地址分别是0xc0070000和0xc0001500</p>
<p>在加载完内核后，我们还需要选择一个新的地方作为内核代码的栈顶，可用空间的顶部0x9fc00作为栈顶是最合适的。但是由于pcb（后面章节讲）要求4KB对齐，所以栈顶既要接近0x9fc00又要是4KB的整数倍,所以我们选择了0x9f000作为内核代码的栈顶，转化为虚拟地址即是0xc009f000</p>
<h2 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h2><h3 id="elf文件布局"><a href="#elf文件布局" class="headerlink" title="elf文件布局"></a>elf文件布局</h3><p>elf文件&#x3D;二进制可执行文件+头文件(存储元信息)</p>
<p>一个elf文件的逻辑布局如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img20.png" alt="img"></p>
<p>物理布局如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img21.png" alt="img"></p>
<p>关于这两图我们要讲几点：</p>
<ol>
<li><p>Section和Segment的区别：</p>
<p> Section是写代码时为了更清楚的逻辑划分，程序员将代码主动划分为一节一节。（汇编语言中的section、segment关键字本质上划分的都是节）</p>
<p> Segment是编译器将相同类型的Section集合在一起形成了段，如代码段、数据段。（经过编译器链接后，我们才称为段）</p>
</li>
<li><p>我们关注的重点：</p>
<p> 大部分的Section经过编译器链接后成为了Segment，我们关注的重点在Segment，我们所要做的就是根据elf头文件的指示，将每一个Segment放到它该去的地方</p>
</li>
</ol>
<h3 id="elf-header结构"><a href="#elf-header结构" class="headerlink" title="elf header结构"></a>elf header结构</h3><p>elf格式的数据类型（它们就和int、double一样，只关注字节大小就好了）</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img22.png" alt="img"></p>
<p>elf header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img23.png" alt="img"></p>
<p>elf header具体数据成员意义描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:e_phoff、e_phentisize、e_phnum）：</p>
<ol>
<li><p>e_ident</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img24.png" alt="img"></p>
</li>
<li><p>e_type</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img25.png" alt="img"></p>
</li>
<li><p>e_machine</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img26.png" alt="img"></p>
</li>
<li><p>others</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img27.png" alt="img"></p>
</li>
</ol>
<h3 id="program-table-header结构"><a href="#program-table-header结构" class="headerlink" title="program table header结构"></a>program table header结构</h3><p>program table header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img28.png" alt="img"></p>
<p>program table header的成员描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:p_offset、p_vaddr、p_mensz）：</p>
<ol>
<li><p>p_type<br> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img29.png" alt="img"></p>
</li>
<li><p>p_flags<br> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img30.png" alt="img"></p>
</li>
<li><p>others<br> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img31.png" alt="img"></p>
</li>
</ol>
<p>实例：请参照<code>操作系统真相象还原</code>P218-5.3.4；我们可以使用命令<code>readelf -e &#39;文件名&#39;</code>来查看一个elf文件的头的具体数据,也可以使用<code>hd &#39;文件名&#39;</code>来查看一个elf文件的十六进制形式</p>
<h2 id="代码实战-1"><a href="#代码实战-1" class="headerlink" title="代码实战"></a>代码实战</h2><ol>
<li><p>用C编写main.c文件，然后并使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里</p>
<ul>
<li><p>main.c：</p>
<p>  int main(void){<br>  while(1);<br>  return 0;<br>  }</p>
</li>
<li><p>使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里：</p>
<pre><code>  gcc -m32 -c -o kernel/main.o kernel/main.c
  ;注意要编译成32位文件才能兼容
  ld -m elf_i386 kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin 
  # ld是链接程序，-Ttext指定起始的虚拟地址,为什么是0xc0001500后面详细说明，-e是指定程序入口地址(main符号代表main函数的起始地址)
  dd if=/home/sparkle2/codeset/kernel/kernel.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=200 seek=9 conv=notrunc
  # 内核程序预计不会超过100KB，于是一次性给它分配200个扇区的磁盘空间。存入磁盘号为9号，和loader程序之间腾出一些间隔
  # 现在磁盘hd60M.img的分布如下：0号扇区留给MBR  2~5号扇区位置留给loader 9~208号扇区位置留给kernel
</code></pre>
</li>
</ul>
</li>
<li><p>boot.inc添加加载内核相关宏</p>
<pre><code> ;--------------loader----------------

 LOADER_BASE_ADDR equ 0x900
 ;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
 ;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
 ;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

 LOADER_START_SECTOR equ 0x2
 ;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
 ;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区   

 ;--------------loader----------------



 ;--------------kernel----------------

 KERNEL_BIN_BASE_ADDR equ 0x70000 
 ;kernel.bin应尽量位于可用空间的高地址，给不断增长的kernel映像文件腾出空间。预计kernel.bin不会超过100kb，计划存储在0x70000

 KERNEL_BIN_START_SECTOR equ 0x9  
 PT_NULL equ 0 

 KERNEL_ENTER_ADDR equ 0xc0001500

 ;--------------kernel----------------




 ;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------
 ;为了方便我们将64位的gdt描述符分为高32位和低32位来定义，下面代码定义的都是低32位


 ;二进制数据中间的&#39;_&#39;符号没有任何意义，仅仅只是为了让程序员看得更清楚，编译器会自动忽略
 ;命名中的DESC是描述的意思
 DESC_G_4K equ 1_00000000000000000000000b ;第23位G 表示4K或者1MB位 段界限的单位值 此时为1则为4k 
 DESC_D_32 equ 1_0000000000000000000000b  ;第22位D/B位 表示地址值用32位EIP寄存器 操作数与指令码32位
 DESC_L    equ 0_000000000000000000000b   ;第21位 设置成0表示32位代码段而非64位代码段
 DESC_AVL  equ 0_00000000000000000000b    ;第20位 CPU不用此位设置为0


 ;LIMIT代表段界限，我们打算在GPT里加入三个段：代码段、数据段、显存段(就是将之前显存的位置单独划分一个成一个段)
 ;我们对4GB的内存空间采用平坦模式，也就是说基址=0，偏移量最大范围=4GB（除了显存段外，显存段任然放置在0xB8000~0xBFFFF）
 ;DESC_LIMIT_CODE2代表定义代码段的段界限(第二部分)
 DESC_LIMIT_CODE2  equ  1111_0000000000000000b   ;平坦模型要满足最大段界限*粒度=4GB，换算可知段界限必须为0xFFFFF,也就是全为1
 DESC_LIMIT_DATA2  equ  DESC_LIMIT_CODE2         ;相同的值  数据段与代码段段界限相同
 DESC_LIMIT_VIDEO2 equ	0000_0000000000000000b	;第16-19位 显存段任然放置在0xB8000~0xBFFFF，段基址应该为0xbffff,
                                                 ;段界限应该为(0xbffff-0xb8000)/4k=7(高4位为0)


 DESC_P            equ 	1_000000000000000b	  
 DESC_DPL_0        equ  00_0000000000000b         
 DESC_DPL_1        equ  01_0000000000000b	  
 DESC_DPL_2        equ  10_0000000000000b
 DESC_DPL_3        equ  11_0000000000000b
 DESC_S_sys        equ  0_000000000000b           
 DESC_S_CODE       equ  1_000000000000b        
 DESC_S_DATA       equ  DESC_S_CODE


 ;这边存在一个问题，根据书本上的Type格式图里从3~0位数据段的排序应该是xwea，而代码部分则按照xewa的顺序，需要进一步确认
 DESC_TYPE_CODE    equ  1000_00000000b            ;第9-11位表示该段状态 1000 可执行 不允许可读 已访问位0
 ;x=1 e=0 w=0 a=0
 DESC_TYPE_DATA    equ  0010_00000000b            ;第9-11位type段   0010  可写  
 ;x=0 e=0 w=1 a=0



 ;代码段描述符高位4字节初始化 (0x00共8位 &lt;&lt;24 共32位初始化0) 
 ;4KB为单位 Data段32位操作数 初始化的部分段界限 最高权限操作系统代码段 P存在表示 状态 
 DESC_CODE_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
 DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \
 DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00

 ;数据段描述符高位4字节初始化
 DESC_DATA_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
 DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \
 DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00

 ;显存段描述符高位4字节初始ua
 DESC_VIDEO_HIGH4   equ (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
 DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \
 DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B  ;书本上末尾是0，但显存段段基址应该为0xbffff，也就是说这边末尾应该是B 

 ;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------







 ;-------------------- 选择GDTR子属性 --------------------------------
 RPL0    equ 00b
 RPL1    equ 01b
 RPL2    equ 10b
 RPL3    equ 11b
 TI_GDT  equ 000b
 TI_LDT  equ 100b

 ;-------------------- 选择GDTR子属性 --------------------------------

     
     
     
 ;-----------------------页目录和页表属性---------------------------------------     
 PAGE_DIR_TABLE_POS equ 0x100000

 PG_P    equ 1b
 PG_RW_R equ 00b
 PG_RW_W equ 10b
 PG_US_S equ 000b
 PG_US_U equ 100b     

 ;-----------------------页目录和页表属性---------------------------------------
</code></pre>
</li>
<li><p>loader.S添加加载内核部分代码</p>
<pre><code> ;loader.S 负责完成构建页表、页目录、以及启动分页机制
 %include &quot;boot.inc&quot;
 SECTION loader vstart=LOADER_BASE_ADDR
 LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
 jmp loader_start                      		   ;跳跃到代码区


     ;构建gpt及其内部的描述符
     ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
     ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
     GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                 dd 0x00000000 

     CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                 dd DESC_CODE_HIGH4

     ;这边数据段和栈段共用一个段
     ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
     ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
     ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
     ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
     DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                         dd DESC_DATA_HIGH4

     VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                 dd DESC_VIDEO_HIGH4     	  
                     
     GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
     GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

     times 60 dq 0                              ;预留60个 四字型 描述符
     
     ;gdt指针
     gdt_ptr         dw GDT_LIMIT
                     dd GDT_BASE  
     
     ;构造16位的段选择子
     SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
     SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
     SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0  
     
     
 loader_start:   
 ; --------------------------------- 设置进入保护模式 -------------------------------------
     ; 1 打开A20 gate 
     in al,0x92                
     or al,0000_0010b
     out 0x92,al

     ; 2 加载gdt
     lgdt [gdt_ptr] 

     ; 3 将cr0 的 pe位置1
     mov eax,cr0                
     or  eax,0x00000001              
     mov cr0,eax
     
 ;-------------------------------- 设置进入保护模式 ---------------------------------------
     jmp dword SELECTOR_CODE:p_mode_start                       
     ;前面是16位指令，后面是32位指令，CPU由于流水线技术无法直接处理混合在一起的二者，利用无转跳指令刷新一下流水线即可
     ;dword指定访问数据为32位，进入了保护模式后，操作数变为32位，这里声明选择子和偏移量都是32位操作数


 [bits 32]
 p_mode_start: 
     ;初始化段选择子
     mov ax,SELECTOR_DATA
     mov ds,ax
     mov es,ax
     mov ss,ax
     mov esp,LOADER_STACK_TOP
     mov ax,SELECTOR_VIDEO
     mov gs,ax
     
     ;测试显存段
     mov byte [gs:0],&#39;P&#39; 
     
     ;开始构建页表以及页目录
     call setup_page    
     
     ;在保护模式打开前加载kernel到内存合适位置
     call kernel_load

 ; --------------------------------- 重新装载gdt并开启分页机制 -------------------------------------

     ;如果我们开启了分页机制，所有线性地址都将变成虚拟地址，为了保证gdt能正常运作，我们需要在它的线性基址上+0xc0000000(也就是上升到3GB以上的1MB内核空间)
     ;3GB以上的1MB内核空间会映射回原来的低端1MB物理地址，保证代码正常运行
     ;sgdt将GDTR里面的内容取出到gdt_ptr
     sgdt [gdt_ptr]
     
     ;将显存段的位置移动到内核中
     mov ebx,[gdt_ptr+2]
     or dword [ebx+0x18+4],0xc0000000
     
     ;修改gdt_base的位置
     add dword [gdt_ptr+2],0xc0000000

     ;修改栈顶指针位置
     add esp,0xc0000000
     
     ;向cr3传入页目录地址
     mov eax,PAGE_DIR_TABLE_POS
     mov cr3,eax
     
     ;在cr0里开启分页
     mov eax,cr0
     or eax,0x80000000
     mov cr0,eax
     
     
     lgdt [gdt_ptr] 
     
     ;测试显存段能否正常工作，本质上是测试GDT能否正常工作
     mov eax,SELECTOR_VIDEO
     mov gs,eax
     mov byte [gs:160],&#39;V&#39;   

 ; --------------------------------- 重新装载gdt并开启分页机制 ------------------------------------- 

         
         
 
 ;------------------------------ 刷新流水线并，进入内核-----------------------------------    
     jmp SELECTOR_CODE:enter_kernel
 enter_kernel:
     call kernel_init					          
     mov  esp,0xc009f000          
     ;可用空间的顶部0x9fc00作为栈顶是最合适的。
     ;但是由于pcb（后面章节讲）要求4KB对齐，所以栈顶既要接近0x9fc00又要是4KB的整数倍,
     ;所以我们选择了0x9f000作为内核代码的栈顶
     ;转化为虚拟地址即是0xc009f000
     jmp  KERNEL_ENTER_ADDR  ;跳转到程序入口地址，将接力棒交给kernel

 ;------------------------------ 刷新流水线并，进入内核-----------------------------------   


 


 ; ---------------------------------加载kernel.bin到合适位置 ------------------------------------- 
 kernel_load:
     mov eax, KERNEL_BIN_START_SECTOR
     mov ebx, KERNEL_BIN_BASE_ADDR
     
     mov cx,200
     call rd_disk_m_32 
     ret 
 ; ---------------------------------加载kernel.bin到合适位置 ------------------------------------- 

         
         
         
         
         
 ; ---------------------------------实现kernel的初始化 ------------------------------------- 
 kernel_init:
     xor eax,eax
     xor ebx,ebx     ;记录program header table地址
     xor ecx,ecx     ;记录program header table中他program header的数量
     xor edx,edx     ;记录program header尺寸，即e_phentsize
     
     mov dx,[KERNEL_BIN_BASE_ADDR+42]    ;kernel.bin偏移文件42字节处是e_phentsize
     mov ebx,[KERNEL_BIN_BASE_ADDR+28]   ;kernel.bin偏移文件28字节处是e_phoff
     add ebx,KERNEL_BIN_BASE_ADDR        
     mov cx,[KERNEL_BIN_BASE_ADDR+44]    ;kernel.bin偏移文件44字节处是e_phnum  
     
 .each_segment:       
     cmp byte [ebx+0],PT_NULL            ;[ebx+0]指向program_header的p_type
     je .PTNULL 
     
     ;为函数mem_cpy压入参数
     push dword [ebx+16]                 ;[ebx+16]指向program_header的p_filesz
     mov eax,[ebx+4]                     ;[ebx+4]指向program_header的p_offset
     add eax,KERNEL_BIN_BASE_ADDR
     push eax
     push dword [ebx+8]                  ;[ebx+8]指向program_header的p_vaddr
     
     call mem_cpy
     add esp,12                          ;清理栈中的三个参数
     

     
 .PTNULL:
     add ebx,edx
     loop .each_segment 
             
     ret
 ; ---------------------------------实现kernel的初始化 -------------------------------------   



 ; ---------------------------------mem_cpy(dst,src,size) 逐字节拷贝函数 -------------------------------------  
 mem_cpy:
     cld     ;设置movsb增长方向
     push ebp
     mov ebp,esp
     push ecx
     
     mov edi,[ebp+8]    ;dst
     mov esi,[ebp+12]   ;src
     mov ecx,[ebp+16]   ;size
     
     rep movsb          ;逐字节拷贝 
     
     pop ecx
     pop ebp
     ret

 ; ---------------------------------mem_cpy(dst,src,size) 逐字节拷贝函数 ------------------------------------- 
             
     
             
             
             
 ;------------------------ rd_disk_m_32------------------------------- ----------------------

 rd_disk_m_32: 
 ;调用rd_disk_m_32时利用32位寄存器传入参数
 ;eax记录LBA28
 ;ebx记录目标地址
 ;cx记录要移动的扇区数   
 ;实现从磁盘LBA28地址eax处赋值cx磁盘数据到ebx目标地址处

     mov esi,eax                 ;ax会在后续in/out指令被使用，所以备份参数
     mov di,cx                   ;di会在后续循环中被用到，所以备份参数


     ;第一步：先选择通道，往该通道的sector cout寄存器写入待操作的扇区数
     mov ax,di
     mov dx,0x1f2
     out dx,al

     mov eax,esi                  ;复原eax


     ;第二步往通道上的三个LBA写入扇区地址LBA28的低24位
     mov dx,0x1f3
     out dx,al

     mov cl,8
     shr eax,cl       
     mov dx,0x1f4     
     out dx,al

     shr eax,cl
     mov dx,0x1f5
     out dx,al

     
     ;第三步 往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式
     shr eax,cl
     and al,0x0f
     or al,0xe0
     mov dx,0x1f6
     out dx,al


     ;第四步往该通道的command寄存器写入命令（一旦写入立即执行）
     mov dx,0x1f7
     mov al,0x20
     out dx,al


     ;第五步读取status寄存器，判断硬盘工作是否完成(这边采用查询传输的方式)
 .not_ready:
     nop            ;增加循环查询的延迟
     in al,dx
     and al,0x88
     cmp al,0x08
     jnz .not_ready


     ;最后一步将硬盘数据读出
     mov ax,di
     mov dx,256
     mul dx
     mov cx,ax
     ;一个扇区512字节，要读取di个扇区，每次读取2字节(16位的data寄存器),一共要循环读取di*512/2次

     mov dx,0x1f0
 .go_on_read:
     in ax,dx
     mov [ebx],ax
     add ebx,2
     loop .go_on_read

     ;函数loader_ready_proc结束返回
     ret
         
 ;------------------------ rd_disk_m_32---------------------------------------------------

 


 ; ---------------------------------创建页目录和页表-函数 -------------------------------------
 setup_page:
 ;建立页表以及页目录   

     ;先把页目录清0
     mov esi,0
     mov ecx,4096
 .clear_page_dir:   
     mov byte [PAGE_DIR_TABLE_POS+esi],0
     inc esi
     loop .clear_page_dir
                             
                             
     ;建立页目录，令页目录中的第0项和第768项指向第一个页表，令页目录中的第1023项指向自己   
     mov edx,PAGE_DIR_TABLE_POS
     or edx,PG_P|PG_RW_W|PG_US_U
     add edx,0x1000   
     
     mov [PAGE_DIR_TABLE_POS+0x00],edx
     mov [PAGE_DIR_TABLE_POS+768*4],edx
     
     sub edx,0x1000
     mov [PAGE_DIR_TABLE_POS+4092],edx  
     
     
     ;建立剩下的第769~1022一共254个页目录 
     mov edx,PG_P|PG_RW_W|PG_US_U 
     add edx,PAGE_DIR_TABLE_POS
     add edx,0x2000
     mov ecx,254    
     mov esi,769
 .set_page_dir:       
     mov [PAGE_DIR_TABLE_POS+esi*4],edx
     inc esi      
     add edx,0x1000
     loop .set_page_dir 
     
     
     
     ;构建第一个页表
     mov ebx,PAGE_DIR_TABLE_POS
     add ebx,0x1000 
     xor edx,edx
     or edx,PG_P|PG_RW_W|PG_US_U   
     mov esi,0   
     mov ecx,256
 .set_page_table:
     mov [ebx+esi*4],edx
     inc esi
     add edx,0x1000
     loop .set_page_table  

     ret
 ;---------------------------------创建页目录和页表-函数 -------------------------------------
</code></pre>
</li>
</ol>
<h1 id="特权级：DPL、CPL、RPL"><a href="#特权级：DPL、CPL、RPL" class="headerlink" title="特权级：DPL、CPL、RPL"></a>特权级：DPL、CPL、RPL</h1><p>RPL是选择子上的特权级，DPL是段描述符上的特权级，CPL表示当前访问者(CPU)的特权级</p>
<p>特权世界有几条基本法则:</p>
<ol>
<li><p>CPL恒等于CS.RPL（代码段选择子上的RPL）</p>
</li>
<li><p>唯一一种特权级会从高到低的方式:从中断中返回</p>
</li>
<li><p>CPU从当前代码段跳转到目标代码段时:new_CPL&#x3D;目标代码段的DPL(一致性代码段除外)</p>
</li>
<li><p>特权级的检测只在你打算访问某个地方时检测一次</p>
</li>
</ol>
<h2 id="没有RPL的世界"><a href="#没有RPL的世界" class="headerlink" title="没有RPL的世界"></a>没有RPL的世界</h2><p>为了理解这三者，我们要做的第一件事就是忽视RPL(除了CS.RPL,它是特别的，我们以后就叫它CPL了)，脑子里只剩下CPL和DPL</p>
<p>CPL表示当前访问者(CPU)的特权级，DPL表示被访问段(代码段&#x2F;数据段&#x2F;栈段)的特权级，二者之间有如下关系：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img35.png" alt="img"></p>
<p><strong>PS：为什么一致性代码段要求CPL&gt;&#x3D;DPL，假想一下，如果你权力比我还大你干嘛还来求我办事？所以一致性代码段限制了只有权力小的人才可以来求权力大的人办事</strong></p>
<p>从图中可以看出特权世界的基本运行规则，我们发现农民的局限性太大了，哪怕有哪个地主愿意帮农民办事也得继续用农民的身份（这样他就同样无法行使地主特权）</p>
<h2 id="没有RPL世界，但是有了调用门"><a href="#没有RPL世界，但是有了调用门" class="headerlink" title="没有RPL世界，但是有了调用门"></a>没有RPL世界，但是有了调用门</h2><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img36.png" alt="img"></p>
<p>可以看出，调用门真正提供了一个渠道允许农民行地主之事(虽然不是所有农民都行)</p>
<p>例子：假设当前特权级是3，也就是说CPL&#x3D;3。当前代码(CPU&#x2F;访问者)想要访问内存里的一个目标段，目标段的DPL&#x3D;0。很明显CPL&gt;DPL,当前代码没有这个权力。它只能<code>call 调用门选择子</code>。我们跟着调用们选择子找到了调用门描述符（DPL&#x3D;3），也找到了被调用代码的描述符（DPL&#x3D;0）。首先进行一次特权级检测：调用门描述符（DPL&#x3D;3）&gt;&#x3D;CPL&gt;&#x3D;被调用代码的描述符（DPL&#x3D;0），允许使用该调用门。于是从当前代码段转跳到被调用代码段（new_CPL&#x3D;被调用代码段.DPL），同样被传到被调用代码段的还有之前代码段压入栈的参数，被调用代码段因为有着CPL&#x3D;0的特权级所以可以拿着参数做任意事情了。一切结束后会引发中断返回，CPL重新&#x3D;3</p>
<h2 id="调用门引发的危险"><a href="#调用门引发的危险" class="headerlink" title="调用门引发的危险"></a>调用门引发的危险</h2><p>假设当前代码段(CPL&#x3D;3)想要读取一个目标段(DPL&#x3D;0)的内容到自己的缓冲区(DPL&#x3D;3)。有一个当前代码段可以使用调用门，该调用门可以传入一个表示缓冲区地址的参数(用压栈方式)，如果成功调用了调用门，被调用的代码段(CPL&#x3D;0)就会把目标段(DPL&#x3D;0)的内容放入到参数指示的缓冲区(DPL&#x3D;3)。</p>
<p>上述的一切看上去都很和谐，就下图左边的情况：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img37.png" alt="img"></p>
<p>但如果当前代码段不怀好意，它故意把缓冲区指针指向了操作系统内核段(DPL&#x3D;0)，就会发生上图右边的情况。被调用代码凭着CPL&#x3D;0任意修改DPL&#x3D;0的操作系统内核段，导致操作系统内核段被破坏。问题的关键出在：DPL&#x3D;0的段无条件信任所有CPL&#x3D;0的代码，CPL&#x3D;0的代码当然不会主动去伤害DPL&#x3D;0的段，但没想到过CPL&#x3D;0的代码会没脑子的帮CPL&#x3D;3的代码做事。</p>
<p>因此，DPL&#x3D;0的段说我们不能在无条件的信任你了，我们必须增加一个条件来判断你是不是在帮别人做事，这个条件就是RPL</p>
<h2 id="RPL解决调用门危机"><a href="#RPL解决调用门危机" class="headerlink" title="RPL解决调用门危机"></a>RPL解决调用门危机</h2><p>先来看看引入了RPL后特权世界的基本规则变成什么样了：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img38.png" alt="img"></p>
<p>仔细分辨，你会发现未曾使用调用门的情况下，因为OS会进行赋值操作使RPL&#x3D;CPL，所以不论对谁都没有影响，和没有RPL世界的运行规律是一样的。</p>
<p>当有了RPL运行规律就不一样了,请看一下例子：</p>
<p>假设当前代码段(CPL&#x3D;3)想要读取一个目标段(DPL&#x3D;0)的内容到自己的缓冲区(DPL&#x3D;3)。有一个当前代码段可以使用调用门，该调用门可以传入一个表示缓冲区地址的参数(用压栈方式)，如果成功调用了调用门，被调用的代码段(CPL&#x3D;0)就会把目标段(DPL&#x3D;0)的内容放入到参数指示的缓冲区(DPL&#x3D;3)。</p>
<p>当前代码段使用<code>call 调用门选择子</code>时，OS会为其构造一个调用门选择子（RPL&#x3D;CPL&#x3D;3）。然后触发特权检测,<code>调用门描述符（DPL=3）&gt;=CPL=RPL&gt;=被调用代码的描述符（DPL=0）</code>运行该代码段使用调用门。在使用调用门前当前代码段需要压入一个指向缓冲区的参数，此时OS会为该参数构造一个指向缓冲区的选择子(RPL&#x3D;CPL&#x3D;3)。进入被调用代码段(new_CPL&#x3D;被调用代码的描述符的DPL&#x3D;0)，拿到参数后开始访问参数指向的地址（使用该参数的选择子）。这时又触发特权检测，如果缓冲区DPL&#x3D;3(也就是正常情况下，程序安分守己)，MAX(CPL,RPL)&#x3D;3&lt;&#x3D;DPL，代码正常运行。如果缓冲区的DPL&#x3D;0(也就是程序不安好心),MAX(CPL,RPL)&#x3D;3&gt;DPL,代码停止。</p>
<p>RPL完美解决了上述的调用门危机，现在的特权世界是这么一种情况：地主可以自由控制地主&#x2F;农民的地盘，农民只能自由控制农民的地盘，地主可以用地主的资源来帮农民打造(或毁坏)农民的地盘，决不允许地主帮农民打造(或毁坏)地主的地盘</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>画了一张图代表从第一章到第五章我们做的事，如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img34.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/11/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（四）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-11 15:46:38" itemprop="dateCreated datePublished" datetime="2023-11-11T15:46:38+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-14 20:28:13" itemprop="dateModified" datetime="2023-11-14T20:28:13+08:00">2023-11-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这一章我们学习如何从实模式到保护模式，并编写加载器loader的代码，让他实现将系统从实模式切换到保护模式</p>
<h1 id="保护模式概述"><a href="#保护模式概述" class="headerlink" title="保护模式概述"></a>保护模式概述</h1><p>保护模式和实模式一样都是指工作状态、工作环境、工作命令等一整个方面的内容。</p>
<p>一开始是没有实模式、保护模式的概念的。16位CPU时代工作配置都是现有的实模式，但是当时并没有16位实模式的概念。直到人们觉得这种工作方式不安全，在32位CPU时代里推出了新的工作方式。由于32位CPU一定要可以兼容16位CPU的程序，所以为了区分新旧工作模式，引入了实模式（重点是真实的物理地址）、保护模式（重点突出保护）两个概念。</p>
<p>也就是说现代计算机是可以兼容实模式和保护模式，当然绝大多数时候都是使用保护模式</p>
<h2 id="为什么要有保护模式-实模式的缺点"><a href="#为什么要有保护模式-实模式的缺点" class="headerlink" title="为什么要有保护模式(实模式的缺点)"></a>为什么要有保护模式(实模式的缺点)</h2><ol>
<li><p>实模式下用户程序和操作系统同一等级，而且逻辑地址就是物理地址，用户程序可以随意修改段基址访问所有内存，不安全</p>
</li>
<li><p>实模式16位寄存器决定访问超过64KB的内存区域要切换段基址、麻烦</p>
</li>
<li><p>一次只能运行一个程序，无法充分利用计算机资源</p>
</li>
<li><p>只有20条地址线，最大可用内存的寻址范围只有1MB，不够用</p>
</li>
</ol>
<h2 id="保护模式的特点"><a href="#保护模式的特点" class="headerlink" title="保护模式的特点"></a>保护模式的特点</h2><ol>
<li><p>应用程序只能访问虚拟地址，虚拟地址由处理器和操作系统协作转换后才显示真正的物理地址</p>
</li>
<li><p>保护模式的运行环境是32位，寄存器、数据线、地址线也相应都被扩展到32位，指令格式也有了相应的扩展（允许32位源操作数）</p>
</li>
<li><p>保护模式不再使用中断向量表、段基址寄存器这些概念。取而代之的是段选择子寄存器、全局描述符、中断描述符表、各种门结构</p>
</li>
<li><p>保护模式引入了特权级的概念，应用程序不再和操作系统拥有同一特权级</p>
</li>
</ol>
<h2 id="保护模式的扩展"><a href="#保护模式的扩展" class="headerlink" title="保护模式的扩展"></a>保护模式的扩展</h2><ol>
<li><p>寄存器扩展：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img1.png" alt="img"></p>
<p> 保护模式下寄存器、地址线和数据总线都扩展到32位，内存寻址空间可达4GB，段内寻址空间也可达4GB。也就是说对内存的访问甚至可以让段基址&#x3D;0，只由一个记录偏移量的寄存器来访问内存，这也就是所谓的平坦模型</p>
<p> 另外一提：保护模式抛弃基址这个概念，而是在内存里放入一个全局描述符表，每一个表项都是一个段描述符，用来描述各个内存段的起始地址、大小、权限等信息。段寄存器保护的也不再是段基址了，而是“选择子”，选择子本质上就是全局描述符表中的索引，就像是数组下标一样的东西。</p>
</li>
<li><p>寻址扩展：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img2.png" alt="img"></p>
<p> 如图所示保护模式的寻址方式更加灵活多变，不仅在基址寄存器(所有通用寄存器都可)和变址寄存器(处理esp外的所有通用寄存器都可)有了更多选择外，还引入了比例因子</p>
</li>
<li><p>运行模式反转：</p>
<p> 由于32位CPU兼容保护模式和实模式，所以如果你在保护模式下使用实模式的命令，或者在实模式下使用保护模式的命令，都会触发运行模式反转，将会在二进制机器码前加上相应的反转前缀。</p>
<p> 注意：模式反转前缀只对单条指令有效，效果并非是全局的</p>
<pre><code> [bit 16] ;告诉编译器接下来的代码是实模式
 [bit 32] ;告诉编译器接下来的代码是保护模式
</code></pre>
<ul>
<li><p>操作数反转前缀 0x66</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img3.png" alt="img"></p>
<p>  如图上半部分是代码，下半部分是编译后的机器指令</p>
<p>  第三行在[bit 16]实模式下使用了eax，触发了保护模式转换，因此机器码前加了前缀0x66</p>
<p>  第五行在[bit 32]保护模式下使用了ax，触发了实模式转换，因此机器码前加了前缀0x66</p>
</li>
<li><p>寻址方式反转前缀 0x67</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img4.png" alt="img"></p>
<p>  第四行在[bit 16]实模式下同时使用了保护模式的32位源操作数和更加灵活的寻址方式，触发模式转换，机器码添加了前缀0x66、0x67</p>
</li>
</ul>
</li>
<li><p>指令扩展</p>
<p> 指令扩展后允许32位寄存器和32位源操作数</p>
</li>
</ol>
<h1 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h1><p>从实模式到保护模式我们要执行三个步骤：</p>
<ol>
<li>打开A20地址线</li>
<li>加载GDT</li>
<li>将CR0的PE位置1</li>
</ol>
<p>对于这三个步骤的讲解请看下文</p>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>到了保护模式下，内存段不再是简单用寄存器加载即可用，而是需要提前把段定义好才可使用。全局描述符就是用来存储对每个段描述的表，全局描述符中的每一个表项包含段描述符，段描述符就是对一个段的描述，64位段描述符格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img5.png" alt="img"></p>
<ol>
<li><p>段基址：</p>
<p> 每个段都有32位的段基址，在段描述符中被拆分成三块存储。</p>
<p> 为什么被拆分成三块？为的是兼容，实模式下段基址是16位，80286有关短暂的24位段基址，而现在则是32位段基址，为了兼容原本应该连续存放的段基址被拆分为16-8-8的形式。</p>
<p> 当需要查看段基址时，硬件会把三个分散的段基址取出来并拼接在一起得到一个完整的32位段基址。</p>
<p> <strong>PS：现在知道为什么有那么多屎山代码了，为了兼容旧时代的程序，屎山代码将成为每一个持续发展产品的最终归宿！</strong></p>
</li>
<li><p>段界限：</p>
<p> 段界限表示段边界的扩展最值，20位段界限被拆分为两部分(当然又是为了兼容)。</p>
<p> 段界限是一个单位量，单位要么是1字节，要么是4KB(单位由G段决定)。也就是说段的最大寻址范围要么是1*2^20&#x3D;1MB；要么是2*12*2^20&#x3D;4GB。(注意寻址范围!&#x3D;空间)</p>
<p> 实际的段界限边界值&#x3D;(描述符中段界限+1)*(段界限的粒度大小：4KB&#x2F;1Byte)-1</p>
</li>
<li><p>S字段和type字段：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img6.png" alt="img">    </p>
<p> S字段只有1位：S&#x3D;0 则说明是系统段(凡是硬件允许需要用到的东西，程序入口、调用门之类);S&#x3D;1 则说明是非系统段(凡是软件运行需要的东西，数据、代码、栈都是数据段)</p>
<p> type字段有4位：type字段只有在S确认后才有意义，X区分代码段和数据段，R代表是否可读，W代表是否可写，C代表是否一致，E代表向上扩展(E&#x3D;0,低地址到高地址)或向下扩展(E&#x3D;1，高地址到低地址)，A代表是否被CPU读过（CPU访问过则置1）</p>
</li>
<li><p>DPL（Descriptor Privilege Level）</p>
<p> 2位的DPL字段表示特权级，特权级从0~3,数字越低特权级越高，操作系统是0级，一般应用程序是3级</p>
</li>
<li><p>P字段（Present）：</p>
<p> 1位P表示段是否存在，有时候内存不够时，保护模式下CPU可能会按页(4KB)的单位将内存换到磁盘里，此时相当于该段不存在，即P&#x3D;0;</p>
</li>
<li><p>AVL字段（Avaliable）:</p>
<p> 1位AVL字段代表该段是否可用，是否可用是对用户来说，对操作系统来说可随意访问此位</p>
</li>
<li><p>L字段：</p>
<p> 1位L字段，L&#x3D;1表示代码段是64位，L&#x3D;0表示代码段是32位，我们在32位地址下编程将其设置为0即可</p>
</li>
<li><p>D&#x2F;B字段：</p>
<p> 1位D&#x2F;B字段指定有效地址及操作数大小，对不同段的意义不同</p>
<ul>
<li><p>如果争对代码段，D&#x3D;0时指令中有效地址和操作数是16位，指令有效地址用IP寄存器；D&#x3D;1时指令中有效地址和操作数是32位，指令有效地址用EIP寄存器</p>
</li>
<li><p>如果争对栈段，B&#x3D;0时栈使用SP寄存器，栈最大寻址范围为2^16；B&#x3D;1时栈使用ESP寄存器，栈最大寻址范围为2^32</p>
</li>
</ul>
</li>
<li><p>G段：</p>
<p> 1位G段用来指定段界限的单位大小，G&#x3D;0时，段界限的单位时1字节；G&#x3D;1时，段界限的单位是4KB</p>
</li>
</ol>
<h2 id="全局描述符号GDT、选择子以及GDTR寄存器"><a href="#全局描述符号GDT、选择子以及GDTR寄存器" class="headerlink" title="全局描述符号GDT、选择子以及GDTR寄存器"></a>全局描述符号GDT、选择子以及GDTR寄存器</h2><ol>
<li><p>GDT(Global Descriptor Table)相当于是段描述符的数组，每一表项都是一个段描述符</p>
</li>
<li><p>选择子是什么？选择子由三部分组成，如下图：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img7.png" alt="img"> </p>
<p> 0~1位用来存储RPL，即特权级；第2位是TI(Table Indicator)，用来表示选择子是GDT还是LDT的索引；3~5位是描述符的索引值，就是数组下表</p>
<p> <strong>PS：我们注意到索引一共是13位，也就是说一个GDT最多有2^13&#x3D;8192个表项</strong></p>
</li>
<li><p>LDT(Local Descriptor Table)是局部描述符，一个任务对应一个LDT，但它在现实中应用很少，我们的系统中也未用到LDT</p>
</li>
<li><p>GDTR(Global Descriptor Table Register)是用来指向GDT的寄存器，GDT存储在内存中，GDTR存储的则是GDT的地址。</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img8.png" alt="img"> </p>
<p> 如图所示是GDTR的结构，48位寄存器前16位是GDT以字节为单位的界限，后32位是GDT在内存中的起始地址</p>
<p> <strong>GDT界限范围有16位，也就是占有2^16个字节，而一个表项占有8字节，一个GDT一共可以存储2^16&#x2F;8&#x3D;8192个表项，和上面结论相符合</strong></p>
</li>
<li><p>ldgt(load Gloabal Descriptor Table)指令用来加载GPT，一般情况下从实模式进入保护模式我们需要使用命令ldgt来初始化GPTR，不仅如此，在保护模式中我们也可以使用ldgt命令来修改GPTR的值。ldgt的指令格式是：lgdt 48位内存数据</p>
</li>
<li><p>段描述符与内存的关系</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img9.png" alt="img"> </p>
<p> 如图可知，段描述符指向内存的各个地方。但是GDT的第0个段描述符是不可用的，因为GDT是用选择子来索引的，如果选择子忘记初始化就默认为0，这样选择子相当于索引到不可用的段描述符，而不会索引到其他内存空间。</p>
</li>
</ol>
<h2 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h2><ol>
<li><p>实模式下的地址回绕</p>
<p> 实模式下有20根地址线，也就是说最多可以索引1MB空间。实模式下我们用<code>16位段基址:16位偏移量</code>的形式来计算物理地址，我们发现假设16位段基址是0xFFFF，16位地址量是0xFFFF，最终计算得到的物理地址应该是：0xFFFF*16+0xFFFF&#x3D;0x10FFEF,我们发现这个地址已经超出了20位地址线所能传输的最大范围0xFFFFF。那当我们在实模式下访问超出0xFFFFF物理地址范围的空间时会发生什么事吗？其实并不会发生太糟糕的事，由于硬件原因，超出20位地址线的位将被舍弃，当你访问超过0x100000时就相当于访问0x00000,访问0x10FFEF时就相当于访问0x0FFEF。这个特点就叫做地址回绕。</p>
</li>
<li><p>32位CPU也要兼容地址回绕</p>
<p> 实模式下地址回绕的特性被许多程序员视为优点加以利用编程，但是保护模式却没有地址回绕这个问题。所以为了满足32位CPU必须兼容保护模式和实模式的特点，我们必须让32位CPU也要具备可以自由使用地址回绕的特点。</p>
<p> 我们知道32位CPU有32位的地址线，IBM在键盘控制器上的一些输出线来控制第21根地址线(A20)的有效性，成为A20Gate。</p>
<p> 如果A20Gate&#x3D;1，当访问0x100000~0x10FFEF之间的地址将会正常访问</p>
<p> 如果A20Gate&#x3D;0，当访问0x100000~0x10FFEF之间的地址将会触发地址回绕特性</p>
</li>
<li><p>打开A20地址线</p>
<p> 因此，当我们想从实模式进入保护模式时，我们必须打开A20Gate才能让保护模式的程序正常运行，打开A20Gate的代码如下：</p>
<pre><code> in al,0x92
 or al,0000_0010B
 out 0x92,al
</code></pre>
</li>
</ol>
<h2 id="保护模式的开关-CRO寄存器的PE位"><a href="#保护模式的开关-CRO寄存器的PE位" class="headerlink" title="保护模式的开关,CRO寄存器的PE位"></a>保护模式的开关,CRO寄存器的PE位</h2><p>想从实模式进入保护模式，我们还差最后一步。控制寄存器CRx是CPU的窗口，既可以用来展示CPU内部状态，又可以用来控制CPU运行机制。这次我们要用到CR0寄存器的PE（Protection Eanble）位，CR0寄存器构造如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img10.png" alt="img"> </p>
<p>右上方是CR0格式位，下方则是对每个位的描述，我们目前只需要关注PE位就行了，将PE位置1，让CPU知道我们要进入保护模式了，代码如下：</p>
<pre><code>mov eax,cr0
or eax,0x00000001
mov cr0,eax
</code></pre>
<h1 id="编写loader-S进入保护模式"><a href="#编写loader-S进入保护模式" class="headerlink" title="编写loader.S进入保护模式"></a>编写loader.S进入保护模式</h1><h2 id="头文件boot-inc更新"><a href="#头文件boot-inc更新" class="headerlink" title="头文件boot.inc更新"></a>头文件boot.inc更新</h2><pre><code>;--------------loader和kernel----------------

LOADER_BASE_ADDR equ 0x900
;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

LOADER_START_SECTOR equ 0x2
;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区

;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------
;为了方便我们将64位的gdt描述符分为高32位和低32位来定义，下面代码定义的都是低32位


;二进制数据中间的&#39;_&#39;符号没有任何意义，仅仅只是为了让程序员看得更清楚，编译器会自动忽略
;命名中的DESC是描述的意思
DESC_G_4K equ 1_00000000000000000000000b ;第23位G 表示4K或者1MB位 段界限的单位值 此时为1则为4k 
DESC_D_32 equ 1_0000000000000000000000b  ;第22位D/B位 表示地址值用32位EIP寄存器 操作数与指令码32位
DESC_L    equ 0_000000000000000000000b   ;第21位 设置成0表示32位代码段而非64位代码段
DESC_AVL  equ 0_00000000000000000000b    ;第20位 CPU不用此位设置为0


;LIMIT代表段界限，我们打算在GPT里加入三个段：代码段、数据段、显存段(就是将之前显存的位置单独划分一个成一个段)
;我们对4GB的内存空间采用平坦模式，也就是说基址=0，偏移量最大范围=4GB（除了显存段外，显存段任然放置在0xB8000~0xBFFFF）
;DESC_LIMIT_CODE2代表定义代码段的段界限(第二部分)
DESC_LIMIT_CODE2  equ  1111_0000000000000000b   ;平坦模型要满足最大段界限*粒度=4GB，换算可知段界限必须为0xFFFFF,也就是全为1
DESC_LIMIT_DATA2  equ  DESC_LIMIT_CODE2         ;相同的值  数据段与代码段段界限相同
DESC_LIMIT_VIDEO2 equ	0000_0000000000000000b	;第16-19位 显存段任然放置在0xB8000~0xBFFFF，段基址应该为0xbffff,
                                                ;段界限应该为(0xbffff-0xb8000)/4k=7(高4位为0)


DESC_P            equ 	1_000000000000000b	  
DESC_DPL_0        equ  00_0000000000000b         
DESC_DPL_1        equ  01_0000000000000b	  
DESC_DPL_2        equ  10_0000000000000b
DESC_DPL_3        equ  11_0000000000000b
DESC_S_sys        equ  0_000000000000b           
DESC_S_CODE       equ  1_000000000000b        
DESC_S_DATA       equ  DESC_S_CODE


;这边存在一个问题，根据书本上的Type格式图里从3~0位数据段的排序应该是xwea，而代码部分则按照xewa的顺序，需要进一步确认
DESC_TYPE_CODE    equ  1000_00000000b            ;第9-11位表示该段状态 1000 可执行 不允许可读 已访问位0
;x=1 e=0 w=0 a=0
DESC_TYPE_DATA    equ  0010_00000000b            ;第9-11位type段   0010  可写  
;x=0 e=0 w=1 a=0



;代码段描述符高位4字节初始化 (0x00共8位 &lt;&lt;24 共32位初始化0) 
;4KB为单位 Data段32位操作数 初始化的部分段界限 最高权限操作系统代码段 P存在表示 状态 
DESC_CODE_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \
DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00

;数据段描述符高位4字节初始化
DESC_DATA_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00

;显存段描述符高位4字节初始ua
DESC_VIDEO_HIGH4   equ (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B  ;书本上末尾是0，但显存段段基址应该为0xbffff，也就是说这边末尾应该是B 



;-------------------- 选择子属性 --------------------------------
RPL0    equ 00b
RPL1    equ 01b
RPL2    equ 10b
RPL3    equ 11b
TI_GDT  equ 000b
TI_LDT  equ 100b
</code></pre>
<p><strong>PS：在本段代码中对数据段type字段x&#x3D;0 e&#x3D;0 w&#x3D;1 a&#x3D;0之间的顺序尚不明确，是个还没解决的问题，有机会再来回答</strong></p>
<h2 id="loader-S更新"><a href="#loader-S更新" class="headerlink" title="loader.S更新"></a>loader.S更新</h2><pre><code>;loader.S 负责进入保护模式

%include &quot;boot.inc&quot;
SECTION loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
jmp loader_start                      		   ;跳跃到代码区


    ;构建gpt及其内部的描述符
    ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
    ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
    GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                dd 0x00000000 

    CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                dd DESC_CODE_HIGH4

    ;这边数据段和栈段共用一个段（因为栈段本身就是反方向增长的数据段）
    ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
    ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
    ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
    ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
    DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                        dd DESC_DATA_HIGH4

    VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                dd DESC_VIDEO_HIGH4     	  
                    
    GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
    GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

    times 60 dq 0                              ;预留60个 四字型 描述符


    ;构造16位的段选择子
    SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
    SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
    SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0


    ;gdt指针（要放置在GDTR的48位内存数据） 
    ;2字gdt界限放在前面 4字gdt地址放在后面 
    ;lgdt 48位格式 低位16位界限 高位32位起始地址
    gdt_ptr         dw GDT_LIMIT
                    dd GDT_BASE


    loadermsg db   &#39;welcome to loader zone!&#39;                  ;loadermsg 加载区显示字符


;以下代码则是正式进入保护模式
loader_start:

    ;这段和之前一样，调用BIOS提供的int10功能显示字符
    mov sp,LOADER_BASE_ADDR					
    mov bp,loadermsg                                           
    mov cx,23     
    mov ax,cs                                                 
    mov es,ax                                                 
    mov ax,0x1301                                             
    mov bx,0x001f                                           
    mov dx,0x1800                                             
    int 0x10
    
    ; --------------------------------- 设置进入保护模式 -----------------------------
    ; 1 打开A20 gate 
    in al,0x92                
    or al,0000_0010b
    out 0x92,al

    ; 2 加载gdt
    lgdt [gdt_ptr] 

    ; 3 将cr0 的 pe位置1
    mov eax,cr0                
    or  eax,0x00000001              
    mov cr0,eax
    
    ;-------------------------------- 已经打开保护模式 ---------------------------------------
    jmp dword SELECTOR_CODE:p_mode_start                       
    

[bits 32]
p_mode_start: 
    ;是初始化段选择子
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax
    
    ;测试显存段
    mov byte [gs:160],&#39;P&#39;
    
    jmp $     
</code></pre>
<h2 id="mbr-S更新"><a href="#mbr-S更新" class="headerlink" title="mbr.S更新"></a>mbr.S更新</h2><p>由于loader.S编译出来的loader.bin的大小已经超出了一个扇区也就是512字节，所以我们需要将mbr.S里调用装载loader函数前传参从<code>mov cx,1</code>改成<code>mov cx,4</code>（假设loader.bin占据了4个扇区，这样以后就不用每次更新都要修改）</p>
<p>还有dd指令装载loader.S时也要有相应的更改,将<code>count=1</code>改为<code>count=4</code></p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>屏幕显示如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img11.png" alt="img"></p>
<p>可以用<code>info gdt</code>查看构建的gdt:</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img12.png" alt="img">  </p>
<h1 id="处理器微架构简介-jmp清空流水线"><a href="#处理器微架构简介-jmp清空流水线" class="headerlink" title="处理器微架构简介(jmp清空流水线)"></a>处理器微架构简介(jmp清空流水线)</h1><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>指令并不是以原子的形式执行的，而是可以被拆分的。我们把一条指令拆分成三部分取指、译码、执行，CPU在一个时间段内无法执行两个执行，但是在一个时间段内可以同时执行取值&#x2F;译码&#x2F;执行。</p>
<p>这样可以大大缩短执行时间，三级流水线技术如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img13.png" alt="img"></p>
<p>如果原子性地执行3条指令需要9个周期，采用流水线技术就可以在5个周期内执行3条指令</p>
<p>在流水线基础上，我们发现一个规律：影响流水线效率地关键在分割的细度，分割得越细，执行得越快</p>
<p>你可以假想一下将一条指令划分为4个部分的四级流水线，4级流水线执行速度就将比3级更快</p>
<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>CPU并非一直按照顺序执行命令，而是按照一定的策略打乱执行顺序（当然，有相关关系的指令顺序不能被打乱），来提升速度</p>
<p>如以下代码：</p>
<pre><code>mov eax,[0x1234]
add ecx,ebx
</code></pre>
<p>两条指令并没有因果关系，因此在第一条指令等待内存访问时，第二条指令将会先执行，以此提高整体速度</p>
<p>再看以下代码：</p>
<pre><code>mov eax,[0x1234]
push eax
call function
</code></pre>
<p>第一条指令和第二条指令之间存在相关关系，那它就不能乱序执行了吗？不完全是。</p>
<p>第二条指令本质上可以被划分为两个微操作:<code>sub esp,4</code>和<code>mov [esp],eax</code>,我们发现只有<code>mov [esp],eax</code>和第一条指令相关。</p>
<p>因此CPU乱序执行可以在等待第一条指令的内存访问时执行<code>sub esp,4</code>，甚至还会先执行第三条指令</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>基于时间局部性和空间局部性原理发明的硬件(SRAM),当CPU需要去访问内存时先看看缓存，缓存有的话就不用去内存了，大大提高速度。</p>
<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>分支预测时针对有条件跳转指令(if&#x2F;switch&#x2F;for&#x2F;while)在流水线上糟糕的表现研发出的技术</p>
<p>我们发现流水线技术里你执行当前指令的同时（或者说当前指令还没执行完），你就必须知道下一条指令是什么并且进行操作。</p>
<p>如果所有指令都是顺序的话，那当然没什么问题。但是程序都是有分支的(有条件跳转指令)，假想我们现在在执行一条有条件跳转指令，那请问流水线的下一步要取那一条指令？要取左边的指令还是取右边的指令？如果出错了我们就必须花费一定的代价来清除流水线。</p>
<p>最简单的分支预测是根据上一次是否跳转来执行，如果上一次跳转了，那么我们预测这一次也跳转（想想循环指令就明白为什么了）</p>
<p>Intel的分支预测部件中用了分支目标缓冲区(Branch Target Buffer,BTB)如下图:</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img14.png" alt="img"></p>
<p>本质上就是根据过往统计次数来判断下一次是否跳转</p>
<h2 id="为什么使用远跳转指令来清空流水线"><a href="#为什么使用远跳转指令来清空流水线" class="headerlink" title="为什么使用远跳转指令来清空流水线"></a>为什么使用远跳转指令来清空流水线</h2><p>我们使用<code>jmp dword SELECTOR_CODE:p_mode_start</code>来更新流水线，究竟是为什么？</p>
<ol>
<li><p>段描述缓冲寄存器未更新</p>
<p> 32位CPU兼容保护模式和实模式，段缓存寄存器在实模式下和保护模式下都有用。实模式下：段描述缓冲寄存器用于缓存段基址，保护模式下：段描述缓冲寄存器缓存段描述符。只有当CPU重新引用一个段后，段描述缓冲寄存器才会更新。</p>
<p> 当我们从实模式到保护模式后，我们的段描述缓存寄存器存在的还是实模式下用的20位段基址，这当然是不行的。所以我们指令跳转到<code>SELECTOR_CODE:p_mode_start</code>相当于重新引用一个段，让它更新。</p>
</li>
<li><p>流水线中指令译码错误</p>
<p> 从实模式到保护模式，一开始我们是16位指令，后来是32位指令。因为CPU的流水线技术提前被加载进流水线的32位指令可能会被译码错误成16位指令。因此我们使用无条件跳转指令jmp,跳转过后会自动清空流水线，避免译码错误。</p>
</li>
<li><p>dword</p>
<p> dword则是让编译器将<code>p_mode_start</code>当成32位操作数处理保证得到正确的地址</p>
</li>
</ol>
<h1 id="保护模式提供的保护"><a href="#保护模式提供的保护" class="headerlink" title="保护模式提供的保护"></a>保护模式提供的保护</h1><p>这里围绕对内存段的保护做基本的阐述，其他方面的保护，如特权级以后再说</p>
<h2 id="向段寄存器加载选择子时提供的保护"><a href="#向段寄存器加载选择子时提供的保护" class="headerlink" title="向段寄存器加载选择子时提供的保护"></a>向段寄存器加载选择子时提供的保护</h2><p>当引用一个内存段时，实际上就是往段寄存器加载选择子，为了避免出现非法访问内存段的情况，处理器为做以下检测：</p>
<ol>
<li><p>判断选择子的索引值是否越界(0&lt;选择子的索引值&lt;8192)</p>
</li>
<li><p>检测段寄存器的用途和段类型是否匹配，大致原则如下：</p>
</li>
</ol>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img15.png" alt="img"></p>
<ol start="3">
<li>检测段描述符的P位，判断其是否存在</li>
</ol>
<h2 id="对代码段和数据段的保护"><a href="#对代码段和数据段的保护" class="headerlink" title="对代码段和数据段的保护"></a>对代码段和数据段的保护</h2><p>CPU每访问一个地址，都要确定其地址不能超过其所在内存段的范围</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/10/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-10 13:28:18" itemprop="dateCreated datePublished" datetime="2023-11-10T13:28:18+08:00">2023-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-11 17:02:44" itemprop="dateModified" datetime="2023-11-11T17:02:44+08:00">2023-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们将在上一章节的基础上完善MBR,学会使用IO接口的两种方法</p>
<p>相应的本章一共要完成两个实验：一个是MBR使用显存和显卡沟通，另一个是MBR通过端口将磁盘上的loader程序加载到内存相应位置</p>
<h1 id="地址、section和vstart"><a href="#地址、section和vstart" class="headerlink" title="地址、section和vstart"></a>地址、section和vstart</h1><ol>
<li><p>地址</p>
<p> 地址只是数字，描述各种符号在源程序中的位置，它是源代码文件中符号<strong>偏移</strong>文件开头的位置。编译器的工作就是给代码里的各符号编址。</p>
<p> 下图给出了一个程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img1.png" alt="img"></p>
<p> 仔细观察图片可得到这样一种关系：地址&#x3D;上一个地址+上一个地址内容的长度</p>
<p> 于是我们得出一个关于地址的结论：编译器给程序中各符号（变量名或函数名）分配的地址就是各符号相对于文件开头的<strong>偏移量</strong></p>
</li>
<li><p>section</p>
<p> 编译器提供section关键字（伪指令）是为了让程序员在逻辑上将程序划分为几个部分。一般section的应用场景就是根据不同的属性人为地讲程序划分几部分，如数据放在一个section中，指令放在另一个section中。</p>
<p> 下图给出了一个包含section分段程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img2.png" alt="img"></p>
<p> <strong>PS：程序第三行地section.data.start代表地是名为data的section在本文件中相对于文件开头的偏移量</strong></p>
<p> 仔细观察图片我们得出结论：关键字section并没有对程序中的地址产生任何影响，seciton仅仅是为了让开发人员梳理程序之用。</p>
</li>
<li><p>vstart：</p>
<p> vstart的作用是为section内的数据指定一个虚拟的起始地址。</p>
<p> 下图给出了一个包含vstart修饰section分段程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img3.png" alt="img"></p>
<p> 仔细观察图片，首先我们确定vstart对数据本身在文件的真实物理地址没有任何影响。</p>
<p> 那vstart影响的是什么? vstart影响的是虚拟段基址的值。在没有vstart的情况下，每个段的虚拟段基址默认是上一个段的结尾（首段虚拟段基址默认为0）；有了vstart后，就人为规定了虚拟的段基址。</p>
<p> vstart的使用时机：我们预先知道我们的程序将来被加载到某地址。</p>
<p> <strong>PS：vstart&#x3D;xxxx，并不是告诉编译器要把程序加载到地址xxxx，而是开发人员事先知道这段程序会被加载到xxxx，为了保证程序后续地址（相对文件开头地址的偏移量）的正确性，我们使用vstart提前告诉编译器：这个文件数据的相对地址不再是相对于上一个段末尾或者0了，而是要相对于xxxx，编译器编译时就会计算<code>xxxx+地址（相对文件开头地址的偏移量）</code>得到正确地址</strong></p>
</li>
</ol>
<h1 id="CPU的实模式"><a href="#CPU的实模式" class="headerlink" title="CPU的实模式"></a>CPU的实模式</h1><p>实模式是指8086CPU的工作环境、工作内容、工作状态一整套内容（寻址方式、寄存器大小、指令用法等），而不是单一某个方面的内容。</p>
<p>实模式的特点如下：</p>
<ol>
<li><p>CPU只能寻址1MB范围的物理内存（并不代表内存大小1MB），因为它只有20位地址线</p>
</li>
<li><p>实模式下操作系统和应用程序的执行权限都一样，没有任何保护；实模式下应用程序也可随意修改操作系统的内存（当然这是不安全的）</p>
</li>
<li><p>实模式中CPU使用分段的内存管理模式，即<code>物理地址=段基址&lt;&lt;4+段内偏移</code>，实模式中的逻辑地址就是物理地址，没有虚拟地址一说。</p>
</li>
<li><p>实模式中CPU使用中断向量表来响应中断</p>
</li>
<li><p>实模式下所有寄存器都是16位</p>
</li>
<li><p>实模式的寻址方式可分为三大类寄存器寻址、立即数寻址、内存寻址；其中内存寻址又可以分为直接寻址、基址寻址、变址寻址、基址变址寻址</p>
</li>
</ol>
<p>总而言之：你在汇编语言中接触到的相关知识，基本就是实模式下的相关知识。建议学习<code>王爽的《汇编语言》</code></p>
<h1 id="改进MBR：通过显存与显卡沟通"><a href="#改进MBR：通过显存与显卡沟通" class="headerlink" title="改进MBR：通过显存与显卡沟通"></a>改进MBR：通过显存与显卡沟通</h1><p>上一章节中我们的MBR是通过BIOS提供的中断例程实现的，BIOS提供的中断例程利用了只有在实模式下才可使用的中断向量表，由于我们进入保护模式后无法调用BIOS提供的中断例程，所以我们必须学会直接显卡沟通。</p>
<ol>
<li><p>CPU如何与外设通信？</p>
<p> CPU与外设的通信采用：<code>CPU——IO接口——外设</code>的形式。不同外设有不同的协议、不同的规则、不同的速度等，CPU无需关心这些，由IO接口来负责二者之间的沟通交流，CPU只需要知道怎样和IO接口沟通就行，如图式结构：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img4.png" alt="img"></p>
<p> <strong>PS：南桥芯片又叫输入输出控制中心，用于连接一些低速设备，可以把它看作是IO接口的集合管理中心</strong></p>
</li>
<li><p>CPU如何与IO接口通信？</p>
<p> IO接口可以提供两种方式与CPU沟通，一种是IO内存、另一种是IO端口。</p>
<p> IO内存是将外设的寄存器映射到CPU的地址空间中，使得CPU可以用内存访问指令来访问外设，如同访问内存一样。此时写入特定位置的内存，就相当于写入外设的寄存器里。</p>
<p> IO端口是将外设的寄存器分配一个唯一的地址，使得CPU可以用专门的<code>in/out</code>(输入输出指令)来访问外设。</p>
</li>
<li><p>CPU使用IO内存与显卡沟通</p>
<p> 显存是显卡中的一块内存，显卡所做的工作就是不断将显存里的数据放到显示器上。</p>
<p> 显存被映射到CPU的内存中的地址如下：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img5.png" alt="img"></p>
<p> 我们只需要往<code>0xB80000~0xBFFFF</code>32KB大的显存映射范围内里写入数据，就可以实现直接让数据显示到显示屏上。</p>
<p> 显卡在加电后，屏幕默认输出格式是80*25，也就是一屏幕共可以输出2000个字符。其中每个字符需要两字节表示，低位字节代表字符的ASCII码，高位字节代表字符的属性信息。32KB&#x2F;4000Byte约等于8屏幕数据，也就是说显存一次输出可以输出8个屏幕的数据。</p>
<pre><code> ; 修改后的MBR代码如下：实现直接与显卡沟通在屏幕上打印字符

 SECTION MBR vstart=0x7c00
     ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

     mov ax,cs
     mov ds,ax
     mov es,ax
     mov ss,ax
     mov fs,ax
     ;利用CS=0初始化各个段寄存器
     mov sp,0x7c00
     ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

     mov ax,0xb800;
     mov gs,ax
     ;令附加段基址寄存器gs指向显存映射地址

 ;------------------------------------------------------------------------------------------
     ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

     mov ax,0x600
     mov bx,0x700
     mov cx,0
     mov dx,0x184f

     int 0x10

 ;------------------------------------------------------------------------------------------
     ;以下代码直接向显存输入数据，实现打印输出背景色绿色，前景色红色，并且跳动的字符串&#39;1 MBR&#39;

     mov byte [gs:0x00],&#39;1&#39;
     mov byte [gs:0x01],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x02],&#39; &#39;
     mov byte [gs:0x03],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x04],&#39;M&#39;
     mov byte [gs:0x05],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x06],&#39;B&#39;
     mov byte [gs:0x07],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x08],&#39;R&#39;
     mov byte [gs:0x09],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

 ;------------------------------------------------------------------------------------------

     jmp $ ;实现死循环，让程序悬停

     times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
     db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
</li>
</ol>
<h1 id="bochs的调试方法-插曲"><a href="#bochs的调试方法-插曲" class="headerlink" title="bochs的调试方法(插曲)"></a>bochs的调试方法(插曲)</h1><p>请运行bochs后，输入<code>help</code>，即可看到bochs相关的所有调试指令</p>
<p>指令大概分为四类：Debugger control、Execution control、Breakpoint control、CPU and memory contents</p>
<p>针对大类里的每一个指令，都可以输出<code>help &#39;指令关键字&#39;</code>来查看该指令的具体用法</p>
<p>不需要对每个指令死记硬背，多多尝试就熟悉了</p>
<h1 id="改进MBR：与磁盘沟通"><a href="#改进MBR：与磁盘沟通" class="headerlink" title="改进MBR：与磁盘沟通"></a>改进MBR：与磁盘沟通</h1><ol>
<li><p>in&#x2F;out 命令</p>
<p> CPU提供了专门的指令来和IO接口进行端口沟通：</p>
<ul>
<li><p>in指令用于从端口中读取数据，格式如下：</p>
<pre><code>  in al,dx
  in ax,dx
</code></pre>
<p>  只要使用in指令，源操作数必须是dx(存放端口号)，而目的操作数是用al，还是ax取决于dx端口指代的寄存器是8位宽还是16位宽</p>
</li>
<li><p>out 指令用于往端口中写数据，格式如下：</p>
<pre><code>  out dx,al
  out dx,ax
  out 立即数,al
  out 立即数,ax
</code></pre>
<p>  out指令的源操作数是ax还是al取决于目标端口指代的寄存器是8位宽还是16位宽，源操作数可以是立即数直接给出端口号，也可以用dx（存放端口号）</p>
</li>
</ul>
</li>
<li><p>磁盘IO端口相关知识</p>
<ul>
<li><p>什么是硬盘控制器？</p>
<p>  硬盘控制器是CPU于硬盘沟通中间的IO接口</p>
</li>
<li><p>Primary通道和Secondary通道</p>
<p>  以前的主机一般只接受四个并口磁盘。主板上提供了两个IDE（Integrated Drive Electronics，硬盘控制器和硬盘集成在一起的集成设备电路）插槽。用Primary通道和Secondary通道来区分这两个不同的IDE，用于连接硬盘和主板。每个通道可以挂载两个硬盘，分别称为主盘（Master）和从盘（Slave）。主盘和从盘的区别主要是在启动顺序和数据传输上，一般来说，主盘优先于从盘启动，而从盘的数据传输需要经过主盘。每个通道都有自己的一组端口寄存器，用于控制和访问硬盘。</p>
<p>  当然上面的描述是以前主机的硬盘布局，现在的大有不同了，但我们学习使用较为简单的以前主机的IO接口相关知识。</p>
</li>
<li><p>LBA和CHS</p>
<p>  一个磁盘里有很多个扇区，要描述一个扇区的具体位置可以通过多种方法。</p>
<p>  一般口头上描述扇区的位置可以用“柱面-磁头-扇区”来定位（Cylinder Head Sector），简称为CHS。CHS描述法的扇区并非是从0开始的，而是从1开始的。</p>
<p>  CHS描述是从物理结构上来描述的，但我们希望在编程时可以不用考虑磁盘的物理结构，只需要通过逻辑结构来定位扇区就行了，于是有了LBA（Logical Block Address）</p>
<p>  LBA有LBA28和LBA48两种。我们只介绍LBA28：就是通过28位bit来描述一个扇区的位置，最大的寻址范围是2^28。</p>
<p>  向磁盘沟通时，端口寄存器必须要知道你是向哪一块磁盘沟通，也就是说知道LBA28。我们用3个8位寄存器（LBA low、LBA mid、LBA high）以及device寄存器其中的4位一共28位表示LBA28</p>
</li>
<li><p>硬盘控制器主要端口寄存器</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img6.png" alt="img"></p>
<ul>
<li><p>我们在与磁盘沟通时，首先要确认我们是与哪一个通道的主盘&#x2F;从盘沟通，然后查看这张表中对应的端口号，以Primary通道为例：</p>
</li>
<li><p>0x1F3、0x1F4、0x1F5三个端口号不论是读操作还是写操作时都是用来记录LBA28低24位的地址的（标记你是与那一块扇区沟通）</p>
</li>
<li><p>0x1F0 端口号映射Data寄存器，写操作时，从外面往里面写数据进去；读操作时，从里面往外读数据出来。<strong>该端口是这里唯一的16位寄存器，其余端口都是8位</strong></p>
</li>
<li><p>0x1F1 读操作时用于存放失败状态信息，写操作时用于存放写操作参数</p>
</li>
<li><p>0x1F2 读操作时用于存放要读取的扇区数，写操作是用于存放要写入的扇区数</p>
</li>
<li><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img7.png" alt="img"></p>
<p>  0x1F6 读写时都是device寄存器，也就是驱动器，具体功能见上图：0~3位放置LBA28的高4位，4位指定是主盘还是从盘，5~7位指定寻址模式（CHS为101，LBA为111）</p>
<p>  0x1F7 写操作时用于写入命令，一旦写入命令磁盘立即指向，主要有三个命令(1) 0xEC，硬盘识别 （2）0x20，读扇区 （3）0x30，写扇区。读操作时则是statue寄存器，具体功能见上图</p>
</li>
</ul>
</li>
<li><p>约定好的IO端口沟通操作顺序</p>
<p>  了解了这些寄存器的功能后我们就可以知道如何与磁盘进行沟通了，但第一步我们先约定一个操作执行顺序，确保大家不会乱（当然你不按照这个顺序也行）：</p>
<ol>
<li><p>先选择通道，往该通道的sector cout寄存器写入待操作的扇区数</p>
</li>
<li><p>往通道上的三个LBA写入扇区地址LBA28的低24位</p>
</li>
<li><p>往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式</p>
</li>
<li><p>往该通道的command寄存器写入命令（一旦写入立即执行）</p>
</li>
<li><p>读取status寄存器，判断硬盘工作是否完成</p>
</li>
<li><p>如果上诉是写操作，则到此完工；如果上诉是读操作，则还需要一步</p>
</li>
<li><p>将硬盘数据读出</p>
</li>
</ol>
<p>  <strong>PS：操作并不是单纯的读，我们要读取一块扇区上的数据，我们要做的一步是把读取命令写入command寄存器，注意，是写入！也就是说读操作中也包含写入的过程</strong></p>
</li>
<li><p>常用的数据传输方式</p>
<p>  当我们要读取硬盘中的某个扇区，我们先写入读取命令并判断硬盘工作已经完成，在判断硬盘工作是否完成(上述5操作)这一步我们区分出了不同的数据传输方式</p>
<ol>
<li><p>无条件传输：数据源设备随时准备好数据，CPU随取随拿，如寄存器、内存等设备，CPU无需提前打招呼。</p>
</li>
<li><p>查询传送方式：CPU按照一定间隔不断去检测设备是否完成操作，如果完成，则CPU去取数据</p>
</li>
<li><p>中断传送方式：CPU无需不断检测，而是当设备完成时触发中断，由中断来通知CPU我数据已经准备好了</p>
</li>
<li><p>直接存储器存取方式（DMA）：不让CPU参与传输，完全由数据源设备和内存直接传输，CPU直接到内存中拿数据即可</p>
</li>
<li><p>I&#x2F;O处理机传送方式：引入完整的一套硬件来处理这些事，CPU甚至不知道有传输这回事</p>
</li>
</ol>
<p>  <strong>PS:方式1磁盘用不了，方式4、5则需要硬件支持，所以在我们与硬件沟通时采用方式2或3</strong></p>
</li>
</ul>
</li>
<li><p>接力第三棒：loader</p>
<p> 我们的MBR受限于512字节的关系，无法做太多的事：没法为内核准备好环境，更没法将内核成功加载到内存并允许。</p>
<p> 所以我们要在另一个程序中完成初始化环境以及加载内核的任务，这个程序就是加载器loader</p>
<p> loader的源代码自然也是存在磁盘里的，MBR要负责从硬盘上把loder加载到内存，并把接力棒交给loader</p>
</li>
<li><p>修改后的代码</p>
<ul>
<li><p>boot.inc(头文件)</p>
<pre><code>  LOADER_BASE_ADDR equ 0x900
  ;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
  ;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
  ;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

  LOADER_START_SECTOR equ 0x2
  ;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
  ;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区
</code></pre>
</li>
<li><p>MBR.S</p>
<pre><code>  ; 主引导程序 MBR ：实现从硬盘上加载loader到内存中，并将接力棒交给loader

  %include &quot;boot.inc&quot;
  ;连接头文件，定义了LOADER_BASW_ADDR、LOADER_START_SECTOR

  SECTION MBR vstart=0x7c00
      ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

      mov ax,cs
      mov ds,ax
      mov es,ax
      mov ss,ax
      mov fs,ax
      ;利用CS=0初始化各个段寄存器
      mov sp,0x7c00
      ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

      

  ;------------------------------------------------------------------------------------------
      ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

      mov ax,0x600
      mov bx,0x700
      mov cx,0
      mov dx,0x184f

      int 0x10

  ;------------------------------------------------------------------------------------------
      ;以下是通过寄存器传递参数并调用 loader_ready_proc

      mov eax,LOADER_START_SECTOR ;eax记录LBA28，也就是loader在磁盘上的扇区地址
      mov bx,LOADER_BASE_ADDR     ;bx记录loader将要被移动到内存里哪个位置
      mov cx,1                    ;cx记录移动的扇区数

      call loader_ready_proc      ;调用函数装载loader
      jmp LOADER_BASE_ADDR        ;跳转到被装载到内存里的loader，将接力棒交给它
  ;------------------------------------------------------------------------------------------
  ;该函数的功能是装载loader
  loader_ready_proc:
      mov esi,eax                 ;ax会在后续in/out指令被使用，所以备份参数
      mov di,cx                   ;di会在后续循环中被用到，所以备份参数


      ;第一步：先选择通道，往该通道的sector cout寄存器写入待操作的扇区数
      mov ax,di
      mov dx,0x1f2
      out dx,al

      mov eax,esi                  ;复原eax


      ;第二步往通道上的三个LBA写入扇区地址LBA28的低24位
      mov dx,0x1f3
      out dx,al

      mov cl,8
      shr eax,cl       
      mov dx,0x1f4     
      out dx,al

      shr eax,cl
      mov dx,0x1f5
      out dx,al

      
      ;第三步 往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式
      shr eax,cl
      and al,0x0f
      or al,0xe0
      mov dx,0x1f6
      out dx,al


      ;第四步往该通道的command寄存器写入命令（一旦写入立即执行）
      mov dx,0x1f7
      mov al,0x20
      out dx,al


      ;第五步读取status寄存器，判断硬盘工作是否完成(这边采用查询传输的方式)
  .not_ready:
      nop            ;增加循环查询的延迟
      in al,dx
      and al,0x88
      cmp al,0x08
      jnz .not_ready


      ;最后一步将硬盘数据读出
      mov ax,di
      mov dx,256
      mul dx
      mov cx,ax
      ;一个扇区512字节，要读取di个扇区，每次读取2字节(16位的data寄存器),一共要循环读取di*512/2次

      mov dx,0x1f0
  .go_on_read:
      in ax,dx
      mov [bx],ax
      add bx,2
      loop .go_on_read

      ;函数loader_ready_proc结束返回
      ret


      times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
      db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
</li>
<li><p>loader.S</p>
<pre><code>  ;这串代码并非实现真正的loader功能，而是只是在屏幕上打印字符，来验证我们是否真正装载并执行了loader


  %include &quot;boot.inc&quot;

  section loader vstart=LOADER_BASE_ADDR

      mov ax,0xb800;
      mov gs,ax
      ;令附加段基址寄存器gs指向显存映射地址

  ;输出背景色绿色，前景色红色，并且跳动闪烁的字符串&quot;2 LOADER&quot;

      mov byte [gs:0x00],&#39;2&#39;
      mov byte [gs:0x01],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x02],&#39; &#39;
      mov byte [gs:0x03],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x04],&#39;L&#39;
      mov byte [gs:0x05],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x06],&#39;O&#39;
      mov byte [gs:0x07],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x08],&#39;A&#39;
      mov byte [gs:0x09],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0A],&#39;D&#39;
      mov byte [gs:0x0B],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0C],&#39;E&#39;
      mov byte [gs:0x0D],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0E],&#39;R&#39;
      mov byte [gs:0x0F],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      jmp $
</code></pre>
</li>
<li><p>一个小细节<br>  这些代码中默认我们的虚拟磁盘是Primary通道的主盘，可能有人会疑惑为什么是Primary通道的主盘，详细信息请看配置文件bochsrc.disk，如下所示</p>
<pre><code>  ata0:enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14
  ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat,cylinders=121,heads=16,spt=63
  # ata0代表IDE0也就是Primary通道，atao-master代表的是Primary通道的主盘
</code></pre>
</li>
</ul>
</li>
<li><p>装载代码</p>
<p> 我们现在有三个文件：头文件boot.inc、mbr.S、loader.S</p>
<ul>
<li><p>boot.inc<br>  请在代码文件夹下创建一个文件夹include,把boot.inc放在include下面，用于被其他文件引用链接</p>
</li>
<li><p>mbr.S<br>  我们使用在原有的命令上添加了include路径：</p>
<pre><code>  nasm -I include/ -o mbr.bin mbr.S
</code></pre>
<p>  然后继续使用dd命令将他装载到hd60M.img的第一块扇区:</p>
<pre><code>  dd if=/home/sparkle2/codeset/mbr.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 conv=notrunc
</code></pre>
</li>
<li><p>loader.S<br>  我们同样用带有include路径的命令编译它:</p>
<pre><code>  nasm -I include/ -o loader.bin loader.S
</code></pre>
<p>  然后继续使用dd命令将他装载到hd60M.img的第三块扇区（seek&#x3D;2代表跳过两块）:</p>
<pre><code>  dd if=/home/sparkle2/codeset/loader.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 seek=2 conv=notrunc
</code></pre>
</li>
</ul>
<p> 最后运行命令<code>bin/bochs -f bochsrc.disk</code>看到屏幕上出现<code>2 loader</code>的输出字符实验就成功了</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/09/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/09/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-09 23:15:59" itemprop="dateCreated datePublished" datetime="2023-11-09T23:15:59+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-11 17:01:58" itemprop="dateModified" datetime="2023-11-11T17:01:58+08:00">2023-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在这一章，我们编写一段MBR程序并装载在磁盘里，开始接手操作系统的第一步。</p>
<h1 id="BIOS与MBR的职责和功能"><a href="#BIOS与MBR的职责和功能" class="headerlink" title="BIOS与MBR的职责和功能"></a>BIOS与MBR的职责和功能</h1><p>下图是1MB寻址范围内存空间在实模式下的内存布局（注意区分寻址范围和空间大小的区别，实模式由于20位地址总线所以最大寻址范围是1MB，但这不代表内存空间大小就1MB，实际内存大小是1MB*Byte）：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img1.jpg" alt="img"></p>
<p><strong>PS：0x00000~0x9FFFF是RAM，0xA0000~0xFFFFF是ROM</strong><br><strong>你可能会觉得疑惑：一定要如此布局吗？</strong><br><strong>该布局方式源于早期系统，其中一些魔数（特别的数，像是为什么MBR其实地址在0x7C00）也是早期约定好的规矩，而后来的设备为了可以兼容早期设备都遵守这些规矩</strong></p>
<p>BIOS全称叫Base Input&amp;Output System，即基本输入输出系统，是固化在ROM上的一段程序</p>
<p>电脑上电后运行的第一个软件就是BIOS，也就是CS:IP在硬件支持下一上电即为<code>0xF000:0xFFF0</code>（BIOS的入口地址）。BIOS的入口地址处是一条跳转指令<code>jmp far f000:e05b</code>,CPU跳转并开始执行BIOS的程序，开始检测内存、显卡等外设信息，初始化硬件，并在<code>0x000~0x3FFF</code>处建立中断向量</p>
<p>BIOS的最后一项工作是校验启动盘中位于<code>0盘0道1扇区</code>（相当于0盘0道0扇区，1扇区和0扇区只是描述方法不同）的内容，如果此时扇区末尾的两个字节分别是0x55和0xaa，BIOS便将该扇区的内容认定为待装载的MBR程序（Main Boot Record 主引导记录），将其加载道物理地址0x7c00处，然后将控制权MBR，执行MBR程序</p>
<p>通俗地说：BIOS就是接力手的第一棒，MBR就是第二棒</p>
<p>我们的目的就是编写MBR程序，并装载到启动盘的<code>0盘0道1扇区</code>处，由我们来接手第二棒</p>
<h1 id="必须要了解的相关知识点"><a href="#必须要了解的相关知识点" class="headerlink" title="必须要了解的相关知识点"></a>必须要了解的相关知识点</h1><ol>
<li><p>MBR的大小必须是512字节，而且得保证0x55和0xaa在该扇区的这两个魔数出现在510字节和511字节</p>
</li>
<li><p>x86平台是小端序（低位字节放在低地址），也就是说对于0xaa55这条指令来说，0xaa高位字节放在高地址（511），0x55低位字节放在低地址（510）</p>
</li>
<li><p>$和$$是NASM预留的关键字，$是表示本行代码起始地址的标号，$$是表示本section代码起始地址的标号</p>
</li>
<li><p>section可以用vstart&#x3D;xxxx修饰，表示section的虚拟起始地址设置为xxxx</p>
</li>
<li><p>我们知道BIOS在扫描完0xaa55后会装载并跳转道0x7c00，这一步也是由硬件支持，CS:IP会被强制设置为<code>0x0000:0x7c00</code></p>
</li>
<li><p>NASM指令格式：<code>nasm -f &lt;format&gt; &lt;filename&gt; [-o &lt;output&gt;]</code> 其中<code>-f &lt;format&gt;</code>是指令输出文件格式，<code>&lt;filename&gt;</code>是目标文件名， <code>-o &lt;output&gt;</code>是指令输出文件名</p>
</li>
<li><p>关于输出文件格式有很多种，我们这里只关注bin和elf：bin是纯二进制文件（给CPU就可以直接运行）；elf是二进制可执行文件（里面参杂了些和指令无关的修饰，是给操作系统的程序加载器使用的）</p>
</li>
</ol>
<h1 id="MBR程序"><a href="#MBR程序" class="headerlink" title="MBR程序"></a>MBR程序</h1><p>编写文本文件 mbr.S </p>
<pre><code>; 主引导程序 MBR ：实现屏幕上打印字符&#39;1 MBR&#39;

SECTION MBR vstart=0x7c00
    ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

    mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    ;利用CS=0初始化各个段寄存器
    mov sp,0x7c00
    ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

    mov ax,0x600
    mov bx,0x700
    mov cx,0
    mov dx,0x184f

    int 0x10

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的3号子功能，获取光标位置，在光标处打印字符

    mov ah,3
    mov bh,0
    
    int 0x10

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的13号子功能，实现打印字符

    mov ax,message
    mov bp,ax

    mov cx,5
    mov ax,0x1301
    mov bx,0x2
    
    int 0x10

;------------------------------------------------------------------------------------------

    jmp $ ;实现死循环，让程序悬停

    message db &quot;1 MBR&quot;
    times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
    db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
<p><strong>PS:代码中关于BIOS提供的历程int 10具体格式注释中并没有给出，因为这块不重要，如果想知道为什么int 10的功能调用要这么编写可以查BIOS的手册，也可以查看<code>操作系统真象还原 P61</code></strong></p>
<h1 id="编译、装载并启动"><a href="#编译、装载并启动" class="headerlink" title="编译、装载并启动"></a>编译、装载并启动</h1><ol>
<li><p>编译：</p>
<p> 接下来我们要用<code>nasm -f bin mbr.S -o mbr.bin</code>(也可以简写成<code>nasm -o mbr.bin mbr.s</code>)对mbr.S进行编译,编译成功你就可以看到mbr.bin文件了</p>
<p> 我们还得用指令<code>ls -l</code>查看当前目录下所有文件及属性，检测一下mbr.bin文件的大小，是不是刚好512字节不多也不少</p>
</li>
<li><p>转载：</p>
<p> 然后我们要把mbr.bin文件装载到虚拟磁盘<code>hd60M.img</code>中的0盘0道1扇区处，可以使用dd命令：<code>dd if=/home/sparkle2/codeset/mbr.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 conv=notrunc</code></p>
<p> dd命令中<code>if</code>指定要读取的文件路径；<code>of</code>指定装载文件的路径；<code>bs</code>指令块的大小，也就是字节数；<code>cout</code>指令拷贝的块数；<code>conv</code>指定转换文件方式，在追加数据时conv最好用notrunc<br> 方式</p>
</li>
<li><p>启动</p>
<p> 最后我们进入安装目录下，使用命令<code>bin/bochs -f bochsrc.disk</code>启动，bochs emulator处于黑屏状态 在控制台按<code>c</code>进入调试模式，看到如下结果则大功告成：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img2.png" alt="img"></p>
<p> <strong>PS:我们可以注意到启动后，电脑上有两个窗口，一个是bochs emulator，另一个是控制台；bochs emulator就是我们模拟的机器。我在关闭bochs emulator是遇到一些问题，请不要直接点击bochs emulator窗口右上角的红叉，会引发关闭不了的问题。正确的做法是可以点击bochs emulator右上角第二行的电源键关闭模拟机器，再关闭控制台。也可以在控制台<code>Ctrl+C</code>退出调试模式，然后输入<code>q</code>退出该进程。</strong></p>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到这里我们就正式接受了电脑启动后的第二棒接力棒，开始正式掌权了。如果看完本文章还有疑惑，建议看下<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117782012">《操作系统真象还原》第二章 —- 编写MBR主引导记录 初尝编写的快乐 雏形已显！</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/08/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/08/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-08 15:08:46" itemprop="dateCreated datePublished" datetime="2023-11-08T15:08:46+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-09 15:06:51" itemprop="dateModified" datetime="2023-11-09T15:06:51+08:00">2023-11-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本系列记录我跟随<code>《操作系统真象还原》</code>制作一个简易的操作系统的全过程</p>
<h1 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h1><p>VMware是一款可以帮你轻松建立并管理虚拟机的工具。<code>操作系统真象还原</code>推荐使用虚拟机管理工具virtualBox，但由于我之前使用过VMware所以选择继续使用VMware</p>
<p>VMware的许可证密钥可以在网上轻松获得</p>
<p>具体的安装步骤请参照<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">八分钟完成VMware和ubuntu系统安装</a>的前半部分</p>
<h1 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h1><p>Ubuntu是以Linux为内核的操作系统，也是我们将来要自制简易操作系统的环境。<code>操作系统真象还原</code>推荐虚拟机安装Centos操作系统（二者都是Linux内核，听说Centos7会有些问题所以选择Ubuntu）</p>
<p>其中我的虚拟机设置是：2*2核、40G硬盘、2G内存；Ubuntu版本是20.04.6（兼容gcc 4）</p>
<p>具体的安装步骤请参照<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">八分钟完成VMware和ubuntu系统安装</a>的后半部分</p>
<p><strong>PS：从安装完Ubuntu后应该在执行每一个重要的步骤前给虚拟机拍一个快照，如果执行出错了，我们就可以回到快照处，保证虚拟机的正确性</strong><br><strong>安装Ubuntu时Language选项请选择英语，可以省去很多后续麻烦</strong></p>
<h1 id="安装VMware-Tool"><a href="#安装VMware-Tool" class="headerlink" title="安装VMware Tool"></a>安装VMware Tool</h1><p>VMware Tool可以实现主机和虚拟机之间拖拽传输文件以及通用复制粘贴，大大简化两机之间的交互难度</p>
<p>具体安装步骤请参照该<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YA411k7Lm/?spm_id_from=333.880.my_history.page.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">VMwareTools安装教程</a></p>
<p>如果在执行第二步Ubuntu时不是自定义安装而是简易安装，就有可能会遇到一个问题：ubuntu安装VMware-tools时，虚拟机中的选项是灰色的，点击不了。那么请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhvngchvng/article/details/108603053">ubuntu安装VMware-tools时，虚拟机中的选项是灰色的，点击不了</a></p>
<p><strong>PS：有的虚拟机安装完操作系统就自带安装VMware Tool了，请安装完Ubuntu看看虚拟机菜单，如果选项是’重新安装BMware Tool’就代表已经按照完毕</strong></p>
<h1 id="安装Bochs"><a href="#安装Bochs" class="headerlink" title="安装Bochs"></a>安装Bochs</h1><p>Bochs是一个x86硬件平台的开源模拟器，它可以模拟各种硬件的配置。Bochs模拟的是整个PC平台，包括I&#x2F;O设备、内存和BIOS，某种程度上来说Bochs也是一个虚拟机，我们未来就是要在Bochs上实现操作系统的制作。</p>
<p>我安装的是Bochs2.6.8，Bochs的具体安装步骤请参考<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117751327">《操作系统真象还原》第一章 —- 安装Vmware Station 安装Ubuntu 装载配置Bochs 安装Vmware tools 开始乘帆历险！</a>上半部分。</p>
<p>Bochs的下载我们可以在主机上下载完压缩包后再直接复制到虚拟机里</p>
<p>在解压后的文件夹下打开终端并输入命令</p>
<pre><code>./configure \
--prefix=/home/sparkle2/bochs \
--enable-debugger \
--enable-disasm \
--enable-iodebug \
--enable-x86-debugger \
LIBS=&#39;-lX11&#39; \
--with-x \
--with-x11

#上面的代码中，prefix指定的是安装bochs的路径
#LIBS这一行是原书上没有的，是我遇到第四个报错后查阅资料添加的
#除了最后一句命令外每一句结尾都是&#39; \&#39;代表着命令还未输入完，运行换行继续输入
</code></pre>
<p>等到上述命令得以正确执行后，还需要在Bochs的解压目录下执行两条命令：</p>
<pre><code>make
make install
</code></pre>
<p>Bochs就安装成功了，我们可以在指定路径下看到安装后的bochs文件夹</p>
<p>整个安装过程中我遇到了四个报错</p>
<ol>
<li>缺少C编译器</li>
<li>C++ preprocessor fails sanity check</li>
<li>“ERROR: X windows gui was selected, but X windows libraries were not found.</li>
<li>undefined reference to symbol ‘XSetForeground’</li>
</ol>
<p>其中前两个报错在上述文章中都已解决，第三个报错请参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/geeker_12/article/details/11409009">Ubuntu下安装Bochs各种奇怪错误汇总</a>，第四个报错请参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/cloudblaze/article/details/52752912">[乱七八糟]bochs编译错误之’XSetForeground’</a></p>
<p><strong>PS:在使用apt命令更新或下载一些东西时，有时候需要换源，在etc&#x2F;apt&#x2F;source.list文件中把下载源改为中国地区,否则会出现下载慢下载失败等问题</strong></p>
<h1 id="配置Bochs"><a href="#配置Bochs" class="headerlink" title="配置Bochs"></a>配置Bochs</h1><p>配置Bochs请参照<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117751327">《操作系统真象还原》第一章 —- 安装Vmware Station 安装Ubuntu 装载配置Bochs 安装Vmware tools 开始乘帆历险！</a>下半部分</p>
<p>我的配置文件如下：</p>
<pre><code>megs: 32
# megs书本是32，博客是512，我跟着书本走

romimage: file=/home/sparkle2/bochs/share/bochs/BIOS-bochs-latest
vgaromimage: file=/home/sparkle2/bochs/share/bochs/VGABIOS-lgpl-latest

boot: disk

log: bochs.out

mouse:enabled=0
keyboard:keymap=/home/sparkle2/bochs/share/bochs/keymaps/x11-pc-us.map

ata0:enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14

ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat,cylinders=121,heads=16,spt=63
#新加入的代码，也就是新建立的虚拟磁盘

# gdbstub:enabled=1,port=1234,text_base=0,data_base=0,bss_base=0
</code></pre>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到此，第一步环境的部署就做完了，第二步就可以开始正式写代码了。</p>
<p>只是环境部署就用了将近两天时间，期间反复下载了4次虚拟机，长路漫漫。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">VScode编码不一致问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 22:15:24" itemprop="dateCreated datePublished" datetime="2023-11-04T22:15:24+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:19:23" itemprop="dateModified" datetime="2023-11-06T11:19:23+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文描述并解决在VSCode里遇到的控制台编码与文件编码不一致导致的乱码问题</p>
<h1 id="VSCode控制台介绍"><a href="#VSCode控制台介绍" class="headerlink" title="VSCode控制台介绍"></a>VSCode控制台介绍</h1><p>VSCode里不止只有1个控制台，如下图所示：</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img1.png" alt="img"></p>
<p>图中一共有四个控制台，可通过终端窗口右上角的<code>+</code>进行调整</p>
<ul>
<li><p>PowerShell：VSCode默认采用PowerShell，功能上比cmd更为强大，兼容cmd命令的同时有自己扩展的指令集，用来管理Windows系统和应用程序，执行复杂的脚本和自动化任务。</p>
</li>
<li><p>Git Bash：Git Bash是Git自带的一个终端模拟器，兼容cmd命令的同时扩展了Linux命令和git命令，它可以在Windows上模拟Bash环境（Linux的控制台）。适合习惯使用Linux的用户。</p>
</li>
<li><p>JavaScript调试终端：可以让你在VSCode中直接运行和调试JavaScript代码，而不需要额外的配置或者浏览器。</p>
</li>
<li><p>Command Prompt：基于Dos的传统的cmd命令行，cmd不兼容上述控制台，只能用来执行一些基本的命令和批处理文件。</p>
</li>
</ul>
<p>除了上述四个控制台外，还有在调试代码时跳出的针对不同语言不同的控制台，例如：用于调试C++&#x2F;C代码的cppdbg；用于调试python代码的python Debug Console等等，可以在调试代码时，查看终端窗口右上角的小标题来确定你现在使用的是哪一个控制台</p>
<p>注意：不同的控制台使用的编码是独立不相互影响的，千万不要使用A控制台却去调整B控制台的编码</p>
<h1 id="VSCode文件编码介绍"><a href="#VSCode文件编码介绍" class="headerlink" title="VSCode文件编码介绍"></a>VSCode文件编码介绍</h1><p>VSCode当前文件编码格式可以查看右下角</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img2.png" alt="img"></p>
<p>如图，当前文件编码是UTF-8</p>
<p>如果想要修改该文件编码，可以点击图中的UTF-8</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img3.png" alt="img"></p>
<p>先选择通过目标编码方式保存，再通过目标编码方式打开，这样就成功修改了当前文件的编码格式</p>
<h1 id="常见的编码介绍"><a href="#常见的编码介绍" class="headerlink" title="常见的编码介绍"></a>常见的编码介绍</h1><ul>
<li><p>GBK：针对中文的编码（国内cmd默认的编码方式），在国家标准GB2312的基础上扩展的，向下兼容GB2312，但在国外并不常用。代码是936</p>
</li>
<li><p>UTF-8：UTF-8是一种针对多语言的编码，它包含了全世界所有国家需要用到的字符，基于Unicode字符集的，向下兼容ASCII，在国际上通行。代码是65001</p>
</li>
</ul>
<h1 id="如何查看并改变控制台编码"><a href="#如何查看并改变控制台编码" class="headerlink" title="如何查看并改变控制台编码"></a>如何查看并改变控制台编码</h1><p>在控制台里输入以下命令可以查看当前控制台编码格式：</p>
<pre><code>chcp
</code></pre>
<p>在控制台里输入以下命令可临时转化当前控制台编码格式：</p>
<pre><code>chcp &#39;编码代码&#39;
</code></pre>
<p>综上，只要保证文件和控制台编码格式相同，就不会出现乱码问题</p>
<h1 id="本文尚未解决的问题"><a href="#本文尚未解决的问题" class="headerlink" title="本文尚未解决的问题"></a>本文尚未解决的问题</h1><p>本文只提供了临时更改控制台编码的方法，并没有提供更改各个控制台默认编码的方法</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">个人博客创建指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 15:23:38" itemprop="dateCreated datePublished" datetime="2023-11-04T15:23:38+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:16:01" itemprop="dateModified" datetime="2023-11-06T11:16:01+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&emsp;&emsp;这篇文章记录我第一次创建个人博客的过程，使用了Github个人账户域名，开源免费的Hexo博客框架以及Next主题。</p>
<h1 id="安装Git和Node-js"><a href="#安装Git和Node-js" class="headerlink" title="安装Git和Node.js"></a>安装Git和Node.js</h1><p>Git 是一种分布式版本控制系统，即，代码的本地克隆就是一个完整的版本控制存储库。 通过这些功能齐全的本地存储库，无论脱机还是远程都能轻松工作。 开发人员会在本地提交其工作，然后再将存储库的副本与服务器上的副本进行同步。（Github就是搭配Git使用的用于存储代码的克隆库）</p>
<p>Node.js可以让JavaScript脱离浏览器运行，它是一个开源、跨平台的JavaScript运行时环境，可以用来开发高性能的 Web 服务器和网络应用。</p>
<p>搭建个人博客为何需要安装Git和Node.js?我们基于Hexo搭建博客，Hexo必须依赖Node.js提供的环境运行。而Git并非是搭建个人博客的必备，但我们仍然推荐下载Git，使用Git的相关命令来从Hexo下载Next主题。</p>
<ol>
<li><p>从官网上安装Git并配置相关环境变量（PS：安装完Git后你可以使用Git Bash作为命令行窗口调用命令，Git Bash上可以使用Linux格式的命令，但由于Git Bash上安装下载无法看到进度条的问题，我个人更推荐用cmd来进行操作，本文后续无特殊声明命令行全采用cmd）</p>
</li>
<li><p>绑定Git和Github账号，在cmd里输入以下命令：</p>
<pre><code> git config --global user.name “Your Name”
 git config --global user.email email@example.com
 :: 其中Your Name和email@example.com替换成上面注册时的账户名和邮箱
</code></pre>
</li>
<li><p>从官网上安装Node.js并配置相关环境变量</p>
</li>
<li><p>执行完上述步骤可以用以下命令测试是否安装成功：</p>
<pre><code> git version
 node -v
 npm -v
</code></pre>
<p> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture1.png" alt="img"></p>
</li>
</ol>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>hexo是一个基于Node.js的静态博客框架，它可以让您使用Markdown（或其他渲染引擎）编写文章，并在几秒内生成静态网页。</p>
<p>npm是Node.js 的默认程序包管理器，它可以让您从 npm 服务器下载、安装、上传和管理 Node.js 的模块或包。模块或包是一些可以重用的代码，可以实现一些特定的功能或提供一些特定的服务</p>
<p>使用npm安装Hexo，命令如下：</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<h1 id="创建博客网站"><a href="#创建博客网站" class="headerlink" title="创建博客网站"></a>创建博客网站</h1><p>所有的准备工作都做好了后，现在需要生成一个文件夹作为个人博客网站的根目录，在你希望放置个人博客文件夹的地方使用如下命令：</p>
<pre><code>hexo init myBlog
:: 其中myBlog就是你的个人博客网站根目录，可以取自己喜欢的名字
cd myBlog
npm install
</code></pre>
<p>如果上面工作都没有出错的化，现在你的个人博客已经搭建成功了，你可以在个人博客根目录下输入以下命令在本地预览效果：</p>
<pre><code>hexo s
</code></pre>
<p><img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture2.png" alt="img"></p>
<p>并且我们可以在根目录下的_config.yml里对个人博客的初始设置进行配置，例如：姓名、标题等个性化设置</p>
<h1 id="选择你喜欢的主题"><a href="#选择你喜欢的主题" class="headerlink" title="选择你喜欢的主题"></a>选择你喜欢的主题</h1><p>大家可以去<a target="_blank" rel="noopener" href="https://hexo.io/themes/">Hexo官网</a>去寻找喜欢的主题下载下来，每个主题都可以点击预览，并且可以点击查看使用说明文档</p>
<p>我使用的<a target="_blank" rel="noopener" href="https://github.com/next-theme/hexo-theme-next">Next主题</a>是较为受欢迎的一款，风格简约大气</p>
<p>下载主题有两种方法，这边只介绍使用一种，在个人博客文件根目录下使用命令：</p>
<pre><code>git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
<p>如果下载成功则根目录下会出现该文件夹 &#x2F;themes&#x2F;next</p>
<p>我们就可以在NexT文件夹里的_config.yml里对该主题的一些设定进行配置，但这种方法存在弊端，官方推荐的配置方法以及具体的操作可以查看<a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/theme-settings/custom-pages">NexT官方说明文档</a></p>
<h1 id="将个人博客部署到Github上"><a href="#将个人博客部署到Github上" class="headerlink" title="将个人博客部署到Github上"></a>将个人博客部署到Github上</h1><p>Github能且仅能使用一个同名仓库的代码托管一个静态站点.</p>
<ol>
<li><p>在Github上创建一个名为：<code>用户名.github.io</code>的仓库</p>
</li>
<li><p>使用以下命令配置SSH钥匙：</p>
<pre><code> git config --global user.name &quot;用户名&quot;
 git config --global user.email &quot;邮箱地址&quot;
 ::之前已经配置过可直接输入第三条命令 
 ssh-keygen -t rsa -C &#39;上面的邮箱&#39;
</code></pre>
<p> 可在<code>C:\Users\用户名\.ssh\id_rsa.pub</code>文件里查看SSH公钥</p>
</li>
<li><p>首次使用还须使用以下命令确认并添加主机到本机SSH可信列表：</p>
<pre><code> ssh -T git@github.com
 ::若返回 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功
</code></pre>
</li>
<li><p>登陆Github添加刚刚生成的SSH key，在下图中Key部分处放入SSH公钥内容<br> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture3.png" alt="img"></p>
</li>
<li><p>在根目录底下_config.xml文件拉到最底部添加如下配置：</p>
<pre><code> deploy :
 type: git
 repo: https://github.com/1478540/1478540.github.io.git
 # repo是你的仓库地址
 branch: master
</code></pre>
</li>
<li><p>安装一个部署插件：</p>
<pre><code> npm install hexo-deployer-git --save
</code></pre>
</li>
<li><p>生成相应的博客文件并部署：</p>
<pre><code>hexo g 
::g是generate，生成相应文件
hexo d
::d则是部署，部署完以后就可以通过Github账户域名访问个人博客了
</code></pre>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>文章发布可以通过命令<code>hexo new &#39;文章标题&#39;</code>,也可以直接在<code>/sourse/_posts</code>文件夹下创建.md文件，文件的具体的编写可以使用<a target="_blank" rel="noopener" href="https://markdown.com.cn/basic-syntax/images.html">makedown语法</a></p>
<p>本文学习于B站教程<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.880.my_history.page.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">[教程]Hexo &amp; Github搭建自己的专属博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
