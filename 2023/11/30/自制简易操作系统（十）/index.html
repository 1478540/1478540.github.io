<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="同步机制——锁当多个线程共同使用一样公共资源时，就有可能会出现竞争问题。在我们上一章节主线程、A线程和B线程都在打印字符，显存以及put_str()就是我们的公共资源。正是因为竞争问题，所以在上一章节中运行过程会出现字符串错误，并且运行到最后会报错(显存越界)。 所以我们需要实现一个锁，只有持有锁的人才能操作公共资源。我们将使用二元信号量实现锁的同步机制。 函数逻辑关系如图：  代码如下：  th">
<meta property="og:type" content="article">
<meta property="og:title" content="自制简易操作系统（十）">
<meta property="og:url" content="http://example.com/2023/11/30/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="同步机制——锁当多个线程共同使用一样公共资源时，就有可能会出现竞争问题。在我们上一章节主线程、A线程和B线程都在打印字符，显存以及put_str()就是我们的公共资源。正是因为竞争问题，所以在上一章节中运行过程会出现字符串错误，并且运行到最后会报错(显存越界)。 所以我们需要实现一个锁，只有持有锁的人才能操作公共资源。我们将使用二元信号量实现锁的同步机制。 函数逻辑关系如图：  代码如下：  th">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img1.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img2.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img3.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img4.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img5.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img6.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img7.png">
<meta property="article:published_time" content="2023-11-30T08:15:51.000Z">
<meta property="article:modified_time" content="2023-12-12T04:30:58.455Z">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img1.png">


<link rel="canonical" href="http://example.com/2023/11/30/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/11/30/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/","path":"2023/11/30/自制简易操作系统（十）/","title":"自制简易操作系统（十）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>自制简易操作系统（十） | Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sparkle's Space</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E9%94%81"><span class="nav-number">1.</span> <span class="nav-text">同步机制——锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E9%94%AE%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">编写键盘驱动程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.</span> <span class="nav-text">环形输入缓冲区</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/30/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="自制简易操作系统（十） | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自制简易操作系统（十）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-30 16:15:51" itemprop="dateCreated datePublished" datetime="2023-11-30T16:15:51+08:00">2023-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-12 12:30:58" itemprop="dateModified" datetime="2023-12-12T12:30:58+08:00">2023-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="同步机制——锁"><a href="#同步机制——锁" class="headerlink" title="同步机制——锁"></a>同步机制——锁</h1><p>当多个线程共同使用一样公共资源时，就有可能会出现竞争问题。在我们上一章节主线程、A线程和B线程都在打印字符，显存以及put_str()就是我们的公共资源。正是因为竞争问题，所以在上一章节中运行过程会出现字符串错误，并且运行到最后会报错(显存越界)。</p>
<p>所以我们需要实现一个锁，只有持有锁的人才能操作公共资源。我们将使用二元信号量实现锁的同步机制。</p>
<p>函数逻辑关系如图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img1.png" alt="img"></p>
<p>代码如下：</p>
<ul>
<li><p>thread&#x2F;thread.c(新增部分)</p>
<pre><code>  void thread_block(enum task_status stat)&#123;
      ASSERT((stat==TASK_BLOCKED)||(stat==TASK_HANGING)||(stat==TASK_WAITING));
      enum intr_status old_status=intr_disable();

      struct task_struct* cur_thread=running_thread();
      cur_thread-&gt;status=stat;
      schedule();

      intr_set_status(old_status);
  &#125;

  void thread_unblock(struct task_struct* pthread)&#123;
      enum intr_status old_status=intr_disable();

      ASSERT((pthread-&gt;status==TASK_BLOCKED)||(pthread-&gt;status==TASK_HANGING)||(pthread-&gt;status==TASK_WAITING));
      if(pthread-&gt;status!=TASK_READY)&#123;
          ASSERT(!elem_fimd(&amp;thread_ready_list,&amp;pthread-&gt;general_tag));
          if(elem_fimd(&amp;thread_ready_list,&amp;pthread-&gt;general_tag))&#123;
              PANIC(&quot;thread_unblock:blocked thread in ready_list\n&quot;);
          &#125;
          list_push(&amp;thread_ready_list,&amp;pthread-&gt;general_tag);
          pthread-&gt;status=TASK_READY;
      &#125;

      intr_set_status(old_status);
  &#125;
</code></pre>
</li>
<li><p>thread&#x2F;sync.h</p>
<pre><code>  #ifndef __THREAD_SYNC_H__
  #define __THREAD_SYNC_H__

  #include &quot;list.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;thread.h&quot;


  struct semaphore&#123;
      uint8_t value;
      struct list waiters;
  &#125;;


  struct lock&#123;
      struct task_struct* holder;
      struct semaphore semaphore;  //用二元信号量实现锁
      uint32_t holder_repeat_nr;
  &#125;;

  void sema_init(struct semaphore* psema,uint8_t value);
  void lock_init(struct lock* plock);
  void sema_down(struct semaphore* psema);
  void sema_up(struct semaphore* psema);
  void lock_acquire(struct lock* plock);
  void lock_release(struct lock* plock);

  #endif
</code></pre>
</li>
<li><p>thread&#x2F;sync.c</p>
<pre><code>  #include &quot;sync.h&quot;

  void sema_init(struct semaphore* psema,uint8_t value)&#123;

      psema-&gt;value=value;
      list_init(&amp;psema-&gt;waiters);

  &#125;

  void lock_init(struct lock* plock)&#123;
      plock-&gt;holder=NULL;
      plock-&gt;holder_repeat_nr=0;
      sema_init(&amp;plock-&gt;semaphore,1);
  &#125;


  //信号量-1操作
  void sema_down(struct semaphore* psema)&#123;
      enum intr_status old_status=intr_disable();

      while(psema-&gt;value==0)&#123;
          ASSERT(!elem_find(&amp;psema-&gt;waiters,&amp;running_thread()-&gt;general_tag));

          if(elem_find(&amp;psema-&gt;waiters,&amp;running_thread()-&gt;general_tag))&#123;
              PANIC(&quot;sema_down:thread blocked has been in waiters_list\n&quot;);
          &#125;

          list_append(&amp;psema-&gt;waiters,&amp;running_thread()-&gt;general_tag);
          thread_block(TASK_BLOCKED);
      &#125;
      psema-&gt;value--;
      ASSERT(psema-&gt;value==0);

      intr_set_status(old_status);
  &#125;

  //信号量+1操作
  void sema_up(struct semaphore* psema)&#123;
      enum intr_status old_status=intr_disable();
      
      ASSERT(psema-&gt;value==0);
      if(!list_empty(&amp;psema-&gt;waiters))&#123;
          struct task_struct* thread_blocked =elem2entry(struct task_struct, general_tag,list_pop(&amp;psema-&gt;waiters));
          thread_unblock(thread_blocked);
      &#125;
      psema-&gt;value++;
      ASSERT(psema-&gt;value==1);

      intr_set_stauts(old_status);
  &#125;

  //获取锁plock
  void lock_acquire(struct lock* plock)&#123;
      if(plock-&gt;holder!=running_thread())&#123;
          sema_down(&amp;plock-&gt;semaphore);
          plock-&gt;holder=running_thread();
          ASSERT(plock-&gt;holder_repeat_nr==0);
          plock-&gt;holder_repeat_nr=1;
      &#125;else&#123;
          plock-&gt;holder_repeat_nr++;
      &#125;
  &#125;

  //释放锁plock
  void lock_release(struct lock* plock)&#123;
      ASSERT(plock-&gt;holder==running_thread());
      if(plock-&gt;holder_repeat_nr&gt;1)&#123;
          plock-&gt;holder_repeat_nr--;
          return;
      &#125;
      ASSERT(plock-&gt;holder_repeat_nr==1);
      
      plock-&gt;holder=NULL;
      plock-&gt;holder_repeat_nr=0;
      sema_up(&amp;plock-&gt;semaphore);
  &#125;
</code></pre>
</li>
</ul>
<p>接下来我们将在控制台作为一个公共资源，在控制台上打印字符就必须获得控制台的锁，实现代码如下</p>
<ul>
<li><p>device&#x2F;console.h</p>
<pre><code>  #ifndef __DEVICE_CONSOLE_H__
  #define __DEVICE_CONSOLE_H__
  #include &quot;stdint.h&quot;

  void console_init(void);

  void console_release(void);

  void console_acquire(void);

  void console_put_char(uint8_t char_asci);

  void console_put_str(char* str);

  void console_put_int(uint32_t num);

  #endif
</code></pre>
</li>
<li><p>device&#x2F;console.c</p>
<pre><code>  #include &quot;console.h&quot;
  #include &quot;print.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;sync.h&quot;
  #include &quot;thread.h&quot;

  static struct lock console_lock;

  void console_init()&#123;
      lock_init(&amp;console_lock);
  &#125;

  void console_release()&#123;
      lock_release(&amp;console_lock);
  &#125;

  void console_acquire()&#123;
      lock_acquire(&amp;console_lock);
  &#125;

  void console_put_char(uint8_t char_asci)&#123;
      console_acquire();
      put_char(char_asci);
      console_release();
  &#125;

  void console_put_str(char* str)&#123;
      console_acquire();
      put_str(str);
      console_release();  
  &#125;

  void console_put_int(uint32_t num)&#123;
      console_acquire();
      put_int(num);
      console_release();  
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;main.c(将原本的put_str()换成console_put_str())</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;
  #include &quot;debug.h&quot;
  #include &quot;memory.h&quot;
  #include &quot;thread.h&quot;
  #include &quot;console.h&quot;

  void k_thread_a(void*);
  void k_thread_b(void*);

  int main(void) &#123;
  put_str(&quot;I am kernel\n&quot;);
  init_all();


  thread_start(&quot;k_thread_a&quot;,31,k_thread_a,&quot;argA &quot;);
  thread_start(&quot;k_thread_b&quot;,8,k_thread_b,&quot;argB &quot;);

  intr_enable();
  while(1)&#123;
      console_put_str(&quot;Main &quot;);
  &#125;;
  
  return 0;
  &#125;


  //在线程中运行的函数
  void k_thread_a(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      console_put_str(para);
  &#125;
  &#125;

  void k_thread_b(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      console_put_str(para);
  &#125;
  &#125;
</code></pre>
</li>
</ul>
<p>我们就可以正确的打印字符而不报错了。</p>
<h1 id="编写键盘驱动程序"><a href="#编写键盘驱动程序" class="headerlink" title="编写键盘驱动程序"></a>编写键盘驱动程序</h1><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img2.png" alt="img"></p>
<p>如上图所示，键盘上有芯片8048用于捕获按键的扫描码并传递给8042，8042是再主机上的键盘控制器负责CPU和键盘之间的沟通，8042会将从8048里收到的不同格式的扫描码统一成第一套键盘扫描码并向8259A发送键盘中断信号，8259A就是我们的老朋友了，用于中断管理。</p>
<p>工作流程如下：每当我们按下键盘的任一一个按键时，8048会捕获该按键的扫描码并发送给8042。8042接受扫描码后会将其翻译成第一套键盘扫描码(统一格式)，每一个按键的扫描码可能是一个字节也可能是两个字节（甚至可能是多个字节）。但8042只会一个字节一个字节的放到自己的缓冲区里并通知CPU来取数据(通过键盘中断),CPU不取走上一个数据，8042就不会放下一个数据，如此循环直到键盘按键的所有信息都被传输给了CPU</p>
<p>第一套键盘扫描码格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img3.png" alt="img"></p>
<p>8048工作内容以及寄存器如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img4.png" alt="img"></p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img5.png" alt="img"></p>
<p><strong>PS：在8048中的4个寄存器我们只需要从0x60的输出缓冲区里不断读取数据</strong></p>
<p>写下来我们要编写键盘驱动程序，键盘驱动程序的核心就是一个中断处理函数intr_keyboard_handler(void);该函数负责把从8042中取得的第一套扫描码转化成相应的ASCII码，然后用put_char()输出。</p>
<p>看上去很简单对吧，但这是在没有组合键的请看下，组合键shift、Ctrl、Capslk让一切都变得有些麻烦(当我们按下组合键时并不会输入任何字符，但是当我们同时搭配组合键和普通按键时却会改变普通按键的功能)，请直接看代码。</p>
<ul>
<li><p>kernel&#x2F;kernel.S(添加几个中断入口，支持的中断数由原本的33个变成48个)</p>
<pre><code>  VECTOR 0X20 ,ZERO					;时钟中断
  VECTOR 0X21 ,ZERO					;键盘中断
  VECTOR 0X22 ,ZERO					;级联
  VECTOR 0X23 ,ZERO					;串口2
  VECTOR 0X24 ,ZERO					;串口1
  VECTOR 0X25 ,ZERO					;并口2
  VECTOR 0X26 ,ZERO					;软盘
  VECTOR 0X27 ,ZERO					;并口1
  VECTOR 0X28 ,ZERO					;实时时钟
  VECTOR 0X29 ,ZERO					;重定向
  VECTOR 0X2A ,ZERO					;保留
  VECTOR 0x2B ,ZERO					;保留
  VECTOR 0x2C ,ZERO					;ps/2 鼠标
  VECTOR 0x2D ,ZERO					;fpu 浮点单元异常
  VECTOR 0x2E ,ZERO					;硬盘
  VECTOR 0x2F ,ZERO					;保留
</code></pre>
</li>
<li><p>device&#x2F;keyboard.c</p>
<pre><code>  #include &quot;keyboard.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;io.h&quot;
  #include &quot;global.h&quot;
  #include &quot;stdint.h&quot;

  #define KBD_BUF_PORT 0x60

  //定义部分字符控制键的转义字符（可直接用put_char处理）
  #define esc     &#39;\0x33&#39;     //八进制ASCII码转义
  #define backspace &#39;\b&#39;
  #define tab       &#39;\t&#39;
  #define enter       &#39;\r&#39;
  #define delete      &#39;\177&#39;  //八进制ASCII码转义

  //定义不可见字符为0
  #define char_invisible 0
  #define ctrl_l_char char_invisible
  #define ctrl_r_char char_invisible
  #define shift_l_char char_invisible
  #define shift_r_char char_invisible
  #define alt_l_char char_invisible
  #define alt_r_char char_invisible
  #define caps_lock_char char_invisible


  //定义控制字符的通码和断码
  #define shift_l_make 0x2a
  #define shift_r_make 0x36
  #define alt_l_make 0x38
  #define alt_r_make 0xe038
  #define alt_r_break 0xe0b8
  #define ctrl_l_make 0x1d
  #define ctrl_r_make 0xe01d
  #define ctrl_r_break 0xe09d
  #define caps_lock_make 0x3a


  bool ctrl_status = false,shift_status = false,alt_status = false,caps_lock_status = false,ext_scancode = false;


  //该二维数组的索引是扫描码，元素0代表未按下shift键时的输出字符，元素1代表按下shift键时的输出字符
  char keymap[][2] = &#123;
  /* 0x00 */	&#123;0,	0&#125;,		
  /* 0x01 */	&#123;esc,	esc&#125;,		
  /* 0x02 */	&#123;&#39;1&#39;,	&#39;!&#39;&#125;,		
  /* 0x03 */	&#123;&#39;2&#39;,	&#39;@&#39;&#125;,		
  /* 0x04 */	&#123;&#39;3&#39;,	&#39;#&#39;&#125;,		
  /* 0x05 */	&#123;&#39;4&#39;,	&#39;$&#39;&#125;,		
  /* 0x06 */	&#123;&#39;5&#39;,	&#39;%&#39;&#125;,		
  /* 0x07 */	&#123;&#39;6&#39;,	&#39;^&#39;&#125;,		
  /* 0x08 */	&#123;&#39;7&#39;,	&#39;&amp;&#39;&#125;,		
  /* 0x09 */	&#123;&#39;8&#39;,	&#39;*&#39;&#125;,		
  /* 0x0A */	&#123;&#39;9&#39;,	&#39;(&#39;&#125;,		
  /* 0x0B */	&#123;&#39;0&#39;,	&#39;)&#39;&#125;,		
  /* 0x0C */	&#123;&#39;-&#39;,	&#39;_&#39;&#125;,		
  /* 0x0D */	&#123;&#39;=&#39;,	&#39;+&#39;&#125;,		
  /* 0x0E */	&#123;backspace, backspace&#125;,	
  /* 0x0F */	&#123;tab,	tab&#125;,		
  /* 0x10 */	&#123;&#39;q&#39;,	&#39;Q&#39;&#125;,		
  /* 0x11 */	&#123;&#39;w&#39;,	&#39;W&#39;&#125;,		
  /* 0x12 */	&#123;&#39;e&#39;,	&#39;E&#39;&#125;,		
  /* 0x13 */	&#123;&#39;r&#39;,	&#39;R&#39;&#125;,		
  /* 0x14 */	&#123;&#39;t&#39;,	&#39;T&#39;&#125;,		
  /* 0x15 */	&#123;&#39;y&#39;,	&#39;Y&#39;&#125;,		
  /* 0x16 */	&#123;&#39;u&#39;,	&#39;U&#39;&#125;,		
  /* 0x17 */	&#123;&#39;i&#39;,	&#39;I&#39;&#125;,		
  /* 0x18 */	&#123;&#39;o&#39;,	&#39;O&#39;&#125;,		
  /* 0x19 */	&#123;&#39;p&#39;,	&#39;P&#39;&#125;,		
  /* 0x1A */	&#123;&#39;[&#39;,	&#39;&#123;&#39;&#125;,		
  /* 0x1B */	&#123;&#39;]&#39;,	&#39;&#125;&#39;&#125;,		
  /* 0x1C */	&#123;enter,  enter&#125;,
  /* 0x1D */	&#123;ctrl_l_char, ctrl_l_char&#125;,
  /* 0x1E */	&#123;&#39;a&#39;,	&#39;A&#39;&#125;,		
  /* 0x1F */	&#123;&#39;s&#39;,	&#39;S&#39;&#125;,		
  /* 0x20 */	&#123;&#39;d&#39;,	&#39;D&#39;&#125;,		
  /* 0x21 */	&#123;&#39;f&#39;,	&#39;F&#39;&#125;,		
  /* 0x22 */	&#123;&#39;g&#39;,	&#39;G&#39;&#125;,		
  /* 0x23 */	&#123;&#39;h&#39;,	&#39;H&#39;&#125;,		
  /* 0x24 */	&#123;&#39;j&#39;,	&#39;J&#39;&#125;,		
  /* 0x25 */	&#123;&#39;k&#39;,	&#39;K&#39;&#125;,		
  /* 0x26 */	&#123;&#39;l&#39;,	&#39;L&#39;&#125;,		
  /* 0x27 */	&#123;&#39;;&#39;,	&#39;:&#39;&#125;,		
  /* 0x28 */	&#123;&#39;\&#39;&#39;,	&#39;&quot;&#39;&#125;,		
  /* 0x29 */	&#123;&#39;`&#39;,	&#39;~&#39;&#125;,		
  /* 0x2A */	&#123;shift_l_char, shift_l_char&#125;,	
  /* 0x2B */	&#123;&#39;\\&#39;,	&#39;|&#39;&#125;,		
  /* 0x2C */	&#123;&#39;z&#39;,	&#39;Z&#39;&#125;,		
  /* 0x2D */	&#123;&#39;x&#39;,	&#39;X&#39;&#125;,		
  /* 0x2E */	&#123;&#39;c&#39;,	&#39;C&#39;&#125;,		
  /* 0x2F */	&#123;&#39;v&#39;,	&#39;V&#39;&#125;,		
  /* 0x30 */	&#123;&#39;b&#39;,	&#39;B&#39;&#125;,		
  /* 0x31 */	&#123;&#39;n&#39;,	&#39;N&#39;&#125;,		
  /* 0x32 */	&#123;&#39;m&#39;,	&#39;M&#39;&#125;,		
  /* 0x33 */	&#123;&#39;,&#39;,	&#39;&lt;&#39;&#125;,		
  /* 0x34 */	&#123;&#39;.&#39;,	&#39;&gt;&#39;&#125;,		
  /* 0x35 */	&#123;&#39;/&#39;,	&#39;?&#39;&#125;,
  /* 0x36	*/	&#123;shift_r_char, shift_r_char&#125;,	
  /* 0x37 */	&#123;&#39;*&#39;,	&#39;*&#39;&#125;,    	
  /* 0x38 */	&#123;alt_l_char, alt_l_char&#125;,
  /* 0x39 */	&#123;&#39; &#39;,	&#39; &#39;&#125;,		
  /* 0x3A */	&#123;caps_lock_char, caps_lock_char&#125;
  &#125;;


  static void intr_kerboard_handler(void)&#123;

      bool ctrl_down_last=ctrl_status;
      bool shift_down_last=shift_status;
      bool caps_lock_last=caps_lock_status;

      bool break_code;
      uint16_t scancode=inb(KBD_BUF_PORT);//必须读取缓冲区数据，否则8042不再继续响应键盘中断

      //打开拓展标志，并返回，（说明要接受的扫描码不止1字节，有两字节）
      if(scancode == 0xe0)&#123;
          ext_scancode=true;
          return;
      &#125;

      if(ext_scancode)&#123;
          scancode=(0xe000|scancode);
          ext_scancode=false;
      &#125;


      //true则代表是断码，否则是通码
      break_code=((scancode&amp;0x0080)!=0);

      if(break_code)&#123;
          uint16_t make_code=(scancode&amp;=0xff7f);

          //改变状态
          if(make_code==ctrl_l_make||make_code==ctrl_r_make)&#123;
              ctrl_status=false;
          &#125;else if(make_code == shift_l_make || make_code==shift_r_make)&#123;
              shift_status=false;
          &#125;else if(make_code == alt_l_make || make_code ==alt_r_make)&#123;
              alt_status=false;
          &#125;

          return;
      &#125;else if((scancode&gt;0x00 &amp;&amp; scancode&lt;0x3b)||(scancode == alt_r_make)||(scancode ==ctrl_r_make))&#123;
          
          //shift用于判断keymap到底是要输出元素0还是元素1
          bool shift=false;


          //区分双字符键和单子符键，capslk和shift对双字符键和单字符键作用不一样
          if((scancode &lt; 0x0e) || (scancode == 0x29) || (scancode == 0x1a) || \
          (scancode == 0x1b) || (scancode == 0x2b) || (scancode == 0x27) || \
          (scancode == 0x28) || (scancode == 0x33) || (scancode == 0x34) || \
          (scancode == 0x35))&#123;

              if(shift_down_last)&#123;
                  shift = true;
              &#125;

          &#125;else&#123;  //默认是字符键
              if(shift_down_last &amp;&amp; caps_lock_last)&#123;
                  shift = false; //效果确实是这样子的 我试了一下
              &#125;else if(shift_down_last || caps_lock_last)&#123;
                  shift = true; //其中任意一个都是大写的作用
              &#125;else&#123;
                  shift = false;
              &#125; 
          &#125;


          //忽略高8位，也就是0xe0的影响
          uint8_t index=(scancode&amp;=0x00ff);

          char cur_char = keymap[index][shift];

          if(cur_char)&#123;
              put_char(cur_char);
              return;
          &#125;

          if(scancode == ctrl_l_make || scancode == ctrl_r_make)&#123;
              ctrl_status = true;
          &#125;  	
          else if(scancode == shift_l_make || scancode == shift_r_make)&#123;
              shift_status = true;
          &#125;
          else if(scancode == alt_l_make || scancode == alt_r_make)&#123;
              alt_status = true;
          &#125;
          else if(scancode == caps_lock_make)&#123;
              caps_lock_status = !caps_lock_status;
          &#125;
          
      &#125;else&#123;
          put_str(&quot;unknown key\n&quot;);
      &#125;

  &#125;

  void keyboard_init()&#123;
      put_str(&quot;keyboard init start\n&quot;);
      register_handler(0x21,intr_kerboard_handler);
      put_str(&quot;kerboard init done\n&quot;);
  &#125;
</code></pre>
</li>
</ul>
<h1 id="环形输入缓冲区"><a href="#环形输入缓冲区" class="headerlink" title="环形输入缓冲区"></a>环形输入缓冲区</h1><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img6.png" alt="img"></p>
<p>如图是线性缓冲区的生成者与消费者示例图，生产者在前面生产，消费者在后面消费</p>
<p>我们要将线性缓冲区变成环形，如下图示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img7.png" alt="img"></p>
<p>构造环形输入缓冲区是为了实现Shell命令的键入，Shell的命令是由数个字符组成，我们可以先用键盘输入(生产者),将数个字符存在缓冲区中，再用shell一次性读入（消费者）</p>
<p>实现代码如下：</p>
<ul>
<li><p>device&#x2F;ioqueue.h</p>
<pre><code>  #ifndef __DEVICE_IOQUEUE_H__
  #define __DEVICE_IOQUEUE_H__

  #include &quot;stdint.h&quot;
  #include &quot;thread.h&quot;
  #include &quot;sync.h&quot;

  #define bufsize 64

  struct ioqueue&#123;
      struct lock lock;
      struct task_struct* producer;
      struct task_struct* consumer;
      char buf[bufsize];
      int32_t head;
      int32_t tail;
  &#125;;


  void ioqueue_init(struct ioqueue* ioq);
  char ioq_getchar(struct ioqueue* ioq);
  void ioq_putchar(struct ioqueue* ioq,char byte);
  bool ioq_empty(struct ioqueue* ioq);
  bool ioq_full(struct ioqueue* ioq);

  #endif
</code></pre>
</li>
<li><p>device&#x2F;ioqueue.c</p>
<pre><code>  #include &quot;ioqueue.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;global.h&quot;
  #include &quot;debug.h&quot;


  void ioqueue_init(struct ioqueue* ioq)&#123;
      lock_init(&amp;ioq-&gt;lock);
      ioq-&gt;producer=ioq-&gt;consumer=NULL;
      ioq-&gt;head=ioq-&gt;tail=0;
  &#125;


  static int32_t next_pos(int32_t pos)&#123;
      return (pos+1)%bufsize;
  &#125;

  bool ioq_full(struct ioqueue* ioq)&#123;
      ASSERT(intr_get_status()==INTR_OFF);
      return next_pos(ioq-&gt;head)==ioq-&gt;tail;
  &#125;

  bool ioq_empty(struct ioqueue* ioq)&#123;
      ASSERT(intr_get_status()==INTR_OFF);
      return ioq-&gt;head==ioq-&gt;tail;
  &#125;


  static void ioq_wait(struct  task_struct** waiter)&#123;
      ASSERT(*waiter==NULL &amp;&amp; waiter!=NULL);
      *waiter = running_thread();
      thread_block(TASK_BLOCKED);
  &#125;

  static void wakeup(struct task_struct** waiter)&#123;
      ASSERT(*waiter!=NULL);
      thread_unblock(*waiter);
      *waiter=NULL;
  &#125;

  char ioq_getchar(struct ioqueue* ioq)&#123;
      ASSERT(intr_get_status()==INTR_OFF);

      while(ioq_empty(ioq))&#123;
          lock_acquire(&amp;ioq-&gt;lock);
          ioq_wait(&amp;ioq-&gt;consumer);
          lock_release(&amp;ioq-&gt;lock);
      &#125;

      char byte=ioq-&gt;buf[ioq-&gt;tail];
      ioq-&gt;tail=next_pos(ioq-&gt;tail);

      if(ioq-&gt;producer!=NULL)&#123;
          wakeup(&amp;ioq-&gt;producer);
      &#125;

      return byte;
  &#125;


  void ioq_putchar(struct ioqueue* ioq,char byte)&#123;
      ASSERT(intr_get_status()==INTR_OFF);

      while(ioq_full(ioq))&#123;
          lock_acquire(&amp;ioq-&gt;lock);
          ioq_wait(&amp;ioq-&gt;producer);
          lock_release(&amp;ioq-&gt;lock);
      &#125;

      ioq-&gt;buf[ioq-&gt;head]=byte;
      ioq-&gt;head=next_pos(ioq-&gt;head);

      if(ioq-&gt;consumer!=NULL)&#123;
          wakeup(&amp;ioq-&gt;consumer);
      &#125;
  &#125;
</code></pre>
</li>
<li><p>device&#x2F;keyboard.h</p>
<pre><code>  #ifndef __KEYBOARD_H__
  #define __KEYBOARD_H__

  void keyboard_init(void);

  extern struct ioqueue kbd_buf;

  #endif
</code></pre>
</li>
<li><p>device&#x2F;keyboard.c(修改)</p>
<pre><code>  #include &quot;keyboard.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;io.h&quot;
  #include &quot;global.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;ioqueue.h&quot;

  #define KBD_BUF_PORT 0x60

  //定义部分字符控制键的转义字符（可直接用put_char处理）
  #define esc     &#39;\0x33&#39;     //八进制ASCII码转义
  #define backspace &#39;\b&#39;
  #define tab       &#39;\t&#39;
  #define enter       &#39;\r&#39;
  #define delete      &#39;\177&#39;  //八进制ASCII码转义

  //定义不可见字符为0
  #define char_invisible 0
  #define ctrl_l_char char_invisible
  #define ctrl_r_char char_invisible
  #define shift_l_char char_invisible
  #define shift_r_char char_invisible
  #define alt_l_char char_invisible
  #define alt_r_char char_invisible
  #define caps_lock_char char_invisible


  //定义控制字符的通码和断码
  #define shift_l_make 0x2a
  #define shift_r_make 0x36
  #define alt_l_make 0x38
  #define alt_r_make 0xe038
  #define alt_r_break 0xe0b8
  #define ctrl_l_make 0x1d
  #define ctrl_r_make 0xe01d
  #define ctrl_r_break 0xe09d
  #define caps_lock_make 0x3a


  bool ctrl_status = false,shift_status = false,alt_status = false,caps_lock_status = false,ext_scancode = false;


  //定义键盘缓冲区:
  struct ioqueue kbd_buf;


  //该二维数组的索引是扫描码，元素0代表未按下shift键时的输出字符，元素1代表按下shift键时的输出字符
  char keymap[][2] = &#123;
  /* 0x00 */	&#123;0,	0&#125;,		
  /* 0x01 */	&#123;esc,	esc&#125;,		
  /* 0x02 */	&#123;&#39;1&#39;,	&#39;!&#39;&#125;,		
  /* 0x03 */	&#123;&#39;2&#39;,	&#39;@&#39;&#125;,		
  /* 0x04 */	&#123;&#39;3&#39;,	&#39;#&#39;&#125;,		
  /* 0x05 */	&#123;&#39;4&#39;,	&#39;$&#39;&#125;,		
  /* 0x06 */	&#123;&#39;5&#39;,	&#39;%&#39;&#125;,		
  /* 0x07 */	&#123;&#39;6&#39;,	&#39;^&#39;&#125;,		
  /* 0x08 */	&#123;&#39;7&#39;,	&#39;&amp;&#39;&#125;,		
  /* 0x09 */	&#123;&#39;8&#39;,	&#39;*&#39;&#125;,		
  /* 0x0A */	&#123;&#39;9&#39;,	&#39;(&#39;&#125;,		
  /* 0x0B */	&#123;&#39;0&#39;,	&#39;)&#39;&#125;,		
  /* 0x0C */	&#123;&#39;-&#39;,	&#39;_&#39;&#125;,		
  /* 0x0D */	&#123;&#39;=&#39;,	&#39;+&#39;&#125;,		
  /* 0x0E */	&#123;backspace, backspace&#125;,	
  /* 0x0F */	&#123;tab,	tab&#125;,		
  /* 0x10 */	&#123;&#39;q&#39;,	&#39;Q&#39;&#125;,		
  /* 0x11 */	&#123;&#39;w&#39;,	&#39;W&#39;&#125;,		
  /* 0x12 */	&#123;&#39;e&#39;,	&#39;E&#39;&#125;,		
  /* 0x13 */	&#123;&#39;r&#39;,	&#39;R&#39;&#125;,		
  /* 0x14 */	&#123;&#39;t&#39;,	&#39;T&#39;&#125;,		
  /* 0x15 */	&#123;&#39;y&#39;,	&#39;Y&#39;&#125;,		
  /* 0x16 */	&#123;&#39;u&#39;,	&#39;U&#39;&#125;,		
  /* 0x17 */	&#123;&#39;i&#39;,	&#39;I&#39;&#125;,		
  /* 0x18 */	&#123;&#39;o&#39;,	&#39;O&#39;&#125;,		
  /* 0x19 */	&#123;&#39;p&#39;,	&#39;P&#39;&#125;,		
  /* 0x1A */	&#123;&#39;[&#39;,	&#39;&#123;&#39;&#125;,		
  /* 0x1B */	&#123;&#39;]&#39;,	&#39;&#125;&#39;&#125;,		
  /* 0x1C */	&#123;enter,  enter&#125;,
  /* 0x1D */	&#123;ctrl_l_char, ctrl_l_char&#125;,
  /* 0x1E */	&#123;&#39;a&#39;,	&#39;A&#39;&#125;,		
  /* 0x1F */	&#123;&#39;s&#39;,	&#39;S&#39;&#125;,		
  /* 0x20 */	&#123;&#39;d&#39;,	&#39;D&#39;&#125;,		
  /* 0x21 */	&#123;&#39;f&#39;,	&#39;F&#39;&#125;,		
  /* 0x22 */	&#123;&#39;g&#39;,	&#39;G&#39;&#125;,		
  /* 0x23 */	&#123;&#39;h&#39;,	&#39;H&#39;&#125;,		
  /* 0x24 */	&#123;&#39;j&#39;,	&#39;J&#39;&#125;,		
  /* 0x25 */	&#123;&#39;k&#39;,	&#39;K&#39;&#125;,		
  /* 0x26 */	&#123;&#39;l&#39;,	&#39;L&#39;&#125;,		
  /* 0x27 */	&#123;&#39;;&#39;,	&#39;:&#39;&#125;,		
  /* 0x28 */	&#123;&#39;\&#39;&#39;,	&#39;&quot;&#39;&#125;,		
  /* 0x29 */	&#123;&#39;`&#39;,	&#39;~&#39;&#125;,		
  /* 0x2A */	&#123;shift_l_char, shift_l_char&#125;,	
  /* 0x2B */	&#123;&#39;\\&#39;,	&#39;|&#39;&#125;,		
  /* 0x2C */	&#123;&#39;z&#39;,	&#39;Z&#39;&#125;,		
  /* 0x2D */	&#123;&#39;x&#39;,	&#39;X&#39;&#125;,		
  /* 0x2E */	&#123;&#39;c&#39;,	&#39;C&#39;&#125;,		
  /* 0x2F */	&#123;&#39;v&#39;,	&#39;V&#39;&#125;,		
  /* 0x30 */	&#123;&#39;b&#39;,	&#39;B&#39;&#125;,		
  /* 0x31 */	&#123;&#39;n&#39;,	&#39;N&#39;&#125;,		
  /* 0x32 */	&#123;&#39;m&#39;,	&#39;M&#39;&#125;,		
  /* 0x33 */	&#123;&#39;,&#39;,	&#39;&lt;&#39;&#125;,		
  /* 0x34 */	&#123;&#39;.&#39;,	&#39;&gt;&#39;&#125;,		
  /* 0x35 */	&#123;&#39;/&#39;,	&#39;?&#39;&#125;,
  /* 0x36	*/	&#123;shift_r_char, shift_r_char&#125;,	
  /* 0x37 */	&#123;&#39;*&#39;,	&#39;*&#39;&#125;,    	
  /* 0x38 */	&#123;alt_l_char, alt_l_char&#125;,
  /* 0x39 */	&#123;&#39; &#39;,	&#39; &#39;&#125;,		
  /* 0x3A */	&#123;caps_lock_char, caps_lock_char&#125;
  &#125;;


  static void intr_keyboard_handler(void)&#123;

      bool ctrl_down_last=ctrl_status;
      bool shift_down_last=shift_status;
      bool caps_lock_last=caps_lock_status;

      bool break_code;
      uint16_t scancode=inb(KBD_BUF_PORT);//必须读取缓冲区数据，否则8042不再继续响应键盘中断

      //打开拓展标志，并返回，（说明要接受的扫描码不止1字节，有两字节）
      if(scancode == 0xe0)&#123;
          ext_scancode=true;
          return;
      &#125;

      if(ext_scancode)&#123;
          scancode=(0xe000|scancode);
          ext_scancode=false;
      &#125;


      //true则代表是断码，否则是通码
      break_code=((scancode&amp;0x0080)!=0);

      if(break_code)&#123;
          uint16_t make_code=(scancode&amp;=0xff7f);

          //改变状态
          if(make_code==ctrl_l_make||make_code==ctrl_r_make)&#123;
              ctrl_status=false;
          &#125;else if(make_code == shift_l_make || make_code==shift_r_make)&#123;
              shift_status=false;
          &#125;else if(make_code == alt_l_make || make_code ==alt_r_make)&#123;
              alt_status=false;
          &#125;

          return;
      &#125;else if((scancode&gt;0x00 &amp;&amp; scancode&lt;0x3b)||(scancode == alt_r_make)||(scancode ==ctrl_r_make))&#123;
          
          //shift用于判断keymap到底是要输出元素0还是元素1
          bool shift=false;


          //区分双字符键和单子符键，capslk和shift对双字符键和单字符键作用不一样
          if((scancode &lt; 0x0e) || (scancode == 0x29) || (scancode == 0x1a) || \
          (scancode == 0x1b) || (scancode == 0x2b) || (scancode == 0x27) || \
          (scancode == 0x28) || (scancode == 0x33) || (scancode == 0x34) || \
          (scancode == 0x35))&#123;

              if(shift_down_last)&#123;
                  shift = true;
              &#125;

          &#125;else&#123;  //默认是字符键
              if(shift_down_last &amp;&amp; caps_lock_last)&#123;
                  shift = false; //效果确实是这样子的 我试了一下
              &#125;else if(shift_down_last || caps_lock_last)&#123;
                  shift = true; //其中任意一个都是大写的作用
              &#125;else&#123;
                  shift = false;
              &#125; 
          &#125;


          //忽略高8位，也就是0xe0的影响
          uint8_t index=(scancode&amp;=0x00ff);

          char cur_char = keymap[index][shift];

          if(cur_char)&#123;
              if(!ioq_full(&amp;kbd_buf))&#123;
  //               put_char(cur_char);
                  ioq_putchar(&amp;kbd_buf,cur_char);
              &#125;
              return;
          &#125;

          if(scancode == ctrl_l_make || scancode == ctrl_r_make)&#123;
              ctrl_status = true;
          &#125;  	
          else if(scancode == shift_l_make || scancode == shift_r_make)&#123;
              shift_status = true;
          &#125;
          else if(scancode == alt_l_make || scancode == alt_r_make)&#123;
              alt_status = true;
          &#125;
          else if(scancode == caps_lock_make)&#123;
              caps_lock_status = !caps_lock_status;
          &#125;
          
      &#125;else&#123;
          put_str(&quot;unknown key\n&quot;);
      &#125;

  &#125;

  void keyboard_init()&#123;
      put_str(&quot;keyboard init start\n&quot;);
      ioqueue_init(&amp;kbd_buf);
      register_handler(0x21,intr_keyboard_handler);
      put_str(&quot;kerboard init done\n&quot;);
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;interrupt.c（修改）</p>
<pre><code>  //打开主片上的IR0,接受时钟中断和键盘中断
  outb(PIC_M_DATA, 0xfc);
  outb(PIC_S_DATA, 0xff);
</code></pre>
</li>
</ul>
<p>（该main.c用两个线程AB充当消费者，键盘键入充当生产者）</p>
<ul>
<li><p>kernel&#x2F;main.c</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;
  #include &quot;debug.h&quot;
  #include &quot;memory.h&quot;
  #include &quot;thread.h&quot;
  #include &quot;console.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;ioqueue.h&quot;
  #include &quot;keyboard.h&quot;

  void k_thread_a(void*);
  void k_thread_b(void*);

  int main(void) &#123;
  put_str(&quot;I am kernel\n&quot;);
  init_all();


  thread_start(&quot;k_thread_a&quot;,31,k_thread_a,&quot; A_&quot;);
  thread_start(&quot;k_thread_b&quot;,31,k_thread_b,&quot; B_&quot;);

  intr_enable();
  while(1);
  // while(1)&#123;
  //    console_put_str(&quot;Main &quot;);
  // &#125;;
  return 0;
  &#125;


  //在线程中运行的函数
  void k_thread_a(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      enum intr_status old_status =intr_disable();
      if(!ioq_empty(&amp;kbd_buf))&#123;
          console_put_str(para);
          char byte=ioq_getchar(&amp;kbd_buf);
          console_put_char(byte);
      &#125;
      intr_set_status(old_status);
  &#125;
  &#125;

  void k_thread_b(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      enum intr_status old_status =intr_disable();
      if(!ioq_empty(&amp;kbd_buf))&#123;
          console_put_str(para);
          char byte=ioq_getchar(&amp;kbd_buf);
          console_put_char(byte);
      &#125;
      intr_set_status(old_status);
  &#125;
  &#125;
</code></pre>
</li>
<li><p>makefile</p>
<pre><code>  BUILD_DIR = ./build
  ENTRY_POINT = 0xc0001500
  AS = nasm
  CC = gcc
  LD = ld
  LIB = -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ -I thread/ 
  ASFLAGS = -f elf

  CFLAGS = -Wall -m32 -fno-stack-protector $(LIB) -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes
  # -fno-stack-protector 闭栈保护的编译选项，栈保护作用是禁止编译器在函数的栈帧中插入栈保护符号，以防止栈溢出攻击。
  # -fno-builtin 告诉编译器不要采用内部函数，因为我们以后会自定义与内部函数同名的函数
  # -Wall 启动所有警告
  # -W 启动常见警告
  # -Wstrict-prototypes  要求函数声明中必须有参数类型，否则警告
  # -Wmissing-prototypes 要求函数必须声明，否则警告

  LDFLAGS =  -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)/kernel.map
  # -Map $(BUILD_DIR)/kernel.map  输出文件build/kernel.map。用于记录kernel符号地址

  OBJS = $(BUILD_DIR)/main.o $(BUILD_DIR)/init.o $(BUILD_DIR)/interrupt.o \
      $(BUILD_DIR)/timer.o $(BUILD_DIR)/kernel.o $(BUILD_DIR)/print.o \
      $(BUILD_DIR)/debug.o $(BUILD_DIR)/string.o $(BUILD_DIR)/memory.o \
      $(BUILD_DIR)/bitmap.o $(BUILD_DIR)/thread.o $(BUILD_DIR)/list.o \
      $(BUILD_DIR)/switch.o $(BUILD_DIR)/sync.o $(BUILD_DIR)/console.o \
      $(BUILD_DIR)/keyboard.o $(BUILD_DIR)/ioqueue.o
  # 定义目标文件名集合，用于ld时依赖文件项


  ##############     c代码编译     			###############
  $(BUILD_DIR)/main.o: kernel/main.c lib/kernel/print.h \
          lib/stdint.h kernel/init.h lib/string.h kernel/memory.h \
          thread/thread.h kernel/interrupt.h device/console.h \
          device/keyboard.h device/ioqueue.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/init.o: kernel/init.c kernel/init.h lib/kernel/print.h \
          lib/stdint.h kernel/interrupt.h device/timer.h kernel/memory.h \
          thread/thread.h device/console.h device/keyboard.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/interrupt.o: kernel/interrupt.c kernel/interrupt.h \
          lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/timer.o: device/timer.c device/timer.h lib/kernel/io.h lib/kernel/print.h \
          kernel/interrupt.h thread/thread.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/debug.o: kernel/debug.c kernel/debug.h \
          lib/kernel/print.h lib/stdint.h kernel/interrupt.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/string.o: lib/string.c lib/string.h \
          kernel/debug.h kernel/global.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/memory.o: kernel/memory.c kernel/memory.h \
          lib/stdint.h lib/kernel/bitmap.h kernel/debug.h lib/string.h \
          lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/bitmap.o: lib/kernel/bitmap.c lib/kernel/bitmap.h \
          lib/string.h kernel/interrupt.h lib/kernel/print.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/thread.o: thread/thread.c thread/thread.h \
          lib/stdint.h lib/string.h kernel/global.h kernel/memory.h \
          kernel/debug.h kernel/interrupt.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/list.o: lib/kernel/list.c lib/kernel/list.h \
          kernel/interrupt.h lib/stdint.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/sync.o: thread/sync.c thread/sync.h \
          lib/stdint.h thread/thread.h kernel/debug.h kernel/interrupt.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/console.o: device/console.c device/console.h \
          lib/kernel/print.h thread/sync.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/keyboard.o: device/keyboard.c device/keyboard.h \
          lib/kernel/print.h lib/kernel/io.h kernel/interrupt.h \
          kernel/global.h lib/stdint.h device/ioqueue.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/ioqueue.o: device/ioqueue.c device/ioqueue.h \
          kernel/interrupt.h kernel/global.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  ##############     c代码编译     			###############


  ##############    汇编代码编译    ###############
  $(BUILD_DIR)/kernel.o: kernel/kernel.S
      $(AS) $(ASFLAGS) $&lt; -o $@

  $(BUILD_DIR)/print.o: lib/kernel/print.S
      $(AS) $(ASFLAGS) $&lt; -o $@

  $(BUILD_DIR)/switch.o: thread/switch.S
      $(AS) $(ASFLAGS) $&lt; -o $@
  ##############    汇编代码编译    ###############


  ##############    链接所有目标文件    #############
  $(BUILD_DIR)/kernel.bin: $(OBJS)
      $(LD) $(LDFLAGS) $^ -o $@
  ##############    链接所有目标文件    #############


  ################  伪目标 ###############################
  .PHONY : mk_dir hd clean build all

  mk_dir:
      if [ ! -d $(BUILD_DIR) ]; then mkdir $(BUILD_DIR); fi

  hd:
      dd if=$(BUILD_DIR)/kernel.bin \
          of=/home/sparkle2/bochs/hd60M.img \
          bs=512 count=200 seek=9 conv=notrunc

  clean:
      cd $(BUILD_DIR) &amp;&amp; rm -f  ./*

  build: $(BUILD_DIR)/kernel.bin

  all: mk_dir build hd
  ################  伪目标 ###############################
</code></pre>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/29/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/" rel="prev" title="自制简易操作系统（九）">
                  <i class="fa fa-angle-left"></i> 自制简易操作系统（九）
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
