<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这一章我们介绍中断，可以说操作系统就是依靠中断运行的 中断分类中断分类见下图：  部分中断和异常的向量号见下图：  中断描述符表中断描述符表（Interrupt Descriptor Table,IDT）里面存储的不仅只有中断描述符、还有任务门描述符和陷阱门描述符。它和GDT是并列关系。 门结构这里我们先介绍一下新的概念————门结构，门结构本质上就是段描述符，但是普通的段描述符指向一个段，而门结">
<meta property="og:type" content="article">
<meta property="og:title" content="自制简易操作系统（七）">
<meta property="og:url" content="http://example.com/2023/11/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="这一章我们介绍中断，可以说操作系统就是依靠中断运行的 中断分类中断分类见下图：  部分中断和异常的向量号见下图：  中断描述符表中断描述符表（Interrupt Descriptor Table,IDT）里面存储的不仅只有中断描述符、还有任务门描述符和陷阱门描述符。它和GDT是并列关系。 门结构这里我们先介绍一下新的概念————门结构，门结构本质上就是段描述符，但是普通的段描述符指向一个段，而门结">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img1.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img2.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img3.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img4.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img5.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img6.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img7.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img8.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img9.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img10.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img11.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img12.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img13.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img14.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img15.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img16.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img17.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img18.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img19.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img20.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img21.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img22.png">
<meta property="article:published_time" content="2023-11-24T02:08:06.000Z">
<meta property="article:modified_time" content="2023-11-25T06:36:41.166Z">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img1.png">


<link rel="canonical" href="http://example.com/2023/11/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/11/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/","path":"2023/11/24/自制简易操作系统（七）/","title":"自制简易操作系统（七）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>自制简易操作系统（七） | Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sparkle's Space</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">中断分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">中断描述符表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">门结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IDTR%E5%92%8Clidt"><span class="nav-number">2.2.</span> <span class="nav-text">IDTR和lidt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E5%8F%8A%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.3.</span> <span class="nav-text">中断处理过程及保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%8F%91%E7%94%9F%E7%9A%84%E5%8E%8B%E6%A0%88"><span class="nav-number">2.4.</span> <span class="nav-text">中断发生的压栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-number">2.5.</span> <span class="nav-text">错误码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A88259A"><span class="nav-number">3.</span> <span class="nav-text">可编程中断控制器8259A</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8259A%E7%9A%84%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">8259A的结构以及工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8259A%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">3.1.1.</span> <span class="nav-text">8259A需要处理的事情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8259A%E7%BA%A7%E8%81%94%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.2.</span> <span class="nav-text">8259A级联结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8259A%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.3.</span> <span class="nav-text">8259A内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8259A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.4.</span> <span class="nav-text">8259A工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E8%A6%81%E5%81%9A%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="nav-number">3.1.5.</span> <span class="nav-text">我们要做的工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8259A%E7%9A%84%E7%BC%96%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">8259A的编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">编写中断处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80"><span class="nav-number">4.1.</span> <span class="nav-text">当前文件布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%E6%80%9D%E8%B7%AF%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">（简易版思路）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E6%94%B9%E8%BF%9B%E7%89%88%E6%80%9D%E8%B7%AF%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">（改进版思路）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">4.4.</span> <span class="nav-text">具体代码如下：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="nav-number">4.5.</span> <span class="nav-text">调试思路：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E8%AE%A1%E6%95%B0%E5%99%A8-%E5%AE%9A%E6%97%B6%E5%99%A88253"><span class="nav-number">5.</span> <span class="nav-text">可编程计数器&#x2F;定时器8253</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8253%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">8253内部结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8253%E6%8E%A7%E5%88%B6%E5%AD%97%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%AD%97%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">8253控制字寄存器：控制字格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.3.</span> <span class="nav-text">计数器工作模式和工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E4%BF%AE%E6%94%B9%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E9%A2%91%E7%8E%87%E4%B8%BA100HZ"><span class="nav-number">5.4.</span> <span class="nav-text">编码修改时钟中断频率为100HZ</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="自制简易操作系统（七） | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自制简易操作系统（七）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-24 10:08:06" itemprop="dateCreated datePublished" datetime="2023-11-24T10:08:06+08:00">2023-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-25 14:36:41" itemprop="dateModified" datetime="2023-11-25T14:36:41+08:00">2023-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>这一章我们介绍中断，可以说操作系统就是依靠中断运行的</p>
<h1 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h1><p>中断分类见下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img1.png" alt="img"></p>
<p>部分中断和异常的向量号见下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img2.png" alt="img"></p>
<h1 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h1><p>中断描述符表（Interrupt Descriptor Table,IDT）里面存储的不仅只有中断描述符、还有任务门描述符和陷阱门描述符。它和GDT是并列关系。</p>
<h2 id="门结构"><a href="#门结构" class="headerlink" title="门结构"></a>门结构</h2><p>这里我们先介绍一下新的概念————门结构，门结构本质上就是段描述符，但是普通的段描述符指向一个段，而门结构指向一串代码（程序）。</p>
<p>一共有4种门结构，如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img3.png" alt="img"></p>
<ol>
<li><p>注意4种门结构的都属于系统段(S&#x3D;0)，并且它们的Type类型都是固定的（D&#x3D;1代表32位）。</p>
</li>
<li><p>任务门用于和TTS(Task Status Segment)搭配提供任务切换机制,任务门可存在与GDT、LDT和IDT中，任务门在现代操作系统中已经很少用了</p>
<ul>
<li><p>TTS结构简介：</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img4.png" alt="img"></p>
<p>  TTS结构的关键是多出来三个对应不同特权级的栈（不同的特权级使用不同的栈），以及上一任务指针（指向上一个任务，可以在任务嵌套中完成新任务后返回到旧任务里）</p>
</li>
</ul>
</li>
<li><p>中断门（重点关注），中段门包含了中断处理程序所在段的段选择子和段内偏移地址，中断门只允许存在IDT中。使用中断门时eflags中的IF会自动置0关闭中断，避免中断嵌套（当然只对外部中断有效）</p>
</li>
<li><p>陷阱门，陷阱门也只允许存在IDT中，一般用于调试。使用陷阱门时不会自动关闭中断</p>
</li>
<li><p>调用门，调用门用于给用户进程提升特权级，只能存在于GDT和LDT中，不会出现在IDT里</p>
</li>
</ol>
<h2 id="IDTR和lidt"><a href="#IDTR和lidt" class="headerlink" title="IDTR和lidt"></a>IDTR和lidt</h2><p>IDT地址不限制，存放在哪里都可以，但是必须把它的地方放入IDTR中。（类似GDTR）</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img5.png" alt="img"></p>
<p>IDTR里高32位存放IDT的基址，低16位存放IDT界限，也就是说IDT最大只能是2^16&#x3D;64KB，每一个描述符大小8字节，最多可以有64KB&#x2F;8B&#x3D;8192个表项（处理器只支持256个中断，所以大多数位置是空的）。</p>
<p>更新IDTR的指令如下：</p>
<pre><code>lidt 48位内存数据
</code></pre>
<h2 id="中断处理过程及保护"><a href="#中断处理过程及保护" class="headerlink" title="中断处理过程及保护"></a>中断处理过程及保护</h2><p>中断处理过程如下图所示（未涉及特权级验证）：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img6.png" alt="img"></p>
<p>中断处理过程中的保护指的就是特权级验证，每个门结构都有门栏(门结构的DPL)和门框(目标代码段的DPL)。</p>
<ul>
<li><p>对于软中断的特权级检查要求： <code>门框(目标代码段的DPL) &lt; CPL &lt;= 门栏(门结构的DPL)</code></p>
</li>
<li><p>对于外部中断和异常的特权级检查要求： <code>门框(目标代码段的DPL) &lt; CPL</code></p>
</li>
</ul>
<p>中断开启时，eflags中的NT（NT用于任务嵌套，关闭NT表示当前是在中断处理环境，避免任务嵌套）、TF（TF用于单步调试，关闭TF避免一步一中断）、IF（避免外部中断导致的中断嵌套）都是自动置0</p>
<h2 id="中断发生的压栈"><a href="#中断发生的压栈" class="headerlink" title="中断发生的压栈"></a>中断发生的压栈</h2><p>中断发生后要跳转到中断处理程序，跳转到中断处理程序就一定要经历压栈（保存当前程序地址）</p>
<p>中断压栈的第一步:判断是否发生了特权级转换，因为如果发生了特权级转换，根据TTS结构不同特权级使用不同栈，我们必须使用不同的栈而非当前的栈。</p>
<p>如果发生了特权级转换，就使用新的特权级对应的栈，压栈过程如下图(ABCD)所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img7.png" alt="img"></p>
<p>也就是依次压入：SS_old、ESP_old、EFLAGS、CS_old、EIP_old、ERROR_CODE</p>
<p>压入SS_old、ESP_old是为了中断结束返回后可以复原原本的栈，压入CS_old、EIP_old是为了中断结束返回后可以返回到原本的代码段，压入ERROR_CODE这一步骤并非是每个中断都有的(只有异常才会有)</p>
<p>中断处理程序结束后，我们调用iret(interrput return)返回，iret会依次弹出栈里3个32位数据赋值给EIP,CS,EFLAGS。这就要求我们在调用iret前必须手动操作栈顶指针跳过ERROR_CODE（有的话才跳过，没有就不用）。调用完iret后还需讲SS_old赋值给SS、ESP_old赋值给ESP，恢复旧特权级的栈。</p>
<p>如果在中断压栈的第一步判断没有发生特权级转换，那就不用那么麻烦，只需要省略上诉步骤中SS_old、ESP_old的压栈和出栈即可。</p>
<p><strong>PS：在中断返回后也会进行一次特权级检查，如果检查到特权级转换，就会将DS、ES、FS、GS的内容全部置0，以放置特权级恢复后任然可以访问高特权级资源</strong></p>
<h2 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h2><p>错误码一般只在异常发生时才会有，用来指明哪个段上发生了中断</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img8.png" alt="img"></p>
<p>选择子用来指明段，EXT表示中断源是否是外部硬件，IDT表示选择子是否是指向IDT（IDT&#x3D;1表示指向IDT，IDT&#x3D;0时表示指向GDT&#x2F;LDT），TI（只在IDT&#x3D;0时有意义）表示选择子是否指向GDT（TI&#x3D;0时指向GDT，TI&#x3D;1时指向LDT）</p>
<p>有时候中断的发生与特定的段无关，此时错误码就全为0</p>
<h1 id="可编程中断控制器8259A"><a href="#可编程中断控制器8259A" class="headerlink" title="可编程中断控制器8259A"></a>可编程中断控制器8259A</h1><p>从之前的图可以看出外部设备向CPU传入中断向量号时还需要经过一个中断代理芯片，也就是8259A。其实外部设备并不知道什么中断向量号，外部设备只在需要的时候发出中断信号，其他的琐事全部都交给8259A处理</p>
<h2 id="8259A的结构以及工作流程"><a href="#8259A的结构以及工作流程" class="headerlink" title="8259A的结构以及工作流程"></a>8259A的结构以及工作流程</h2><h3 id="8259A需要处理的事情"><a href="#8259A需要处理的事情" class="headerlink" title="8259A需要处理的事情"></a>8259A需要处理的事情</h3><ol>
<li><p>维护一个中断信号队列（CPU只给出一个引脚用于接受外部中断向量，多个外部设备同时发出中断请求时，8259A就要维护一个中断消息队列）</p>
</li>
<li><p>中断优先级裁决（多个中断请求总要有个优先级吧，由8259A判断）</p>
</li>
<li><p>构造中断向量号（外部设备并不知道中断向量号，是8259A构造中断向量号并发送给CPU）</p>
</li>
</ol>
<h3 id="8259A级联结构"><a href="#8259A级联结构" class="headerlink" title="8259A级联结构"></a>8259A级联结构</h3><p>一片8259A有8个引脚用于接受，一个引脚用于发送，也就是说只能处理8个中断。但是我们可以通过多片8259A进行级联来处理多个中断，最好的情况是用9片8259A(1片主片，8片从片)进行级联，来处理共64个中断号，级联示意图如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img9.png" alt="img"></p>
<p>但我们的个人电脑一般只采用两片8259A级联，只能处理15个中断，示意图如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img10.png" alt="img"></p>
<h3 id="8259A内部结构"><a href="#8259A内部结构" class="headerlink" title="8259A内部结构"></a>8259A内部结构</h3><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img11.png" alt="img"></p>
<p><strong>PS图中所有寄存器均是8位，也就和8259A的8个IRQ(Interrupt ReQuest)引脚一一对应。比如IRR寄存器&#x3D;0x06,代表的意思就是8259A的IRQ1和IRQ2引脚收到了中断请求</strong></p>
<ol>
<li><p>IMR（中断屏蔽寄存器）：哪个位为1，就代表屏蔽了相应引脚的中断信号</p>
</li>
<li><p>IRR（中断请求寄存器）：哪些位为1，就代表有哪些引脚接收到了中断信号，维护了一个消息队列</p>
</li>
<li><p>RP(优先权判别器)：负责从IRR里取出优先权高的中断信息送入ISR和控制电路（默认接口号越低优先权越高）</p>
</li>
<li><p>ISR（中断服务寄存器）：哪个位为1，代表当前正在执行的中断（同一时间只能执行一个中断）。处于ISR中的当前正执行中断是有可能被RP换下来的</p>
</li>
<li><p>控制电路：负责和CPU沟通，通过INT送入中断向量号(初始中断向量号+该中断的接口号)，通过INTA接受CPU的回应</p>
</li>
</ol>
<h3 id="8259A工作流程"><a href="#8259A工作流程" class="headerlink" title="8259A工作流程"></a>8259A工作流程</h3><p>完整流程如下：</p>
<p>某个外设发送中断信号，IMR先检查有没有被屏蔽，没有则送入IRR排队去。PR从IRR中选一个优先级最大并且通知控制电路，控制电路向CPU发送INTR信号（有活干了），CPU收到后回复INTA信号（我准备好了）。8259A收到信号后立即将刚刚选出来的送入ISR（当前就执行这个了）同时将它从IRR中去除（不在排队队列）。</p>
<p>过一会CPU再次发送INTA信号(给我中断向量号)，控制电路计算中断向量号(其实中断向量号+引脚接口号)通过INTR信号发给CPU。</p>
<p>CPU执行完毕后通过INTA信号发送EOI(End of Interrupt)通知,8259A收到EOI后将ISR中相应位置0(你已经执行完了)</p>
<p><strong>PS：上诉流程是8259A的手工模式。如果是自动模式，则当CPU向8259A要中断号时，ISR相应位置就置0了（直接赶人，相信CPU一定会完成的）</strong></p>
<h3 id="我们要做的工作"><a href="#我们要做的工作" class="headerlink" title="我们要做的工作"></a>我们要做的工作</h3><ol>
<li><p>构造好IDT（类似构造GDT）</p>
</li>
<li><p>提供中断向量号</p>
</li>
</ol>
<h2 id="8259A的编程"><a href="#8259A的编程" class="headerlink" title="8259A的编程"></a>8259A的编程</h2><p>8259A提供给程序员操作的寄存器一共有7个ICW1<del>4（Initialization Command Words）和OCW1</del>3（Operation Command Word）如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img12.png" alt="img"></p>
<p>ICW1~ICW4 4个寄存器结构如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img13.png" alt="img"></p>
<ol>
<li><p>ICW1</p>
<ul>
<li>IC4置1代表使用ICW4，置0则代表不使用ICW4（x86要求必须要用ICW4）</li>
<li>SNGL为1表示单片，为0代表使用级联</li>
<li>ADI 用于8085，x86不需要此位</li>
<li>LTIM 用来设置中断检查方式，为0表示边沿触发，为1表示电平触发</li>
<li>第4位是标识符，固定为1</li>
<li>5~7位 用于8085，x86不需要此位</li>
</ul>
</li>
<li><p>ICW2</p>
<p> ICW2用来设置起始中断向量号</p>
<ul>
<li>第3<del>7位由程序员填入，第0</del>2位硬件会根据引脚号自动填入（IQR0就是000，IQR1就是001）</li>
</ul>
</li>
<li><p>ICW3(主片)</p>
<p> ICW3用来表示级联方式，只有设置了级联才需要ICW3。对于ICW3寄存器主片和从片有不同的用途</p>
<ul>
<li>ICW3哪一位为1，就代表主片的哪一个引脚接入了从片</li>
</ul>
</li>
<li><p>ICW3(从片)</p>
<ul>
<li>第0~2位用来表示该从片接入的是主片的哪一个引脚。当主片发送信号时，从片通过比较该寄存器的值和信号来确定该信号是不是发送给自己的</li>
</ul>
</li>
<li><p>ICW4</p>
<p> 只有开启了IC4，ICW4才有意义</p>
<ul>
<li>7~5位未定义</li>
<li>SFNM为0表示全嵌套模式，SFNM为1表示特殊全嵌套模式</li>
<li>BUF表示芯片是否在缓冲模式，1为缓冲模式</li>
<li>M&#x2F;S只有在BUF为缓冲模式时才有意义，1表示是主片，0表示是从片</li>
<li>AEOI表示自动结束中断，AEOI&#x3D;1时表示设置自动结束中断，AEOI&#x3D;0时表示手动模式</li>
<li>uPM表示微处理器类型，uPM为1表示旧的处理器，为1表示x86系列</li>
</ul>
</li>
</ol>
<p>OCW1~OCW3 3个寄存器结构如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img14.png" alt="img"></p>
<ol>
<li><p>OCW1</p>
<ul>
<li>OCW1用来设置屏蔽中断，OCW1哪一位为1就屏蔽掉响应引脚的中断，相当于IMR&#x3D;OCW1</li>
</ul>
</li>
<li><p>OCW2</p>
<p> OCW2用来设置中断结束方式和优先级模式</p>
<ul>
<li><p>第4~3位是标识符，固定为00</p>
</li>
<li><p>SL表示是否启用L2~L0三位，这三位是配合其他模式一起使用的</p>
</li>
<li><p>R表示优先级控制方式<br>  R&#x3D;0表示固定优先级，接口号越低优先级越高。R&#x3D;1表示循环优先级，一开始的优先级是:IR0&gt;IR1&gt;IR2&gt;IR3&gt;IR4&gt;IR5&gt;IR6&gt;IR7。当执行完IR0后就变成了IR1&gt;IR2&gt;IR3&gt;IR4&gt;IR5&gt;IR6&gt;IR7&gt;IR0。当R&#x3D;1时如果SL&#x3D;0，则以L2~L0设置的接口号为最低优先级，然后依次排序下去，例如R&#x3D;1，SL&#x3D;1时L2~L0&#x3D;110，则优先级IR7&gt;IR0&gt;IR1&gt;IR2&gt;IR3&gt;IR4&gt;IR5&gt;IR6</p>
</li>
<li><p>EOI表示中断结束命令位<br>  令EOI为1，则ISR寄存器里最高优先级位清0（处理掉当前中断）。如果EOI&#x3D;1时SL&#x3D;1，则将ISR寄存器里L2~L1指定的位值0。<br>  那么EOI是由谁设置为1的？EOI是在手动结束模式里程序员主动置0的。如果是自动结束模式，则无用</p>
</li>
</ul>
</li>
<li><p>OCW3</p>
<ul>
<li>用不到！懒得看，就记得4~3位是标识符，固定为01</li>
</ul>
</li>
</ol>
<p>我们一共要操纵7个寄存器，那我们是不是需要7个端口号？其实我们对每一片8259A只用两个端口号，端口分别如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img15.png" alt="img"></p>
<p>首先主片和从片的端口号是分开的。</p>
<p>以主片为例：</p>
<p>初始化时写入奇地址0x21的连续三个数据一定依次是ICW2、ICW3、ICW4（因为它们有严格的写入顺序，且中间不能插入其他事务），初始化后写入奇地址0x21就只能是OCW1了</p>
<p>而偶地址0x20里要写入的三个寄存器则可以通过标识符分辨</p>
<h1 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h1><h2 id="当前文件布局"><a href="#当前文件布局" class="headerlink" title="当前文件布局"></a>当前文件布局</h2><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img16.png" alt="img"></p>
<h2 id="（简易版思路）"><a href="#（简易版思路）" class="headerlink" title="（简易版思路）"></a>（简易版思路）</h2><p>简易版中我们的中断程序只做了两件事：</p>
<ol>
<li><p>打印“interrupt occur”</p>
</li>
<li><p>给8259A发送EOI</p>
</li>
</ol>
<p>具体编码思路如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img17.png" alt="img"></p>
<h2 id="（改进版思路）"><a href="#（改进版思路）" class="headerlink" title="（改进版思路）"></a>（改进版思路）</h2><p>我们嫌弃简易版的中断程序太过简单，而且我们打算实现中断处理程序的注册和异常名的注册（没注册就不能使用），所以我们在原有的基础上做了改进。</p>
<p>修改了两个文件：Kernel.S  </p>
<ul>
<li><p>interrupt.c<br>  添加了idt_table[33]用于注册中断程序入口<br>  添加了intr_name[33]用于注册异常名<br>  添加了general_intr_handler()负责处理一般中断程序<br>  添加了负责 中断处理程序注册 和 异常名注册 的exception_init()</p>
</li>
<li><p>kernel.S<br>  原本的中断处理程序改为调用 idt_table[i] 里注册的中断处理程序</p>
</li>
</ul>
<p>改进部分逻辑图如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img18.png" alt="img"></p>
<p>当前情况很奇妙。interrupt.c负责初始化中断描述符表，interrupt.c负责实现一般中断处理程序。但是中断描述符表里的中断处理程序地址却是指向kernel.S。想要调用中断处理程序，就得把权力交给kernel.S，由kernel.S负责调用位于interrupt.c的一般中断处理程序。</p>
<p>为什么要这么麻烦，还要经过kernel.S的转接，我interrupt.c直接全程负责不行吗？kernel.S在这负责实现的一个功能是给33个中断例程入口相邻的地址(这应该是通过.c实现不了的)</p>
<h2 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h2><ul>
<li><p>kernel&#x2F;global.h</p>
<pre><code>  #ifndef __KERNEL_GLOBAL_H__
  #define __KERNEL_GLOBAL_H__


  #define RPL0 0
  #define RPL1 1
  #define RPL2 2
  #define RPL3 3

  #define TI_GDT 0
  #define TI_LDT 1

  //构造选择子
  #define SELECTOR_K_CODE ((1&lt;&lt;3)+(TI_GDT&lt;&lt;2)+RPL0)
  #define SELECTOR_K_DATA ((2&lt;&lt;3)+(TI_GDT&lt;&lt;2)+RPL0)
  #define SELECTOR_K_STACK SELECTOR_K_DATA
  #define SELECTOR_K_GS ((3&lt;&lt;3)+(TI_GDT&lt;&lt;2)+RPL0)

  //IDT描述符属性
  #define IDT_DSEC_P 1
  #define IDT_DSEC_DPL0 0
  #define IDT_DSEC_DPL3 3
  #define IDT_DESC_32_TYPE 0xE    //32位门
  #define IDT_DESC_16_TYPE 0x6    //16位的门，没用到

  #define IDT_DESC_ATTR_DPL0 ((IDT_DSEC_P&lt;&lt;7)+(IDT_DSEC_DPL0&lt;&lt;5)+IDT_DESC_32_TYPE)
  #define IDT_DESC_ATTR_DPL3 ((IDT_DSEC_P&lt;&lt;7)+(IDT_DSEC_DPL3&lt;&lt;5)+IDT_DESC_32_TYPE)

  #endif
</code></pre>
</li>
<li><p>lib&#x2F;kernel&#x2F;io.h</p>
<pre><code>  #ifndef __LIB_KERNEL_IO_H__
  #define __LIB_KERNEL_IO_H__

  #include&quot;stdint.h&quot;

  //向端口port写入一个字节data
  static inline void outb(uint16_t port,uint8_t data)&#123;
      asm volatile(&quot;outb %b0,%w1&quot;::&quot;a&quot;(data),&quot;Nd&quot;(port));
  &#125;

  //将addr处起始的word_cnt个字节写入端口port
  static inline void outsw(uint16_t port,const void* addr,uint32_t word_cnt)&#123;
      asm volatile(&quot;cld; rep outsw&quot;:&quot;+S&quot;(addr),&quot;+c&quot;(word_cnt):&quot;d&quot;(port));
  &#125;

  //从端口port读入一个字节返回
  static inline uint8_t inb(uint16_t port)&#123;
      uint8_t data;
      asm volatile(&quot;inb %w1,%b0&quot;:&quot;=a&quot;(data):&quot;Nd&quot;(port));
      return data;
  &#125;

  //将端口port读入的word_cnt个字节写入addr
  static inline void insw(uint16_t port,const void* addr,uint32_t word_cnt)&#123;
      asm volatile(&quot;cld; rep insw&quot;:&quot;+D&quot;(addr),&quot;+c&quot;(word_cnt):&quot;d&quot;(port):&quot;memory&quot;);
  &#125;

  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;init.h</p>
<p>  #ifndef <strong>KERNEL_INIT_H</strong><br>  #define <strong>KERNEL_INIT_H</strong></p>
<p>  void init_all();</p>
<p>  #endif</p>
</li>
<li><p>kernel&#x2F;init.c</p>
<pre><code>  #include &quot;init.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;

  void init_all()&#123;
      put_str(&quot;init_all\n&quot;);
      idt_init();
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;interrupt.h</p>
<pre><code>  #ifndef __KERNEL_INTERRUPT_H__
  #define __KERNEL_INTERRUPT_H__

  typedef void* intr_handler;

  void idt_init();

  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;interrupt.c</p>
<pre><code>  #include &quot;interrupt.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;global.h&quot;
  #include &quot;print.h&quot;
  #include &quot;io.h&quot;

  #define IDT_DESC_CNT 0x21  //定义了33个中断例程
  #define PIC_M_CTRL 0x20
  #define PIC_M_DATA 0x21
  #define PIC_S_CTRL 0xa0
  #define PIC_S_DATA 0xa1




  struct gate_desc&#123;
      uint16_t func_offset_low_word;
      uint16_t selector;
      uint8_t dcount;
      uint8_t attribute;
      uint16_t func_offset_high_word;
  &#125;;

  char* intr_name[IDT_DESC_CNT]; //用于保存异常名字
  intr_handler idt_table[IDT_DESC_CNT];//用于保存C版本的中断程序


  static struct gate_desc idt[IDT_DESC_CNT];

  extern intr_handler intr_entry_table[IDT_DESC_CNT];
  //c语言通过[bits 32]了解到该数组一个元素4字节，所以能正确定位

  //一般中断处理函数
  static void general_intr_handler(uint8_t vec_nr)&#123;
      if(vec_nr==0x27 || vec_nr == 0x2f)&#123;
          //0x27是伪中断，0x2f是保留项，不用处理
          return;
      &#125;

      put_str(&quot;int vector: 0x&quot;);
      put_int(vec_nr);
      put_char(&#39;\n&#39;);
  &#125;

  //完成一般中断处理函数的注册和异常名称的注册
  static void execption_init(void)&#123;
      int i;
      for(i=0;i&lt;IDT_DESC_CNT;i++)&#123;
          idt_table[i]=general_intr_handler;
          intr_name[i]=&quot;unknow&quot;;
      &#125;
      intr_name[0] = &quot;#DE Divide Error&quot;;
      intr_name[1] = &quot;#DB Debug Exception&quot;;
      intr_name[2] = &quot;NMI Interrupt&quot;;
      intr_name[3] = &quot;#BP Breakpoint Exception&quot;;
      intr_name[4] = &quot;#OF Overflow Exception&quot;;
      intr_name[5] = &quot;#BR BOUND Range Exceeded Exception&quot;;
      intr_name[6] = &quot;#UD Invalid Opcode Exception&quot;;
      intr_name[7] = &quot;#NM Device Not Available Exception&quot;;
      intr_name[8] = &quot;#DF Double Fault Exception&quot;;
      intr_name[9] = &quot;Coprocessor Segment Overrun&quot;;
      intr_name[10] = &quot;#TS Invalid TSS Exception&quot;;
      intr_name[11] = &quot;#NP Segment Not Present&quot;;
      intr_name[12] = &quot;#SS Stack Fault Exception&quot;;
      intr_name[13] = &quot;#GP General Protection Exception&quot;;
      intr_name[14] = &quot;#PF Page-Fault Exception&quot;;
      // intr_name[15] 第15项是intel保留项，未使用
      intr_name[16] = &quot;#MF x87 FPU Floating-Point Error&quot;;
      intr_name[17] = &quot;#AC Alignment Check Exception&quot;;
      intr_name[18] = &quot;#MC Machine-Check Exception&quot;;
      intr_name[19] = &quot;#XF SIMD Floating-Point Exception&quot;;
  &#125;



  static void pic_init(void)&#123;
      //初始化主片
      outb(PIC_M_CTRL,0x11);
      outb(PIC_M_DATA,0x20);
      outb(PIC_M_DATA,0x04);
      outb(PIC_M_DATA,0x01);

      //初始化从片
      outb(PIC_S_CTRL,0x11);
      outb(PIC_S_DATA,0x28);
      outb(PIC_S_DATA,0x02);
      outb(PIC_S_DATA,0x01);

      //打开主片上的IR0,直接受时钟中断
      outb(PIC_M_DATA, 0xfe);
      outb(PIC_S_DATA, 0xff);

      put_str(&quot;    pic_init done\n&quot;);
  &#125;

  static void make_idt_desc(struct gate_desc* p_gdesc,uint8_t attr,intr_handler function)&#123;
      p_gdesc-&gt;func_offset_low_word=(uint32_t)function &amp; 0x0000ffff;
      p_gdesc-&gt;selector=SELECTOR_K_CODE;
      p_gdesc-&gt;dcount=0;
      p_gdesc-&gt;attribute=attr;
      p_gdesc-&gt;func_offset_high_word=((uint32_t)function &amp; 0xffff0000)&gt;&gt;16;
  &#125;

  static void idt_desc_init(void)&#123;
      int i;
      for(i=0;i&lt;IDT_DESC_CNT;i++)&#123;
          make_idt_desc(&amp;idt[i],IDT_DESC_ATTR_DPL0,intr_entry_table[i]);
      &#125;
      put_str(&quot;  ide_desc_init done\n&quot;);
  &#125;


  static void load_idt(uint64_t idt_operand)&#123;
      asm volatile(&quot;lidt %0&quot;::&quot;m&quot;(idt_operand));
      put_str(&quot;idt_init done\n&quot;);
  &#125;



  void idt_init()&#123;
      put_str(&quot;idt_init start\n&quot;);

      idt_desc_init();
      execption_init(); //完成一般中断处理函数的注册和异常名称的注册
      pic_init();


      uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt &lt;&lt; 16));
      load_idt(idt_operand);
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;kernel.S</p>
<pre><code>  [bits 32]

  %define ERROR_CODE nop    ;对于压入错误码的异常不执行任何操纵
  %define ZERO push 0       ;没有压入错误码的中断push 0保证宏定义一致性

  extern put_str 
  extern idt_table

  section .data
  global intr_entry_table
  intr_entry_table:


  ;使用多行宏定义去构造33个中断例程
  ;多行宏定义可以带参数，在宏定义内部用%1,%2依次引用
  %macro VECTOR 2 
  section .text
  intr%1entry:

      %2
      
      ;上下文保护
      push ds
      push es
      push fs
      push gs
      pushad   ;储存8个通用寄存器
      
      ;向主片和从片发送EOI
      mov al,0x20
      out 0xa0,al
      out 0x20,al
      
      push %1   ;压入中断号，调用C的中断处理函数
      call [idt_table + %1*4] 

      jmp intr_exit
  section .data
      dd intr%1entry  
      
  %endmacro

  section .text
  intr_exit:
  ;恢复上下文环境
      add esp,4  ;处理栈中的中断号的参数
      popad
      pop gs
      pop fs
      pop es
      pop ds
      add esp,4
      iretd      ;弹出四字节的EIP和四字节的CS

  VECTOR 0x0 ,ZERO
  VECTOR 0X1 ,ZERO
  VECTOR 0X2 ,ZERO
  VECTOR 0x3 ,ZERO
  VECTOR 0X4 ,ZERO
  VECTOR 0X5 ,ZERO
  VECTOR 0x6 ,ZERO
  VECTOR 0X7 ,ZERO
  VECTOR 0X8 ,ERROR_CODE
  VECTOR 0x9 ,ZERO
  VECTOR 0XA ,ERROR_CODE
  VECTOR 0XB ,ERROR_CODE
  VECTOR 0XC ,ERROR_CODE
  VECTOR 0XD ,ERROR_CODE
  VECTOR 0XE ,ERROR_CODE
  VECTOR 0XF ,ZERO
  VECTOR 0X10 ,ZERO
  VECTOR 0X11 ,ERROR_CODE
  VECTOR 0x12 ,ZERO
  VECTOR 0X13 ,ZERO
  VECTOR 0X14 ,ZERO
  VECTOR 0x15 ,ZERO
  VECTOR 0X16 ,ZERO
  VECTOR 0X17 ,ZERO
  VECTOR 0X18 ,ZERO
  VECTOR 0X19 ,ZERO
  VECTOR 0X1A ,ZERO
  VECTOR 0X1B ,ZERO
  VECTOR 0X1C ,ZERO
  VECTOR 0X1D ,ZERO
  VECTOR 0X1E ,ERROR_CODE                               ;处理器自动推错误码
  VECTOR 0X1F ,ZERO
  VECTOR 0X20 ,ZERO
</code></pre>
</li>
<li><p>kernel&#x2F;main.c</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;

  void main(void)&#123;
      put_str(&quot;I am kernel\n&quot;);
      init_all();
      asm volatile (&quot;sti&quot;); //sti作用是IF=1，即打开中断
      while(1);
  &#125;
</code></pre>
</li>
<li><p>shortcut</p>
<pre><code>  #第七章常用Linux命令

  gcc -m32 -I lib/kernel/ -I kernel/ -c -fno-builtin -o build/main.o kernel/main.c
  #-fno-builtin 作用是禁止编译器将一些内置函数,替换为更高效的指令。

  nasm -f elf -o build/print.o lib/kernel/print.S

  nasm -f elf -o build/kernel.o kernel/kernel.S

  gcc -m32 -I lib/kernel/ -I lib/ -I kernel/ -c -fno-builtin -o build/interrupt.o kernel/interrupt.c

  gcc -m32 -I lib/kernel/ -I lib/ -I kernel/ -c -fno-builtin -o build/init.o kernel/init.c

  ld -m elf_i386 -Ttext 0xc0001500 -e main -o build/kernel.bin build/main.o build/init.o build/interrupt.o build/print.o build/kernel.o

  dd if=/home/sparkle2/codeset/build/kernel.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=200 seek=9 conv=notrunc
</code></pre>
</li>
</ul>
<h2 id="调试思路："><a href="#调试思路：" class="headerlink" title="调试思路："></a>调试思路：</h2><p>本章调试难点是我们不知道中断啥时候会发生，导致无法调试。解决方法如下：</p>
<p>我们在bochs调试时可以用<code>show int</code>打开中断信息打印，它将会打印出中断发生时的信息(包括执行了n条指令后遇到该中断)，得到<code>n</code>就是我们调试的关键。我们可以使用<code>sba n-1</code>指令，让系统执行总共n-1条指令后停止。接下来再用<code>s</code>单步调试，就可以实现准确定位到中断发生地点。<strong>PS：可以用<code>r</code>查看寄存器，也可以用<code>print-stack</code>查看栈</strong></p>
<h1 id="可编程计数器-定时器8253"><a href="#可编程计数器-定时器8253" class="headerlink" title="可编程计数器&#x2F;定时器8253"></a>可编程计数器&#x2F;定时器8253</h1><p>通过定时器8253可以控制时钟中断的频率</p>
<h2 id="8253内部结构"><a href="#8253内部结构" class="headerlink" title="8253内部结构"></a>8253内部结构</h2><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img19.png" alt="img"></p>
<ol>
<li><p>8253内部有三个计数器，三个计数器独立工作。</p>
</li>
<li><p>连接计数器的三个引脚：CLK输入时钟脉冲、GATE用于控制是否工作、OUT用于输出信号</p>
</li>
<li><p>控制字寄存器(8位)用于设置计时器的工作模式</p>
</li>
<li><p>计时器内部有三个16位寄存器</p>
<ul>
<li><p>计数初值寄存器：8253采用倒计时，该寄存器用于存放初始值（不会因为倒计时而改变）</p>
</li>
<li><p>减法计数器：8253的核心部件，从计数初值寄存器里取出初值后每一个时钟脉冲就自减1，为0时向OUT引脚发出计时结束信号。然后再从计数初值寄存器里取值进行新一轮计数</p>
</li>
<li><p>输出锁存器：当你想要查看当前计数时，减法计数器可不会停下来给你看，但是输出锁存器可以帮你完成任务</p>
</li>
</ul>
</li>
</ol>
<p>三个计数器的功能和端口如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img20.png" alt="img"></p>
<p>我们的目标是控制时钟中断频率，所以我们只需要修改计时器0即可</p>
<h2 id="8253控制字寄存器：控制字格式"><a href="#8253控制字寄存器：控制字格式" class="headerlink" title="8253控制字寄存器：控制字格式"></a>8253控制字寄存器：控制字格式</h2><p>8253一个控制字寄存器(端口0x43)用来控制三个计数器，控制字格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img21.png" alt="img"></p>
<h2 id="计数器工作模式和工作原理"><a href="#计数器工作模式和工作原理" class="headerlink" title="计数器工作模式和工作原理"></a>计数器工作模式和工作原理</h2><p>计数器六种工作模式总结：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%83%EF%BC%89/img22.png" alt="img"></p>
<p>计数器启动必须满足两个条件：(1)GATE为高电平，这是硬件控制，(2)计数值初值已写入减法计数器，这是软件控制。我们把满足条件1等待条件2的称为软件启动；满足条件2等待条件1的称为硬件启动。</p>
<p>在这六种工作模式中，我们要用到的只用工作模式2，下面仔细讲解利用工作模式2实现控制时钟中断的原理：</p>
<p>计时器的工作频率固定是1.19318MHz，也就是说1秒钟计时器会减119318次1。计时器的初值寄存器默认为0（即2^16&#x3D;65536）,每计数65536就会引发一次OUT输出(计时器0的OUT输出对应引发时钟中断)。那么时钟中断的默认频率就应该是119318&#x2F;65536&#x3D;18.206HZ。</p>
<p>我们的目标是修改时钟中断的频率，可得公式<code>时钟中断频率=119318/计时器的初值寄存器的值</code></p>
<h2 id="编码修改时钟中断频率为100HZ"><a href="#编码修改时钟中断频率为100HZ" class="headerlink" title="编码修改时钟中断频率为100HZ"></a>编码修改时钟中断频率为100HZ</h2><ol>
<li><p>往控制寄存器端口0x43中写入控制字</p>
</li>
<li><p>往计时器0端口0x40写入计数初值</p>
</li>
</ol>
<p>代码如下：</p>
<p>新增加device目录专门用来存储设备相关代码</p>
<ul>
<li><p>device&#x2F;timer.c</p>
<pre><code>  #include &quot;timer.h&quot;
  #include &quot;io.h&quot;
  #include &quot;print.h&quot;

  #define IRQ0_FREQUENCY          100
  #define INPUT_FREQUENCY         1193180
  #define COUNTER0_VALUE          INPUT_FREQUENCY/IRQ0_FREQUENCY

  #define COUNTER0_PORT           0x40
  #define COUNTER0_SELECTOR       0
  #define COUNTER0_MODE           2
  #define READ_WRITE_LATCH        3
  #define PIT_CONTROL_PORT        0x43


  static void frequency_set(uint8_t counter_port,uint8_t counter_selector,uint8_t rwl,uint8_t counter_mode,uint16_t counter_value)&#123;

      //写入控制字
      outb(PIT_CONTROL_PORT,(uint8_t)((counter_selector&lt;&lt;6)|(rwl&lt;&lt;4)|(counter_mode&lt;&lt;1)));

      //写入计数器初值寄存器
      outb(counter_port,(uint8_t)counter_value);
      outb(counter_port,(uint8_t)(counter_value&gt;&gt;8));
  &#125;


  void timer_init()&#123;
      put_str(&quot;timer_init start\n&quot;);
      frequency_set(COUNTER0_PORT,COUNTER0_SELECTOR,READ_WRITE_LATCH,COUNTER0_MODE,COUNTER0_VALUE);
      put_str(&quot;timer_init done\n&quot;);
  &#125;
</code></pre>
</li>
<li><p>device&#x2F;timer.h</p>
<pre><code>  #ifndef __DEVICE_TIMER_H__
  #define __DEVICE_TIMER_H__

  void timer_init();

  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;init.c</p>
<pre><code>  #include &quot;init.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;timer.h&quot;

  void init_all()&#123;
      put_str(&quot;init_all\n&quot;);
      idt_init();
      timer_init();
  &#125;
</code></pre>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/21/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89/" rel="prev" title="自制简易操作系统（六）">
                  <i class="fa fa-angle-left"></i> 自制简易操作系统（六）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/11/25/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/" rel="next" title="自制简易操作系统（八）">
                  自制简易操作系统（八） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
