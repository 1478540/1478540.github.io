<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="整体设计方案 如图电脑的启动后接力棒的第一棒从BIOS开始，第二棒MBR负责把硬盘上的loader加载到内存里，第三棒loader处理完5个子功能后把接力棒正式交给内核。 我们在本模块所做的事，就是构建具备上述功能的MBR以及loader。 在了解MBR和loader的设计之前请先了解实模式下低端物理内存1MB的布局 MBR设计MBR只需要负责加载loader到相应位置即可 MBR的程序代码分为三">
<meta property="og:type" content="article">
<meta property="og:title" content="SimpleOS-Boot引导">
<meta property="og:url" content="http://example.com/2023/12/30/SimpleOS-Boot%E5%BC%95%E5%AF%BC/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="整体设计方案 如图电脑的启动后接力棒的第一棒从BIOS开始，第二棒MBR负责把硬盘上的loader加载到内存里，第三棒loader处理完5个子功能后把接力棒正式交给内核。 我们在本模块所做的事，就是构建具备上述功能的MBR以及loader。 在了解MBR和loader的设计之前请先了解实模式下低端物理内存1MB的布局 MBR设计MBR只需要负责加载loader到相应位置即可 MBR的程序代码分为三">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img4.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img22.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img11.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img46.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img2.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img3.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img18.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img19.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img20.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img21.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img12.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img13.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img14.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img15.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img16.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img17.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img23.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img24.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img25.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img26.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img27.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img28.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img29.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img30.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img31.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img32.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img33.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img34.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img35.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img36.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img37.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img38.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img39.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img40.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img41.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img42.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img43.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img44.png">
<meta property="og:image" content="http://example.com/img/SimpleOS-2-Boot/img45.png">
<meta property="article:published_time" content="2023-12-30T07:45:05.000Z">
<meta property="article:modified_time" content="2024-10-10T11:12:46.937Z">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/SimpleOS-2-Boot/img4.png">


<link rel="canonical" href="http://example.com/2023/12/30/SimpleOS-Boot%E5%BC%95%E5%AF%BC/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/12/30/SimpleOS-Boot%E5%BC%95%E5%AF%BC/","path":"2023/12/30/SimpleOS-Boot引导/","title":"SimpleOS-Boot引导"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SimpleOS-Boot引导 | Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sparkle's Space</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="nav-number">1.</span> <span class="nav-text">整体设计方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MBR%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.1.</span> <span class="nav-text">MBR设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#loader%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.</span> <span class="nav-text">loader设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">函数表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">4.</span> <span class="nav-text">关键函数说明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86-%E5%B7%A5%E5%85%B7%E5%9B%BE%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">背景知识&#x2F;工具图表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%8E%E7%AB%AF%E7%89%A9%E7%90%86%E5%86%85%E5%AD%981MB%E5%B8%83%E5%B1%80"><span class="nav-number">5.1.</span> <span class="nav-text">实模式下低端物理内存1MB布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LBA28%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">5.2.</span> <span class="nav-text">LBA28相关知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%86%99%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">5.3.</span> <span class="nav-text">磁盘写入相关知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E5%B9%B6%E8%A1%8C%E6%8E%A5%E5%8F%A3-PATA"><span class="nav-number">5.3.1.</span> <span class="nav-text">硬盘并行接口-PATA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.2.</span> <span class="nav-text">硬盘操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%BB%E8%A6%81%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">5.3.3.</span> <span class="nav-text">硬盘控制器主要的端口寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E7%AB%AF%E5%8F%A3%E4%BA%A4%E4%BA%92%E7%9A%84in-out%E6%8C%87%E4%BB%A4"><span class="nav-number">5.3.4.</span> <span class="nav-text">与端口交互的in&#x2F;out指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98%E6%93%8D%E4%BD%9C%E7%BA%A6%E5%AE%9A%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.3.5.</span> <span class="nav-text">硬盘操作约定顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">5.4.</span> <span class="nav-text">保护模式概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">5.4.1.</span> <span class="nav-text">为什么要有保护模式(实模式的缺点)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">5.4.2.</span> <span class="nav-text">保护模式的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">5.4.3.</span> <span class="nav-text">保护模式的扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.</span> <span class="nav-text">从实模式到保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">5.5.1.</span> <span class="nav-text">段描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8F%B7GDT%E3%80%81%E9%80%89%E6%8B%A9%E5%AD%90%E4%BB%A5%E5%8F%8AGDTR%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">5.5.2.</span> <span class="nav-text">全局描述符号GDT、选择子以及GDTR寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80A20%E5%9C%B0%E5%9D%80%E7%BA%BF"><span class="nav-number">5.5.3.</span> <span class="nav-text">打开A20地址线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%80%E5%85%B3-CRO%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84PE%E4%BD%8D"><span class="nav-number">5.5.4.</span> <span class="nav-text">保护模式的开关,CRO寄存器的PE位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BF%9C%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%9D%A5%E6%B8%85%E7%A9%BA%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">5.5.5.</span> <span class="nav-text">为什么使用远跳转指令来清空流水线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">5.6.</span> <span class="nav-text">分页机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="nav-number">5.6.1.</span> <span class="nav-text">为什么要分页？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">5.6.2.</span> <span class="nav-text">一级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">5.6.3.</span> <span class="nav-text">二级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E9%A1%B9%E3%80%81%E9%A1%B5%E8%A1%A8%E9%A1%B9%E4%BB%A5%E5%8F%8ACR3%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.6.4.</span> <span class="nav-text">页目录项、页表项以及CR3格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">5.6.5.</span> <span class="nav-text">启用分页机制的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%87%AA%E4%B8%BE%E7%9A%84%E5%88%86%E9%A1%B5%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">5.6.6.</span> <span class="nav-text">什么是可以自举的分页模型？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.7.</span> <span class="nav-text">加载内核并初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">5.7.1.</span> <span class="nav-text">加载内核并初始化的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">5.7.2.</span> <span class="nav-text">内核文件的内存布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.8.</span> <span class="nav-text">elf文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#elf%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80"><span class="nav-number">5.8.1.</span> <span class="nav-text">elf文件布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#elf-header%E7%BB%93%E6%9E%84"><span class="nav-number">5.8.2.</span> <span class="nav-text">elf header结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#program-table-header%E7%BB%93%E6%9E%84"><span class="nav-number">5.8.3.</span> <span class="nav-text">program table header结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">6.</span> <span class="nav-text">完整源代码</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/30/SimpleOS-Boot%E5%BC%95%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="SimpleOS-Boot引导 | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SimpleOS-Boot引导
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-30 15:45:05" itemprop="dateCreated datePublished" datetime="2023-12-30T15:45:05+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-10-10 19:12:46" itemprop="dateModified" datetime="2024-10-10T19:12:46+08:00">2024-10-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="整体设计方案"><a href="#整体设计方案" class="headerlink" title="整体设计方案"></a>整体设计方案</h1><p><img src="/img/SimpleOS-2-Boot/img4.png" alt="img"></p>
<p>如图电脑的启动后接力棒的第一棒从BIOS开始，第二棒MBR负责把硬盘上的loader加载到内存里，第三棒loader处理完5个子功能后把接力棒正式交给内核。</p>
<p>我们在本模块所做的事，就是构建具备上述功能的MBR以及loader。</p>
<p>在了解MBR和loader的设计之前请先了解<a href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%8E%E7%AB%AF%E7%89%A9%E7%90%86%E5%86%85%E5%AD%981MB%E5%B8%83%E5%B1%80">实模式下低端物理内存1MB的布局</a></p>
<h2 id="MBR设计"><a href="#MBR设计" class="headerlink" title="MBR设计"></a>MBR设计</h2><p>MBR只需要负责加载loader到相应位置即可</p>
<p>MBR的程序代码分为三个部分：</p>
<ol>
<li><p>寄存器初始化（包括栈顶指针初始化）</p>
</li>
<li><p>调用函数loader_ready_proc()（寄存器传参）</p>
<p> PS：请先了解<a href="#lba28%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">LBA28相关知识</a></p>
</li>
<li><p>loader_ready_proc()的具体实现（功能是装载loader,也就是把loader写入磁盘相应位置）</p>
<p> PS：请先了解<a href="#%E7%A3%81%E7%9B%98%E5%86%99%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">磁盘写入相关知识</a></p>
</li>
<li><p>保证MBR一共512字节，并最后两字节必须是0x55和0xaa，使得BIOS能够检测并识别</p>
</li>
</ol>
<h2 id="loader设计"><a href="#loader设计" class="headerlink" title="loader设计"></a>loader设计</h2><p>loader要负责做的事情可多了，大致可分为六个部分</p>
<ol>
<li><p>数据段</p>
<p> loader程序的数据段里存放着GDT等重要数据结构，安排如下图所示</p>
<p> <img src="/img/SimpleOS-2-Boot/img22.png" alt="img"></p>
</li>
<li><p>计算内存大小并存储到0xb00（也就是total_men_bytes标号处）</p>
<p> 我们模仿Linux获取内存的方法，调用BIOS中断0x15的三个子功能（0xe820、0xe801、0x88）去获取内存（一种失败了就接着使用另外一种，直到成功）</p>
<p> 0xb00则是我们安排在loader.S数据段的一个固定位置,当然如果你喜欢也可以存放在其他位置。</p>
<p> 注意：我们使用BIOS中断0x15时，该中断会以ARDS数据结构（描述内存段大小的信息）的形式，返回数个ARDS，所以我们需要在loader.S中划分一块缓冲区用于临时存放返回的ARDS</p>
</li>
<li><p>从实模式切换到保护模式</p>
<p> PS：请先了解<a href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">保护模式相关知识点</a>,以及<a href="#%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F">如何从实模式进入保护模式</a></p>
</li>
<li><p>构建内核页表页目录，开启分页机制</p>
<p> PS：请先了解<a href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6">分页机制</a></p>
<p> 我们所要建立的满足可以自举证的分页模型如下图所示</p>
<p> <img src="/img/SimpleOS-2-Boot/img11.png" alt="img"></p>
<ol>
<li><p>物理空间中低端1MB用于存放内核代码，紧接着0x100000~0x200000这1MB空间用于存放255个页表+1个页目录，每个页表&#x2F;页目录都刚好是一个4KB自然页大小，每个页表项&#x2F;页目录项则占4字节大小</p>
</li>
<li><p>虚拟空间<code>0x00~0x100000</code>和<code>0xc0000000~0xc0100000</code>两个区间都被映射到物理空间的低端1MB内核代码区间</p>
</li>
<li><p>PD[1023]指向页目录本身，为的是实现在开启分页机制后还能正确访问页表和页目录</p>
<p> 如果虚地址高10位全为1、虚地址中10位全为0，就把PD[0]当成自己的页表项，最终指向物理页地址0x101000<br> 如果虚地址高10位全为1、虚地址中10位全为1，就把PD[1023]当成自己的页表项,最终指向物理页地址0x100000<br> 如果虚地址高10位全为1、虚地址中10位处于一定范围内，就把PD[768]~PD[1022]当成自己的页表项目，最终指向物理地址0x101000及以上空间</p>
<p> 总结出不变的规律：</p>
<ul>
<li>要获取页目录表物理地址：让虚位高20位地址全为1，低12位全为0，即0xfffff000。这就是页目录自身的起始物理地址</li>
<li>要访问页目录中的页目录项，即获取页表物理地址：使虚拟地址为0xfffffxxx,其中xxx是页目录项的索引*4</li>
<li>访问页表中的页表项:虚拟地址公式为 0x3ff&lt;&lt;22+中间10位&lt;&lt;12+低12位（中间10位是页表的索引，低12位为页表内的偏移地址）</li>
</ul>
</li>
</ol>
</li>
<li><p>加载kernel到内存中</p>
<p> 将硬盘从0x9开始占据200扇区的kernel代码读取到内存0x70000起始处</p>
</li>
<li><p>初始化kernel</p>
<p> PS：请先了解<a href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96">加载并初始化内核相关知识</a>以及<a href="#elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">elf文件格式</a></p>
</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>无</p>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><ul>
<li><p>boot&#x2F;mbr.S</p>
<pre><code>  /*
  @brief: 该函数负责把磁盘上的loader装载到内存里(汇编函数/寄存器传参)
  @param: loader_start_sector是loader的LBA28扇区地址
          loader_base_addr是内存起始地址
          sector_cnt是移动的扇区数目
  @retval:无
  */
  void loader_ready_proc(loader_start_sector,loader_base_addr,sector_cnt);
</code></pre>
</li>
<li><p>boot&#x2F;loader.S</p>
<pre><code>  /*
  @brief: 该函数负责5件事分布如下：(汇编函数)
          1. 计算内存并存储到0xb00
          2. 从实模式到保护模式
          3. 构建内核页表页目录，开启分页机制
          4. 加载kernel到内核中
          5. 初始化kernel
  @param: 无
  @retval:无
  */
  void loader_start();
</code></pre>
</li>
</ul>
<h1 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a>关键函数说明</h1><p>无</p>
<h1 id="背景知识-工具图表"><a href="#背景知识-工具图表" class="headerlink" title="背景知识&#x2F;工具图表"></a>背景知识&#x2F;工具图表</h1><h2 id="实模式下低端物理内存1MB布局"><a href="#实模式下低端物理内存1MB布局" class="headerlink" title="实模式下低端物理内存1MB布局"></a>实模式下低端物理内存1MB布局</h2><p><img src="/img/SimpleOS-2-Boot/img46.png" alt="img"></p>
<ol>
<li><p>我们整个SimpleOS的代码实际上只会装载到<code>0x500~0x9FBFF</code>这块内存区间（包括两块空闲的可用区域，和一块由BIOS确定的MBR区域）</p>
</li>
<li><p>512字节的MBR将会被BIOS强制装载到<code>0x7C00~0x7DFF</code>，（MBR只负责加载loader，运行过一次就没用了，之后可以被其他代码覆盖）</p>
</li>
<li><p>2048字节的loader规划在可用区间<code>0x900~0x1100</code>（loader是内核的起点，安排在离0x500近一点的地方，为之后的内核文件腾出足够的空间。至于和0x500之间存在的一点间隔存储个人决策，可以忽略）</p>
</li>
<li><p>200扇区kernel.bin，将其装载在<code>0x70000~0x89000</code>可用区域,（内核代码应该装载在可用空间的尽可能高位，为内核映像文件腾出位置）</p>
</li>
<li><p>保护模式下一些虚地址分配</p>
<ul>
<li><p>0xc0001500(虚地址)作为内核代码的入口</p>
</li>
<li><p>一般来说可用空间的上界限0xc009fc00是最好的栈顶，但是为了让内存的每一块都形成4KB的自然页，所以栈顶最好取4KB的整数倍，因此栈顶设置为<code>0xc009f000</code></p>
</li>
<li><p><code>0xc009e000~0xc009f000</code>4KB空间分配给内核主线程PCB</p>
</li>
<li><p><code>0xc009a000~0xc009e000</code>这四个页的空间(可管理一共512MB空间)大小全给位图(物理内核内存池位图、物理用户内存池位图、虚拟内核内存池位图)</p>
</li>
</ul>
</li>
</ol>
<h2 id="LBA28相关知识"><a href="#LBA28相关知识" class="headerlink" title="LBA28相关知识"></a>LBA28相关知识</h2><p>LBA28是用28位比特来描述一个扇区的地址的一种方式</p>
<p>其中前24位分别写在3个8位寄存器LBAlow、LBAmid、LBAhigh，最后4位写在device寄存器里</p>
<h2 id="磁盘写入相关知识"><a href="#磁盘写入相关知识" class="headerlink" title="磁盘写入相关知识"></a>磁盘写入相关知识</h2><h3 id="硬盘并行接口-PATA"><a href="#硬盘并行接口-PATA" class="headerlink" title="硬盘并行接口-PATA"></a>硬盘并行接口-PATA</h3><p>PATA接口的线缆也称IDE线</p>
<p>一个主盘提供了两个IDE插槽，这两个插槽称为两个通道，IDE0叫Primary通道，IDE1叫Secondary通道</p>
<p>每一个IDE线都可以挂载两块硬盘，一个主盘(master),一个从盘(slave)</p>
<h3 id="硬盘操作方法"><a href="#硬盘操作方法" class="headerlink" title="硬盘操作方法"></a>硬盘操作方法</h3><p>当我们要读取硬盘时，我们要先在控制寄存器里写入 读取命令字，然后才能从相关寄存器里读取到所需要的数据</p>
<p>而当我们需要写入硬盘时，我们要先在相关寄存器里写入数据，然后再向控制寄存器里写入 写入命令字，即完成写入</p>
<h3 id="硬盘控制器主要的端口寄存器"><a href="#硬盘控制器主要的端口寄存器" class="headerlink" title="硬盘控制器主要的端口寄存器"></a>硬盘控制器主要的端口寄存器</h3><p><img src="/img/SimpleOS-2-Boot/img2.png" alt="img"></p>
<p>Command Block registers用于向硬盘驱动器写入命令字或者从硬盘控制器里活得硬盘状态</p>
<p>Control Block registers用于控制硬盘状态</p>
<ol>
<li><p>data寄存器用于管理数据</p>
</li>
<li><p>Error寄存器用于记录失败时的错误信息&#x2F;Feature寄存器用于部分命令需要指定额外参数</p>
</li>
<li><p>Sector count寄存器用来指定带读取&#x2F;写入的扇区数目</p>
</li>
<li><p>3个8位的LBA寄存器用于记录LBA28地址的低24位（高4位记录在device寄存器）</p>
</li>
<li><p>Command寄存器用于写入操作时存放命令字，可使用命令字如下：</p>
<p> identify：0xEC （硬盘识别）<br> read sector：0x20 （读扇区）<br> write sector：0x30（写扇区）</p>
</li>
<li><p>device寄存器是杂项，status寄存器用于给出硬盘状态信息，具体信息见下图</p>
<p> <img src="/img/SimpleOS-2-Boot/img3.png" alt="img"></p>
</li>
</ol>
<h3 id="与端口交互的in-out指令"><a href="#与端口交互的in-out指令" class="headerlink" title="与端口交互的in&#x2F;out指令"></a>与端口交互的in&#x2F;out指令</h3><ol>
<li><p>in指令用于从端口中读取数据，格式如下：</p>
<pre><code> in al,dx
 in ax,dx
</code></pre>
<p> 只要使用in指令，源操作数必须是dx(存放端口号)，而目的操作数是用al，还是ax取决于dx端口指代的寄存器是8位宽还是16位宽</p>
</li>
<li><p>out 指令用于往端口中写数据，格式如下：</p>
<pre><code> out dx,al
 out dx,ax
 out 立即数,al
 out 立即数,ax
</code></pre>
<p> out指令的源操作数是ax还是al取决于目标端口指代的寄存器是8位宽还是16位宽，源操作数可以是立即数直接给出端口号，也可以用dx（存放端口号）</p>
</li>
</ol>
<h3 id="硬盘操作约定顺序"><a href="#硬盘操作约定顺序" class="headerlink" title="硬盘操作约定顺序"></a>硬盘操作约定顺序</h3><ol>
<li>先选择通道，往该通道的sector cout寄存器写入待操作的扇区数</li>
<li>往通道上的三个LBA写入扇区地址LBA28的低24位</li>
<li>往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式</li>
<li>第四步往该通道的command寄存器写入命令（一旦写入立即执行）</li>
<li>读取status寄存器，判断硬盘工作是否完成</li>
<li>将硬盘数据读出(如果是写硬盘则无需这步)</li>
</ol>
<h2 id="保护模式概述"><a href="#保护模式概述" class="headerlink" title="保护模式概述"></a>保护模式概述</h2><h3 id="为什么要有保护模式-实模式的缺点"><a href="#为什么要有保护模式-实模式的缺点" class="headerlink" title="为什么要有保护模式(实模式的缺点)"></a>为什么要有保护模式(实模式的缺点)</h3><ol>
<li><p>实模式下用户程序和操作系统同一等级，而且逻辑地址就是物理地址，用户程序可以随意修改段基址访问所有内存，不安全</p>
</li>
<li><p>实模式16位寄存器决定访问超过64KB的内存区域要切换段基址、麻烦</p>
</li>
<li><p>一次只能运行一个程序，无法充分利用计算机资源</p>
</li>
<li><p>只有20条地址线，最大可用内存的寻址范围只有1MB，不够用</p>
</li>
</ol>
<h3 id="保护模式的特点"><a href="#保护模式的特点" class="headerlink" title="保护模式的特点"></a>保护模式的特点</h3><ol>
<li><p>应用程序只能访问虚拟地址，虚拟地址由处理器和操作系统协作转换后才显示真正的物理地址</p>
</li>
<li><p>保护模式的运行环境是32位，寄存器、数据线、地址线也相应都被扩展到32位，指令格式也有了相应的扩展（允许32位源操作数）</p>
</li>
<li><p>保护模式不再使用中断向量表、段基址寄存器这些概念。取而代之的是段选择子寄存器、全局描述符、中断描述符表、各种门结构</p>
</li>
<li><p>保护模式引入了特权级的概念，应用程序不再和操作系统拥有同一特权级</p>
</li>
</ol>
<h3 id="保护模式的扩展"><a href="#保护模式的扩展" class="headerlink" title="保护模式的扩展"></a>保护模式的扩展</h3><ol>
<li><p>寄存器扩展：</p>
<p> <img src="/img/SimpleOS-2-Boot/img18.png" alt="img"></p>
<p> 保护模式下寄存器、地址线和数据总线都扩展到32位，内存寻址空间可达4GB，段内寻址空间也可达4GB。也就是说对内存的访问甚至可以让段基址&#x3D;0，只由一个记录偏移量的寄存器来访问内存，这也就是所谓的平坦模型</p>
<p> 另外一提：保护模式抛弃基址这个概念，而是在内存里放入一个全局描述符表，每一个表项都是一个段描述符，用来描述各个内存段的起始地址、大小、权限等信息。段寄存器保护的也不再是段基址了，而是“选择子”，选择子本质上就是全局描述符表中的索引，就像是数组下标一样的东西。</p>
</li>
<li><p>寻址扩展：</p>
<p> <img src="/img/SimpleOS-2-Boot/img19.png" alt="img"></p>
<p> 如图所示保护模式的寻址方式更加灵活多变，不仅在基址寄存器(所有通用寄存器都可)和变址寄存器(处理esp外的所有通用寄存器都可)有了更多选择外，还引入了比例因子</p>
</li>
<li><p>运行模式反转：</p>
<p> 由于32位CPU兼容保护模式和实模式，所以如果你在保护模式下使用实模式的命令，或者在实模式下使用保护模式的命令，都会触发运行模式反转，将会在二进制机器码前加上相应的反转前缀。</p>
<p> 注意：模式反转前缀只对单条指令有效，效果并非是全局的</p>
<pre><code> [bit 16] ;告诉编译器接下来的代码是实模式
 [bit 32] ;告诉编译器接下来的代码是保护模式
</code></pre>
<ul>
<li><p>操作数反转前缀 0x66</p>
<p>  <img src="/img/SimpleOS-2-Boot/img20.png" alt="img"></p>
<p>  如图上半部分是代码，下半部分是编译后的机器指令</p>
<p>  第三行在[bit 16]实模式下使用了eax，触发了保护模式转换，因此机器码前加了前缀0x66</p>
<p>  第五行在[bit 32]保护模式下使用了ax，触发了实模式转换，因此机器码前加了前缀0x66</p>
</li>
<li><p>寻址方式反转前缀 0x67</p>
<p>  <img src="/img/SimpleOS-2-Boot/img21.png" alt="img"></p>
<p>  第四行在[bit 16]实模式下同时使用了保护模式的32位源操作数和更加灵活的寻址方式，触发模式转换，机器码添加了前缀0x66、0x67</p>
</li>
</ul>
</li>
<li><p>指令扩展</p>
<p> 指令扩展后允许32位寄存器和32位源操作数</p>
</li>
</ol>
<h2 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h2><p>从实模式到保护模式我们要执行四个步骤：</p>
<ol>
<li><p>打开A20地址线</p>
</li>
<li><p>加载GDT</p>
</li>
<li><p>将CR0的PE位置1</p>
</li>
<li><p>使用jump指令更新流水线，避免指令出错</p>
</li>
</ol>
<p>对于这三个步骤的讲解请看下文</p>
<h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>到了保护模式下，内存段不再是简单用寄存器加载即可用，而是需要提前把段定义好才可使用。全局描述符就是用来存储对每个段描述的表，全局描述符中的每一个表项包含段描述符，段描述符就是对一个段的描述，64位段描述符格式如下：</p>
<p><img src="/img/SimpleOS-2-Boot/img12.png" alt="img"></p>
<ol>
<li><p>段基址：</p>
<p> 每个段都有32位的段基址，在段描述符中被拆分成三块存储。</p>
<p> 为什么被拆分成三块？为的是兼容，实模式下段基址是16位，80286有关短暂的24位段基址，而现在则是32位段基址，为了兼容原本应该连续存放的段基址被拆分为16-8-8的形式。</p>
<p> 当需要查看段基址时，硬件会把三个分散的段基址取出来并拼接在一起得到一个完整的32位段基址。</p>
<p> <strong>PS：现在知道为什么有那么多屎山代码了，为了兼容旧时代的程序，屎山代码将成为每一个持续发展产品的最终归宿！</strong></p>
</li>
<li><p>段界限：</p>
<p> 段界限表示段边界的扩展最值，20位段界限被拆分为两部分(当然又是为了兼容)。</p>
<p> 段界限是一个单位量，单位要么是1字节，要么是4KB(单位由G段决定)。也就是说段的最大寻址范围要么是1*2^20&#x3D;1MB；要么是2*12*2^20&#x3D;4GB。(注意寻址范围!&#x3D;空间)</p>
<p> 实际的段界限边界值&#x3D;(描述符中段界限+1)*(段界限的粒度大小：4KB&#x2F;1Byte)-1</p>
</li>
<li><p>S字段和type字段：</p>
<p> <img src="/img/SimpleOS-2-Boot/img13.png" alt="img">   </p>
<p> S字段只有1位：S&#x3D;0 则说明是系统段(凡是硬件允许需要用到的东西，程序入口、调用门之类);S&#x3D;1 则说明是非系统段(凡是软件运行需要的东西，数据、代码、栈都是数据段)</p>
<p> type字段有4位：type字段只有在S确认后才有意义，X区分代码段和数据段，R代表是否可读，W代表是否可写，C代表是否一致，E代表向上扩展(E&#x3D;0,低地址到高地址)或向下扩展(E&#x3D;1，高地址到低地址)，A代表是否被CPU读过（CPU访问过则置1）</p>
</li>
<li><p>DPL（Descriptor Privilege Level）</p>
<p> 2位的DPL字段表示特权级，特权级从0~3,数字越低特权级越高，操作系统是0级，一般应用程序是3级</p>
</li>
<li><p>P字段（Present）：</p>
<p> 1位P表示段是否存在，有时候内存不够时，保护模式下CPU可能会按页(4KB)的单位将内存换到磁盘里，此时相当于该段不存在，即P&#x3D;0;</p>
</li>
<li><p>AVL字段（Avaliable）:</p>
<p> 1位AVL字段代表该段是否可用，是否可用是对用户来说，对操作系统来说可随意访问此位</p>
</li>
<li><p>L字段：</p>
<p> 1位L字段，L&#x3D;1表示代码段是64位，L&#x3D;0表示代码段是32位，我们在32位地址下编程将其设置为0即可</p>
</li>
<li><p>D&#x2F;B字段：</p>
<p> 1位D&#x2F;B字段指定有效地址及操作数大小，对不同段的意义不同</p>
<ul>
<li><p>如果针对代码段，D&#x3D;0时指令中有效地址和操作数是16位，指令有效地址用IP寄存器；D&#x3D;1时指令中有效地址和操作数是32位，指令有效地址用EIP寄存器</p>
</li>
<li><p>如果针对栈段，B&#x3D;0时栈使用SP寄存器，栈最大寻址范围为2^16；B&#x3D;1时栈使用ESP寄存器，栈最大寻址范围为2^32</p>
</li>
</ul>
</li>
<li><p>G段：</p>
<p> 1位G段用来指定段界限的单位大小，G&#x3D;0时，段界限的单位时1字节；G&#x3D;1时，段界限的单位是4KB</p>
</li>
</ol>
<h3 id="全局描述符号GDT、选择子以及GDTR寄存器"><a href="#全局描述符号GDT、选择子以及GDTR寄存器" class="headerlink" title="全局描述符号GDT、选择子以及GDTR寄存器"></a>全局描述符号GDT、选择子以及GDTR寄存器</h3><ol>
<li><p>GDT(Global Descriptor Table)相当于是段描述符的数组，每一表项都是一个段描述符</p>
</li>
<li><p>选择子是什么？选择子由三部分组成，如下图：</p>
<p> <img src="/img/SimpleOS-2-Boot/img14.png" alt="img"></p>
<p> 0~1位用来存储RPL，即特权级；第2位是TI(Table Indicator)，用来表示选择子是GDT还是LDT的索引；3~5位是描述符的索引值，就是数组下表</p>
<p> <strong>PS：我们注意到索引一共是13位，也就是说一个GDT最多有2^13&#x3D;8192个表项</strong></p>
</li>
<li><p>LDT(Local Descriptor Table)是局部描述符，一个任务对应一个LDT，但它在现实中应用很少，我们的系统中也未用到LDT</p>
</li>
<li><p>GDTR(Global Descriptor Table Register)是用来指向GDT的寄存器，GDT存储在内存中，GDTR存储的则是GDT的地址。</p>
<p> <img src="/img/SimpleOS-2-Boot/img15.png" alt="img"></p>
<p> 如图所示是GDTR的结构，48位寄存器前16位是GDT以字节为单位的界限，后32位是GDT在内存中的起始地址</p>
<p> <strong>GDT界限范围有16位，也就是占有2^16个字节，而一个表项占有8字节，一个GDT一共可以存储2^16&#x2F;8&#x3D;8192个表项，和上面结论相符合</strong></p>
</li>
<li><p>ldgt(load Gloabal Descriptor Table)指令用来加载GPT，一般情况下从实模式进入保护模式我们需要使用命令ldgt来初始化GPTR，不仅如此，在保护模式中我们也可以使用ldgt命令来修改GPTR的值。ldgt的指令格式是：lgdt 48位内存数据</p>
</li>
<li><p>段描述符与内存的关系</p>
<p> <img src="/img/SimpleOS-2-Boot/img16.png" alt="img"></p>
<p> 如图可知，段描述符指向内存的各个地方。但是GDT的第0个段描述符是不可用的，因为GDT是用选择子来索引的，如果选择子忘记初始化就默认为0，这样选择子相当于索引到不可用的段描述符，而不会索引到其他内存空间。</p>
</li>
</ol>
<h3 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h3><ol>
<li><p>实模式下的地址回绕</p>
<p> 实模式下有20根地址线，也就是说最多可以索引1MB空间。实模式下我们用<code>16位段基址:16位偏移量</code>的形式来计算物理地址，我们发现假设16位段基址是0xFFFF，16位地址量是0xFFFF，最终计算得到的物理地址应该是：0xFFFF*16+0xFFFF&#x3D;0x10FFEF,我们发现这个地址已经超出了20位地址线所能传输的最大范围0xFFFFF。那当我们在实模式下访问超出0xFFFFF物理地址范围的空间时会发生什么事吗？其实并不会发生太糟糕的事，由于硬件原因，超出20位地址线的位将被舍弃，当你访问超过0x100000时就相当于访问0x00000,访问0x10FFEF时就相当于访问0x0FFEF。这个特点就叫做地址回绕。</p>
</li>
<li><p>32位CPU也要兼容地址回绕</p>
<p> 实模式下地址回绕的特性被许多程序员视为优点加以利用编程，但是保护模式却没有地址回绕这个问题。所以为了满足32位CPU必须兼容保护模式和实模式的特点，我们必须让32位CPU也要具备可以自由使用地址回绕的特点。</p>
<p> 我们知道32位CPU有32位的地址线，IBM在键盘控制器上的一些输出线来控制第21根地址线(A20)的有效性，成为A20Gate。</p>
<p> 如果A20Gate&#x3D;1，当访问0x100000~0x10FFEF之间的地址将会正常访问</p>
<p> 如果A20Gate&#x3D;0，当访问0x100000~0x10FFEF之间的地址将会触发地址回绕特性</p>
</li>
<li><p>打开A20地址线</p>
<p> 因此，当我们想从实模式进入保护模式时，我们必须打开A20Gate才能让保护模式的程序正常运行，打开A20地址总线的方式是将端口0x92的第一位置1，代码如下：</p>
<pre><code> in al,0x92
 or al,0000_0010B
 out 0x92,al
</code></pre>
</li>
</ol>
<h3 id="保护模式的开关-CRO寄存器的PE位"><a href="#保护模式的开关-CRO寄存器的PE位" class="headerlink" title="保护模式的开关,CRO寄存器的PE位"></a>保护模式的开关,CRO寄存器的PE位</h3><p>想从实模式进入保护模式，我们还差最后一步。控制寄存器CRx是CPU的窗口，既可以用来展示CPU内部状态，又可以用来控制CPU运行机制。这次我们要用到CR0寄存器的PE（Protection Eanble）位，CR0寄存器构造如下图所示：</p>
<p><img src="/img/SimpleOS-2-Boot/img17.png" alt="img"></p>
<p>右上方是CR0格式位，下方则是对每个位的描述，我们目前只需要关注PE位就行了，将PE位置1，让CPU知道我们要进入保护模式了，代码如下：</p>
<pre><code>mov eax,cr0
or eax,0x00000001
mov cr0,eax
</code></pre>
<h3 id="为什么使用远跳转指令来清空流水线"><a href="#为什么使用远跳转指令来清空流水线" class="headerlink" title="为什么使用远跳转指令来清空流水线"></a>为什么使用远跳转指令来清空流水线</h3><p>我们使用<code>jmp dword SELECTOR_CODE:p_mode_start</code>来更新流水线，究竟是为什么？</p>
<ol>
<li><p>段描述缓冲寄存器未更新</p>
<p> 32位CPU兼容保护模式和实模式，段缓存寄存器在实模式下和保护模式下都有用。实模式下：段描述缓冲寄存器用于缓存段基址，保护模式下：段描述缓冲寄存器缓存段描述符。只有当CPU重新引用一个段后，段描述缓冲寄存器才会更新。</p>
<p> 当我们从实模式到保护模式后，我们的段描述缓存寄存器存在的还是实模式下用的20位段基址，这当然是不行的。所以我们指令跳转到<code>SELECTOR_CODE:p_mode_start</code>相当于重新引用一个段，让它更新。</p>
</li>
<li><p>流水线中指令译码错误</p>
<p> 从实模式到保护模式，一开始我们是16位指令，后来是32位指令。因为CPU的流水线技术提前被加载进流水线的32位指令可能会被译码错误成16位指令。因此我们使用无条件跳转指令jmp,跳转过后会自动清空流水线，避免译码错误。</p>
</li>
<li><p>dword</p>
<p> dword则是让编译器将<code>p_mode_start</code>当成32位操作数处理保证得到正确的地址</p>
</li>
</ol>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><h3 id="为什么要分页？"><a href="#为什么要分页？" class="headerlink" title="为什么要分页？"></a>为什么要分页？</h3><p>我们只有4GB的内存空间，但我们想让每一个程序都拥有（或者以为自己拥有）4GB的内存空间，于是有了分页机制。</p>
<ol>
<li><p>分页机制是在内存分段的基础上进行的</p>
</li>
<li><p>分页机制的核心思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续</p>
</li>
<li><p>一个程序它申请4GB的内存空间，实际上它并不是每时每刻都需要全部的4GB内存空间，大部分时候它都只在使用其中一两小部分的内存空间。我们将该4GB的内存空间分成好多个等大小的块（页），然后根据一个映射规则将当前有用到的块映射到物理内存中，这样4GB的物理内存就可以同时被接受多个程序享用。</p>
</li>
</ol>
<h3 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h3><ol>
<li><p>分页</p>
<p> 内存分段机制下的内存访问示意图如下：</p>
<p> <img src="/img/SimpleOS-2-Boot/img23.png" alt="img"></p>
<p> 我们在实模式下提供段基址，或者是在保护模式下提供的选择子加上另外提供的偏移量，在段部件的处理下形成了线性地址。在还没开启分页机制的情况下，这个线性地址就是真实的物理地址</p>
<p> 分页机制下的内存访问示意图如下：</p>
<p> <img src="/img/SimpleOS-2-Boot/img24.png" alt="img"></p>
<p> 如果打开了分页机制，线性地址还要经过页部件(负责检索页表的部件)的处理，然后才变成了真正的物理地址。我们把没经过页部件处理的线性地址叫做虚拟地址</p>
<p> 分页机制的作用在于：</p>
<ul>
<li><p>将线性地址转换成物理地址</p>
</li>
<li><p>用大小相等的页代替大小不相等的段</p>
</li>
</ul>
<p> 如下图所示：</p>
<p> <img src="/img/SimpleOS-2-Boot/img25.png" alt="img"></p>
<p> 在分段的基础上，将虚拟空间中的段划分为一块块大小相等的页然后映射到任意物理地址空间里</p>
</li>
<li><p>映射</p>
<p> 我们把存储映射关系的数据结构叫做页表（页表也是存储在内存中），页表中的每一项叫做页表项(记录着页对应的物理地址)，一个页表项需要4字节的大小来描述，页表与物理内存之间的关系如下图所示：</p>
<p> <img src="/img/SimpleOS-2-Boot/img26.png" alt="img"></p>
<p> 线性地址和物理地址之间的映射有多种可选择的方案</p>
<p> 比如最简单的是逐字节映射，虚拟空间中的每一个字节对应到物理空间地址上的每一个字节，那么4GB的虚拟空间对应的页表就得有4G个页表项，每个页表项需要4字节，则一共需要16GB空间大小的页表。为了扩展4GB的内存空间而使用了16GB内存空间这明显是不合适的，所以我们要找到一个合适的映射关系，使得分页机机制即能实现，也不会占用太大的额外内存空间。</p>
<p> 最终决定的合适的映射方案是：每4KB大小的空间作为一页。也就是说4GB的内存空间一共可以划分成4GB&#x2F;4KB&#x3D;1M个页，一张页表就得含有1M个页表项，总大小为4MB（就空间耗费而言可以接受）</p>
</li>
<li><p>从线性地址到物理地址</p>
<p> 现在我们如何从线性地址定位到物理地址呢？</p>
<ul>
<li><p>首先页表是存在内存中的，页表的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页表的位置了</p>
</li>
<li><p>然后我们要定位到具体的页表项，<code>取出线性地址的高20位作为索引*4（因为每个页表项占据4字节）+CR3中页表的起始物理地址=目标页表项的地址</code>。找到了页表项也就相当于找到了该页对应的物理地址</p>
</li>
<li><p>最后我们把<code>线性地址低12位作为偏移量+页物理地址=线性地址对应的真正物理地址</code></p>
</li>
</ul>
<p> 线性地址到物理地址转换的全过程如图所示：</p>
<p> <img src="/img/SimpleOS-2-Boot/img27.png" alt="img"></p>
</li>
</ol>
<h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>一级页表的大小有4MB，这个大小虽然可以接受但不够灵活，我们需要保证内存里有一整块连续的4MB空间。而且每一个进程对应一个页表，当电脑同时运行多个进程的同时页表就会占据很大的空间。我们希望能更节约空间，于是有了二级页表机制</p>
<p>二级页表将原本一共有1M个页表项的大页表分成1k个每个包含1K个页表项的小页表。小页表的空间是1K*4Byte&#x3D;4KB，刚好小页表的大小也是一个页。这样这些1K个小页表就可以灵活得分散到内存空间各个地方里了。但是为了找到这些小页表，我们需要一张页目录(页表的页表),页目录的每一项叫做页目录项（一个页目录项大小也是4字节，一共是1K项），每一项记录着对应小页表的物理地址。真巧！页目录的大小刚刚好也是1K*4Byte&#x3D;4KB(就是一个页的大小)。</p>
<p>二级页表内存分布如下图所示：</p>
<p><img src="/img/SimpleOS-2-Boot/img28.png" alt="img"></p>
<p>这样做有什么好处吗？我们发现二级页表并没有让真正的页表所占用空间变少（只是把它们拆散了），反而多出了一个4KB大小的页目录。但实际上，这样做以后，小页表不仅不需要连续的大空间，而且也可以像普通的页一样在使用频率少的情况下被从内存换到磁盘上，只在需要用的时候才取回来。用4KB空间换取的灵活能带来更多好处。</p>
<p>如何从线性地址定位到物理地址（二级页表）？</p>
<ul>
<li><p>同样也是放在内存中的页目录变成了起点，页目录的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页目录的位置了</p>
</li>
<li><p>我们先取线性地址的高10位*4（页目录项也是4字节）定位到页目录中相对应的页目录项，找到了页目录项就相当于找到了对应页表的物理地址</p>
</li>
<li><p>将线性地址的中间10位*4+对应页表的物理地址找到了页表项，找到了页表项就相当于找到了页的物理地址</p>
</li>
<li><p>将线性地址的最后12位+页的物理地址&#x3D;线性地址对应的真正物理地址</p>
</li>
</ul>
<p>线性地址到物理地址（二级页表）转换的全过程如图所示：</p>
<p><img src="/img/SimpleOS-2-Boot/img29.png" alt="img"></p>
<h3 id="页目录项、页表项以及CR3格式"><a href="#页目录项、页表项以及CR3格式" class="headerlink" title="页目录项、页表项以及CR3格式"></a>页目录项、页表项以及CR3格式</h3><p>页目录项和页表项的格式如下：</p>
<p><img src="/img/SimpleOS-2-Boot/img30.png" alt="img"></p>
<p>页目录基址寄存器(CR3)格式如下：</p>
<p><img src="/img/SimpleOS-2-Boot/img31.png" alt="img"></p>
<ol>
<li><p>为什么页目录项的页表物理地址只有20位而不是32位？因为内存是以4KB每页为单位划分的，因此只要20位地址就可以找到对应的页表了</p>
</li>
<li><p>为什么页表的物理页地址也只有20位？这20位足够索引到内存中的对应页了，剩下的12位是段内偏移量由线性地址的最后12位组成</p>
</li>
<li><p>AVL是Available位，表示可用，是给软件看的。操作系统可以不管该位</p>
</li>
<li><p>G，全局位。G&#x3D;1，则代表缓存在TLB（页表缓冲寄存器）中了，可以不用经过地址转换，直接通过TLB取值</p>
</li>
<li><p>PAT（Page Attribute Table）此位比较复杂，直接置0即可</p>
</li>
<li><p>D(Dirty)脏位，CPU对一个页进行写操作时，对应的页表项D位置1，表示该页已被修改过</p>
</li>
<li><p>A（Accessd）访问位，每当CPU访问过该页时，对应的A位置1。过一段时间后由操作系统同一置0，操作系统可以通过置0的频率来判断该页是否被经常使用</p>
</li>
<li><p>PCD(Page-level Cache Disable)页表高速缓冲禁止位，别管那么多，置0就行</p>
</li>
<li><p>PWT（Page-level Write-Through）页级通写位，别管那么多，置0就行</p>
</li>
<li><p>US（User&#x2F;Supervisor）普通用户&#x2F;超级用户位，为1表示User级，任意特权程序可访问。为0表示Supervisor级，特权级别3的程序不可访问</p>
</li>
<li><p>RW（Read&#x2F;Write）1表示可读可写，0表示可读不可写</p>
</li>
<li><p>P（Present） 存在位，P&#x3D;0表示该表不在物理内存中</p>
</li>
</ol>
<h3 id="启用分页机制的步骤"><a href="#启用分页机制的步骤" class="headerlink" title="启用分页机制的步骤"></a>启用分页机制的步骤</h3><p>启用分页机制要做三件事：</p>
<ol>
<li><p>准备好页目录以及页表</p>
</li>
<li><p>将页目录地址写入控制寄存器cr3</p>
</li>
<li><p>寄存器cr0的PG位置1</p>
</li>
</ol>
<h3 id="什么是可以自举的分页模型？"><a href="#什么是可以自举的分页模型？" class="headerlink" title="什么是可以自举的分页模型？"></a>什么是可以自举的分页模型？</h3><p>当我们想要访问一个物理地址时，我们给出的线性地址将会经过页部件的转换（页目录和页表的查询）后指向真实的物理地址。</p>
<p>现在有一个问题，如果我想要在开启分页机制的情况下修改现有的分表&#x2F;页目录，我该怎么做？</p>
<p>你可能已经发现问题所在了，我们给出的线性地址都是经过页表&#x2F;页目录的映射后才指向真实的物理地址。但是如果我想访问页表和页目录，我给出的地址也是会经过页表&#x2F;页目录的映射后指向其他地方。所以我们需要可以自举的分页模型，也就是说给出的线性地址经过经过页部件转换后可以真正指向目标页表&#x2F;页目录的物理地址。</p>
<p>接下来我们为loader构建的分页模型就是一个可以自举的分页模型</p>
<h2 id="加载内核并初始化"><a href="#加载内核并初始化" class="headerlink" title="加载内核并初始化"></a>加载内核并初始化</h2><h3 id="加载内核并初始化的步骤"><a href="#加载内核并初始化的步骤" class="headerlink" title="加载内核并初始化的步骤"></a>加载内核并初始化的步骤</h3><p>我们将告别汇编，用C编写内核文件kernel.bin,用C编写将会和之前有以下区别：</p>
<p><img src="/img/SimpleOS-2-Boot/img32.png" alt="img"></p>
<p>加载内核要做的事如下：</p>
<ol>
<li><p>用C编写并使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里</p>
</li>
<li><p>修改loader.S，负责把kernel.bin文件加载到合适的位置(执行完第三步kernel.bin就没用了)</p>
</li>
<li><p>修改loader.S，负责初始化内核，即通过elf头文件信息 将kernel.bin文件里的每个段分别放置在elf头文件指定位置(elf中包含头文件，我们总不能把头文件里的元信息也放置到CPU上执行，所以需要拆解)</p>
</li>
<li><p>跳转到kernel的程序入口地址，loader.S交出最后一棒接力棒</p>
</li>
</ol>
<h3 id="内核文件的内存布局"><a href="#内核文件的内存布局" class="headerlink" title="内核文件的内存布局"></a>内核文件的内存布局</h3><p>我们要讲内核加载到内存的哪里？请看下图低端1MB内存布局里三个打勾的位置：</p>
<p><img src="/img/SimpleOS-2-Boot/img33.png" alt="img"></p>
<p>三个打勾的位置将会是我们内核存放的地方（加载在0x7c00的MBR的工作已经做完了，可以被覆盖。加载在0x900的loader里面包含gdt设置，不能被覆盖），从上述加载内核的步骤看我们需要两个地方来存储内核。</p>
<p>第一个地方存储kernel.bin(对应第2步)</p>
<p>第二个地方存储被loader.S处理后的真正的内核映像文件(对应第三步)</p>
<p>kernel.bin应尽量位于高地址，给不断增长的kernel映像文件腾出空间。预计kernel.bin不会超过100kb，计划存储在0x70000（0x70000~0x9fbff有190KB）。</p>
<p>kernel被处理后的映像文件应该尽量放在低地址同时不能覆盖loader。预计loader大小不会超过2000字节,0x900+2000&#x3D;0x10d0,取一个整数为kernel的映像文件地址0x1500。</p>
<p>上述我们说的都是物理地址，由于我们开启了分页机制后，写代码时里要将物理地址转化为虚拟地址，相应的两个虚拟地址分别是0xc0070000和0xc0001500</p>
<p>在加载完内核后，我们还需要选择一个新的地方作为内核代码的栈顶，可用空间的顶部0x9fc00作为栈顶是最合适的。但是由于pcb（后面章节讲）要求4KB对齐，所以栈顶既要接近0x9fc00又要是4KB的整数倍,所以我们选择了0x9f000作为内核代码的栈顶，转化为虚拟地址即是0xc009f000</p>
<h2 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h2><h3 id="elf文件布局"><a href="#elf文件布局" class="headerlink" title="elf文件布局"></a>elf文件布局</h3><p>elf文件&#x3D;二进制可执行文件+头文件(存储元信息)</p>
<p>一个elf文件的逻辑布局如下图：</p>
<p><img src="/img/SimpleOS-2-Boot/img34.png" alt="img"></p>
<p>物理布局如下图：</p>
<p><img src="/img/SimpleOS-2-Boot/img35.png" alt="img"></p>
<p>关于这两图我们要讲几点：</p>
<ol>
<li><p>Section和Segment的区别：</p>
<p> Section是写代码时为了更清楚的逻辑划分，程序员将代码主动划分为一节一节。（汇编语言中的section、segment关键字本质上划分的都是节）</p>
<p> Segment是编译器将相同类型的Section集合在一起形成了段，如代码段、数据段。（经过编译器链接后，我们才称为段）</p>
</li>
<li><p>我们关注的重点：</p>
<p> 大部分的Section经过编译器链接后成为了Segment，我们关注的重点在Segment，我们所要做的就是根据elf头文件的指示，将每一个Segment放到它该去的地方</p>
</li>
</ol>
<h3 id="elf-header结构"><a href="#elf-header结构" class="headerlink" title="elf header结构"></a>elf header结构</h3><p>elf格式的数据类型（它们就和int、double一样，只关注字节大小就好了）</p>
<p><img src="/img/SimpleOS-2-Boot/img36.png" alt="img"></p>
<p>elf header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/SimpleOS-2-Boot/img37.png" alt="img"></p>
<p>elf header具体数据成员意义描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:e_phoff、e_phentisize、e_phnum）：</p>
<ol>
<li><p>e_ident</p>
<p> <img src="/img/SimpleOS-2-Boot/img38.png" alt="img"></p>
</li>
<li><p>e_type</p>
<p> <img src="/img/SimpleOS-2-Boot/img39.png" alt="img"></p>
</li>
<li><p>e_machine</p>
<p> <img src="/img/SimpleOS-2-Boot/img40.png" alt="img"></p>
</li>
<li><p>others</p>
<p> <img src="/img/SimpleOS-2-Boot/img41.png" alt="img"></p>
</li>
</ol>
<h3 id="program-table-header结构"><a href="#program-table-header结构" class="headerlink" title="program table header结构"></a>program table header结构</h3><p>program table header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/SimpleOS-2-Boot/img42.png" alt="img"></p>
<p>program table header的成员描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:p_offset、p_vaddr、p_mensz）：</p>
<ol>
<li><p>p_type<br> <img src="/img/SimpleOS-2-Boot/img43.png" alt="img"></p>
</li>
<li><p>p_flags<br> <img src="/img/SimpleOS-2-Boot/img44.png" alt="img"></p>
</li>
<li><p>others<br> <img src="/img/SimpleOS-2-Boot/img45.png" alt="img"></p>
</li>
</ol>
<p>实例：请参照<code>操作系统真相象还原</code>P218-5.3.4；我们可以使用命令<code>readelf -e &#39;文件名&#39;</code>来查看一个elf文件的头的具体数据,也可以使用<code>hd &#39;文件名&#39;</code>来查看一个elf文件的十六进制形式</p>
<h1 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h1><p>见连接如下：</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" rel="prev" title="VScode编码不一致问题">
                  <i class="fa fa-angle-left"></i> VScode编码不一致问题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/31/SimpleOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="next" title="SimpleOS-内存管理">
                  SimpleOS-内存管理 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
