<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本章我们用C语言编写一个简易内核并编译链接，然后用loader程序加载该内核并初始化 进行这章之前要将gcc降级为gcc-4.4，如何给gcc降级请参考ubuntu 16.04 gcc高低版本切换 获取物理内存容量接触虚拟内存之前我们要知道如何获取物理内存，我们先学习使用BIOS中断int 0x15的三个子功能来获取物理内存 利用BIOS中断0x15子功能0xe820来获取内存0xe820功能最强">
<meta property="og:type" content="website">
<meta property="og:title" content="自制简易操作系统（五）">
<meta property="og:url" content="http://example.com/MyTemp/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="本章我们用C语言编写一个简易内核并编译链接，然后用loader程序加载该内核并初始化 进行这章之前要将gcc降级为gcc-4.4，如何给gcc降级请参考ubuntu 16.04 gcc高低版本切换 获取物理内存容量接触虚拟内存之前我们要知道如何获取物理内存，我们先学习使用BIOS中断int 0x15的三个子功能来获取物理内存 利用BIOS中断0x15子功能0xe820来获取内存0xe820功能最强">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img1.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img2.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img3.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img4.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img5.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img6.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img7.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img8.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img9.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img10.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img11.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img12.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img13.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img14.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img15.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img16.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img17.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img18.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img19.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img33.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img20.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img21.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img22.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img23.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img24.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img25.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img26.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img27.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img28.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img29.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img30.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img31.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img35.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img36.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img37.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img38.png">
<meta property="og:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img34.png">
<meta property="article:published_time" content="2023-11-15T03:40:48.000Z">
<meta property="article:modified_time" content="2024-05-07T17:14:19.617Z">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img1.png">


<link rel="canonical" href="http://example.com/MyTemp/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"en","comments":true,"permalink":"http://example.com/MyTemp/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89.html","path":"MyTemp/自制简易操作系统（五）.html","title":"自制简易操作系统（五）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>自制简易操作系统（五） | Sparkle's Space
</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sparkle's Space</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="nav-number">1.</span> <span class="nav-text">获取物理内存容量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8BIOS%E4%B8%AD%E6%96%AD0x15%E5%AD%90%E5%8A%9F%E8%83%BD0xe820%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98"><span class="nav-number">1.1.</span> <span class="nav-text">利用BIOS中断0x15子功能0xe820来获取内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8BIOS%E4%B8%AD%E6%96%AD0x15%E5%AD%90%E5%8A%9F%E8%83%BD0xe801%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">利用BIOS中断0x15子功能0xe801来获取内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8BIOS%E4%B8%AD%E6%96%AD0x15%E5%AD%90%E5%8A%9F%E8%83%BD0xe88%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98"><span class="nav-number">1.3.</span> <span class="nav-text">利用BIOS中断0x15子功能0xe88来获取内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.4.</span> <span class="nav-text">实战代码：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">启用分页机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">为什么要分页？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">一级页表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">二级页表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95%E9%A1%B9%E3%80%81%E9%A1%B5%E8%A1%A8%E9%A1%B9%E4%BB%A5%E5%8F%8ACR3%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">页目录项、页表项以及CR3格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6-1"><span class="nav-number">2.5.</span> <span class="nav-text">启用分页机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="nav-number">2.6.</span> <span class="nav-text">代码实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E5%88%86%E9%A1%B5%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="nav-number">2.6.1.</span> <span class="nav-text">明确分页模型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%EF%BC%9A"><span class="nav-number">2.6.2.</span> <span class="nav-text">具体代码展示：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="nav-number">2.6.3.</span> <span class="nav-text">调试：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.4.</span> <span class="nav-text">TLB更新方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8"><span class="nav-number">3.</span> <span class="nav-text">加载内核</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.</span> <span class="nav-text">加载内核的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">3.2.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">elf文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#elf%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80"><span class="nav-number">3.3.1.</span> <span class="nav-text">elf文件布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#elf-header%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.2.</span> <span class="nav-text">elf header结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#program-table-header%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.3.</span> <span class="nav-text">program table header结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-1"><span class="nav-number">3.4.</span> <span class="nav-text">代码实战</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%B9%E6%9D%83%E7%BA%A7%EF%BC%9ADPL%E3%80%81CPL%E3%80%81RPL"><span class="nav-number">4.</span> <span class="nav-text">特权级：DPL、CPL、RPL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89RPL%E7%9A%84%E4%B8%96%E7%95%8C"><span class="nav-number">4.1.</span> <span class="nav-text">没有RPL的世界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89RPL%E4%B8%96%E7%95%8C%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%89%E4%BA%86%E8%B0%83%E7%94%A8%E9%97%A8"><span class="nav-number">4.2.</span> <span class="nav-text">没有RPL世界，但是有了调用门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%E5%BC%95%E5%8F%91%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="nav-number">4.3.</span> <span class="nav-text">调用门引发的危险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPL%E8%A7%A3%E5%86%B3%E8%B0%83%E7%94%A8%E9%97%A8%E5%8D%B1%E6%9C%BA"><span class="nav-number">4.4.</span> <span class="nav-text">RPL解决调用门危机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">5.</span> <span class="nav-text">结语</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="en"><header class="post-header">

<h1 class="post-title" itemprop="name headline">自制简易操作系统（五）
</h1>

<div class="post-meta-container">
</div>

</header>

      
      
      <div class="post-body">
          <p>本章我们用C语言编写一个简易内核并编译链接，然后用loader程序加载该内核并初始化</p>
<p>进行这章之前要将gcc降级为gcc-4.4，如何给gcc降级请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/wu11zhike/article/details/83865549?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">ubuntu 16.04 gcc高低版本切换</a></p>
<h1 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h1><p>接触虚拟内存之前我们要知道如何获取物理内存，我们先学习使用BIOS中断int 0x15的三个子功能来获取物理内存</p>
<h2 id="利用BIOS中断0x15子功能0xe820来获取内存"><a href="#利用BIOS中断0x15子功能0xe820来获取内存" class="headerlink" title="利用BIOS中断0x15子功能0xe820来获取内存"></a>利用BIOS中断0x15子功能0xe820来获取内存</h2><p>0xe820功能最强大也最复杂，它会遍历主机上的所有内存并以ARDS（Address Range Descriptor Structure）的形式按照类型连续返回主机上的内存</p>
<ol>
<li><p>ARDS结构</p>
<p> ARDS的结构如下图（上图是ARDS，下图是ARDS中Type字段的描述）：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img1.png" alt="img"></p>
<p> <strong>PS：图中我们发现基地址和长度都是用64位表示的，但我们是32位CPU，所以说我们只关注低32位即可</strong></p>
<p> 为什么该子功能会按类型来返回内存信息？原因是这段内存可能是系统的ROM、或者是ROM用到了这部分内存、或者由于某些原因这段内存不适合标准设备使用。但这些我们都不用理会，我们只需要知道在返回的所有ARDS结构中，范围最大的内存一定是操作系统可使用的部分（也就是我们在主板上配置的物理内存容量）</p>
</li>
<li><p>0xe820调用说明</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img2.png" alt="img"></p>
</li>
</ol>
<h2 id="利用BIOS中断0x15子功能0xe801来获取内存"><a href="#利用BIOS中断0x15子功能0xe801来获取内存" class="headerlink" title="利用BIOS中断0x15子功能0xe801来获取内存"></a>利用BIOS中断0x15子功能0xe801来获取内存</h2><p>0xe801用法比较简单，但是功能并不强大；分别检测低15MB和16MB~4GB的内存，最大支持检测4GB（对32位CPU来说刚好够用）</p>
<ol>
<li><p>0xe801调用说明</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img3.png" alt="img"></p>
</li>
<li><p>对0xe801功能的疑惑解答</p>
<p> 为什么要划分为前15MB和16MB以上？原因是为了兼容80286(80286寻址空间是16MB)。</p>
<p> 下图是0xe801调用的实例：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img4.png" alt="img"></p>
<p> 我们发现，实际物理内存总是比检测到的内存多1MB，因为为了兼容80286系统导致系统中有一块保留的但不可视也不可用的1MB内存空洞，我们无需管那么所，我们只要知道用0xe801检测出来的内存空间要加上1MB才是实际的物理内存</p>
</li>
</ol>
<h2 id="利用BIOS中断0x15子功能0xe88来获取内存"><a href="#利用BIOS中断0x15子功能0xe88来获取内存" class="headerlink" title="利用BIOS中断0x15子功能0xe88来获取内存"></a>利用BIOS中断0x15子功能0xe88来获取内存</h2><p>最简单，但是最大只能检测64MB大小的内存，调用说明如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img5.png" alt="img"></p>
<h2 id="实战代码："><a href="#实战代码：" class="headerlink" title="实战代码："></a>实战代码：</h2><p>我们在原有的loader.S文件里添加了获取内存的代码，代码如下:</p>
<pre><code>;loader.S 负责构建gpt后，查看物理内存
%include &quot;boot.inc&quot;
SECTION loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
jmp loader_start                      		   ;跳跃到代码区


    ;构建gpt及其内部的描述符
    ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
    ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
    GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                dd 0x00000000 

    CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                dd DESC_CODE_HIGH4

    ;这边数据段和栈段共用一个段
    ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
    ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
    ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
    ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
    DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                        dd DESC_DATA_HIGH4

    VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                dd DESC_VIDEO_HIGH4     	  
                    
    GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
    GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

    times 60 dq 0                              ;预留60个 四字型 描述符
    
    ;------------------------数据段更新部分-----------------------------------
                    
    ;total_men_bytes用来存储检测出来的内存大小，loader.bin我们装载在0x900起始地址,当前位置偏移文件头0x203字节(前面的数据定义占据512字节，jmp指令占据3字节)
    ;也就是说total_men_bytes在内存地址0xb03（后面用`mov ax,total_men_bytes`指令检测正确性）
    total_mem_bytes dd 0  
    
    ;gdt指针
    gdt_ptr         dw GDT_LIMIT
                    dd GDT_BASE
    
    ;ards_buf是存放ARDS的缓冲区，之所以要244个字节是为了实现地址对齐,ards_nr是记录ARDS的数量
    ;total_men_bytes4+gdt_ptr6+ards_buf244+ards_nr2=256字节
    ards_buf times 244  db  0
    ards_nr             dw  0               
    
    ;----------------------------------------------------------------------------
    ;构造16位的段选择子
    SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
    SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
    SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0


    loadermsg db   &#39;welcome to loader zone!&#39;                  ;loadermsg 加载区显示字符
    
    
    
;以下代码则是开始查内存
loader_start:
;--------------------------------- 代码段更新 -----------------------------    
    mov eax,total_mem_bytes ;该条指令用于调试时验证total_men_bytes的真正地址，结果确实是0xb03
    
    ;使用0xe820的子功能进行内存查询
    mov eax,0xe820
    xor ebx,ebx
    mov ecx,20 
    mov edx,0x534d4150
    mov di,ards_buf
    
.e820_men_get_loop:    
    int 0x15
    jc .e801_failed_so_try_e801 
    mov eax,0xe820
    add di,cx
    inc word [ards_nr]
    mov ecx,20
    cmp ebx,0
    jnz .e820_men_get_loop   

    ;使用冒泡排序找出内存最大值
    mov cx,[ards_nr]
    xor edx,edx  ;edx用于冒泡排序中存储内存最大值  
    mov esi,ards_buf 
.seek_max_men: 
    mov eax,[esi] 
    add eax,[esi+8] 
    cmp eax,edx
    jb .pass_swap
    mov edx,eax
.pass_swap:
    add esi,20
    loop .seek_max_men
    jmp .men_get_ok
    
    
;0xe820失败，使用0xe801测试内存   
.e801_failed_so_try_e801:   
    mov ax,0xE801
    int 0x15
    jc .e801_failed_so_try_88 
    mov ax,1024
    mul cx
    shl edx,16
    and eax,0x0000FFFF
    or edx,eax 
    add edx,0x100000
    mov esi,edx
    xor eax,eax
    mov ax,bx
    mov ecx,0x10000
    mul ecx
    add esi,eax 
    mov edx,esi
    jmp .men_get_ok


;0xe801失败，使用0x88测试内存
.e801_failed_so_try_88:
    mov ah,0x88
    int 0x15
    jc .error_hlt
    and eax,0x0000FFFF
    mov cx,0x400
    mul cx
    shl edx,16
    or edx,eax
    add edx,0x100000 
    jmp .men_get_ok

.error_hlt:
    jmp $
    
.men_get_ok:    
    mov [total_mem_bytes],edx      
;---------------------------------------------------------------------------------    
    
    ;这段和之前一样，调用BIOS提供的int10功能显示字符
    mov sp,LOADER_BASE_ADDR					
    mov bp,loadermsg                                           
    mov cx,23     
    mov ax,cs                                                 
    mov es,ax                                                 
    mov ax,0x1301                                             
    mov bx,0x001f                                           
    mov dx,0x1800                                             
    int 0x10

    ; --------------------------------- 设置进入保护模式 -----------------------------
    ; 1 打开A20 gate 
    in al,0x92                
    or al,0000_0010b
    out 0x92,al

    ; 2 加载gdt
    lgdt [gdt_ptr] 

    ; 3 将cr0 的 pe位置1
    mov eax,cr0                
    or  eax,0x00000001              
    mov cr0,eax
    
    ;-------------------------------- 已经打开保护模式 ---------------------------------------
    jmp dword SELECTOR_CODE:p_mode_start                       
    ;前面是16位指令，后面是32位指令，CPU由于流水线技术无法直接处理混合在一起的二者，利用无转跳指令刷新一下流水线即可
    ;dword指定访问数据为32位，进入了保护模式后，操作数变为32位，这里声明选择子和偏移量都是32位操作数

[bits 32]
p_mode_start: 
    ;是初始化段选择子
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax
    
    ;测试显存段
    mov byte [gs:160],&#39;P&#39; 
    
    jmp $     
</code></pre>
<p><strong>PS：在这里学到一个以前不了解的汇编知识，假如我有个标号loader_start:，这个标号里面还有个标号.error_hit:则第二个标号的全称其实是loader_start.error_hit,它属于是第一个标号的子标号只能在loader_start的作用范围内使用.error_hit这个标号的名字，否则要使用全称</strong>     </p>
<h1 id="启用分页机制"><a href="#启用分页机制" class="headerlink" title="启用分页机制"></a>启用分页机制</h1><h2 id="为什么要分页？"><a href="#为什么要分页？" class="headerlink" title="为什么要分页？"></a>为什么要分页？</h2><p>我们只有4GB的内存空间，但我们想让每一个程序都拥有（或者以为自己拥有）4GB的内存空间，于是有了分页机制。</p>
<ol>
<li><p>分页机制是在内存分段的基础上进行的</p>
</li>
<li><p>分页机制的核心思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续</p>
</li>
<li><p>一个程序它申请4GB的内存空间，实际上它并不是每时每刻都需要全部的4GB内存空间，大部分时候它都只在使用其中一两小部分的内存空间。我们将该4GB的内存空间分成好多个等大小的块（页），然后根据一个映射规则将当前有用到的块映射到物理内存中，这样4GB的物理内存就可以同时被接受多个程序享用。</p>
</li>
</ol>
<h2 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h2><ol>
<li><p>分页</p>
<p> 内存分段机制下的内存访问示意图如下：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img6.png" alt="img"></p>
<p> 我们在实模式下提供段基址，或者是在保护模式下提供的选择子加上另外提供的偏移量，在段部件的处理下形成了线性地址。在还没开启分页机制的情况下，这个线性地址就是真实的物理地址</p>
<p> 分页机制下的内存访问示意图如下：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img7.png" alt="img"></p>
<p> 如果打开了分页机制，线性地址还要经过页部件(负责检索页表的部件)的处理，然后才变成了真正的物理地址。我们把没经过页部件处理的线性地址叫做虚拟地址</p>
<p> 分页机制的作用在于：</p>
<ul>
<li><p>将线性地址转换成物理地址</p>
</li>
<li><p>用大小相等的页代替大小不相等的段</p>
</li>
</ul>
<p> 如下图所示：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img8.png" alt="img"></p>
<p> 在分段的基础上，将虚拟空间中的段划分为一块块大小相等的页然后映射到任意物理地址空间里</p>
</li>
<li><p>映射</p>
<p> 我们把存储映射关系的数据结构叫做页表（页表也是存储在内存中），页表中的每一项叫做页表项(记录着页对应的物理地址)，一个页表项需要4字节的大小来描述，页表与物理内存之间的关系如下图所示：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img9.png" alt="img"></p>
<p> 线性地址和物理地址之间的映射有多种可选择的方案</p>
<p> 比如最简单的是逐字节映射，虚拟空间中的每一个字节对应到物理空间地址上的每一个字节，那么4GB的虚拟空间对应的页表就得有4G个页表项，每个页表项需要4字节，则一共需要16GB空间大小的页表。为了扩展4GB的内存空间而使用了16GB内存空间这明显是不合适的，所以我们要找到一个合适的映射关系，使得分页机机制即能实现，也不会占用太大的额外内存空间。</p>
<p> 最终决定的合适的映射方案是：每4KB大小的空间作为一页。也就是说4GB的内存空间一共可以划分成4GB&#x2F;4KB&#x3D;1M个页，一张页表就得含有1M个页表项，总大小为4MB（就空间耗费而言可以接受）</p>
</li>
<li><p>从线性地址到物理地址</p>
<p> 现在我们如何从线性地址定位到物理地址呢？</p>
<ul>
<li><p>首先页表是存在内存中的，页表的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页表的位置了</p>
</li>
<li><p>然后我们要定位到具体的页表项，<code>取出线性地址的高20位作为索引*4（因为每个页表项占据4字节）+CR3中页表的起始物理地址=目标页表项的地址</code>。找到了页表项也就相当于找到了该页对应的物理地址</p>
</li>
<li><p>最后我们把<code>线性地址低12位作为偏移量+页物理地址=线性地址对应的真正物理地址</code></p>
</li>
</ul>
<p> 线性地址到物理地址转换的全过程如图所示：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img10.png" alt="img"></p>
</li>
</ol>
<h2 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h2><p>一级页表的大小有4MB，这个大小虽然可以接受但不够灵活，我们需要保证内存里有一整块连续的4MB空间。而且每一个进程对应一个页表，当电脑同时运行多个进程的同时页表就会占据很大的空间。我们希望能更节约空间，于是有了二级页表机制</p>
<p>二级页表将原本一共有1M个页表项的大页表分成1k个每个包含1K个页表项的小页表。小页表的空间是1K*4Byte&#x3D;4KB，刚好小页表的大小也是一个页。这样这些1K个小页表就可以灵活得分散到内存空间各个地方里了。但是为了找到这些小页表，我们需要一张页目录(页表的页表),页目录的每一项叫做页目录项（一个页目录项大小也是4字节，一共是1K项），每一项记录着对应小页表的物理地址。真巧！页目录的大小刚刚好也是1K*4Byte&#x3D;4KB(就是一个页的大小)。</p>
<p>二级页表内存分布如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img11.png" alt="img"></p>
<p>这样做有什么好处吗？我们发现二级页表并没有让真正的页表所占用空间变少（只是把它们拆散了），反而多出了一个4KB大小的页目录。但实际上，这样做以后，小页表不仅不需要连续的大空间，而且也可以像普通的页一样在使用频率少的情况下被从内存换到磁盘上，只在需要用的时候才取回来。用4KB空间换取的灵活能带来更多好处。</p>
<p>如何从线性地址定位到物理地址（二级页表）？</p>
<ul>
<li><p>同样也是放在内存中的页目录变成了起点，页目录的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页目录的位置了</p>
</li>
<li><p>我们先取线性地址的高10位*4（页目录项也是4字节）定位到页目录中相对应的页目录项，找到了页目录项就相当于找到了对应页表的物理地址</p>
</li>
<li><p>将线性地址的中间10位*4+对应页表的物理地址找到了页表项，找到了页表项就相当于找到了页的物理地址</p>
</li>
<li><p>将线性地址的最后12位+页的物理地址&#x3D;线性地址对应的真正物理地址</p>
</li>
</ul>
<p>线性地址到物理地址（二级页表）转换的全过程如图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img12.png" alt="img"></p>
<h2 id="页目录项、页表项以及CR3格式"><a href="#页目录项、页表项以及CR3格式" class="headerlink" title="页目录项、页表项以及CR3格式"></a>页目录项、页表项以及CR3格式</h2><p>页目录项和页表项的格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img13.png" alt="img"></p>
<p>页目录基址寄存器(CR3)格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img14.png" alt="img"></p>
<ol>
<li><p>为什么页目录项的页表物理地址只有20位而不是32位？因为内存是以4KB每页为单位划分的，因此只要20位地址就可以找到对应的页表了</p>
</li>
<li><p>为什么页表的物理页地址也只有20位？这20位足够索引到内存中的对应页了，剩下的12位是段内偏移量由线性地址的最后12位组成</p>
</li>
<li><p>AVL是Available位，表示可用，是给软件看的。操作系统可以不管该位</p>
</li>
<li><p>G，全局位。G&#x3D;1，则代表缓存在TLB（页表缓冲寄存器）中了，可以不用经过地址转换，直接通过TLB取值</p>
</li>
<li><p>PAT（Page Attribute Table）此位比较复杂，直接置0即可</p>
</li>
<li><p>D(Dirty)脏位，CPU对一个页进行写操作时，对应的页表项D位置1，表示该页已被修改过</p>
</li>
<li><p>A（Accessd）访问位，每当CPU访问过该页时，对应的A位置1。过一段时间后由操作系统同一置0，操作系统可以通过置0的频率来判断该页是否被经常使用</p>
</li>
<li><p>PCD(Page-level Cache Disable)页表高速缓冲禁止位，别管那么多，置0就行</p>
</li>
<li><p>PWT（Page-level Write-Through）页级通写位，别管那么多，置0就行</p>
</li>
<li><p>US（User&#x2F;Supervisor）普通用户&#x2F;超级用户位，为1表示User级，任意特权程序可访问。为0表示Supervisor级，特权级别3的程序不可访问</p>
</li>
<li><p>RW（Read&#x2F;Write）1表示可读可写，0表示可读不可写</p>
</li>
<li><p>P（Present） 存在位，P&#x3D;0表示该表不在物理内存中</p>
</li>
</ol>
<h2 id="启用分页机制-1"><a href="#启用分页机制-1" class="headerlink" title="启用分页机制"></a>启用分页机制</h2><p>启用分页机制要做三件事：</p>
<ol>
<li><p>准备好页目录以及页表</p>
</li>
<li><p>将页目录地址写入控制寄存器cr3</p>
</li>
<li><p>寄存器cr0的PG位置1</p>
</li>
</ol>
<h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><h3 id="明确分页模型："><a href="#明确分页模型：" class="headerlink" title="明确分页模型："></a>明确分页模型：</h3><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img15.png" alt="img"></p>
<p>我们只打算把物理内存的低端1MB空间拿来存放内核，而一张页表就可以表示4MB空间，也就是说，其实我们需要的只要<code>一张页表里的256个PTE</code>就够了。所以我们先暂时只申请1个页目录和255个页表(为什么少一个后面提到了)，用来存放内核。</p>
<p>页目录PD的三个重要映射：</p>
<ol>
<li><p>PD[0]指向 第0张页表：<br> 因为开启分页机制前我们正在用线性地址运行处于物理地址低端1MB的代码，而开启分页机制后，线性地址变成了会自动经过页部件转化的虚拟地址，要想保证处于物理地址低端1MB的代码继续正常运行，我们就必须让虚拟空间的低端1MB映射物理地址的低端1MB，<code>PD[0]指向第0张页表</code>这个操作保证了代码正常运行。</p>
</li>
<li><p>PD[1023]指向了页目录起始地址：<br> 这是为了实现能通过虚拟地址修改该页表和页目录的操作，后续会详细讲解，这边就当浪费一个PDE</p>
</li>
<li><p>PD[768]~PD[1022]指向了255个页表：<br> 这儿就是实现将虚拟空间高端1GB里的1MB内核地址映射到物理空间里低端1MB内核地址的关键</p>
</li>
</ol>
<h3 id="具体代码展示："><a href="#具体代码展示：" class="headerlink" title="具体代码展示："></a>具体代码展示：</h3><p>首先是修改boot.inc头文件，在里面添加页目录和页表相关宏：</p>
<pre><code>;--------------loader和kernel----------------

LOADER_BASE_ADDR equ 0x900
;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

LOADER_START_SECTOR equ 0x2
;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区

;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------
;为了方便我们将64位的gdt描述符分为高32位和低32位来定义，下面代码定义的都是低32位


;二进制数据中间的&#39;_&#39;符号没有任何意义，仅仅只是为了让程序员看得更清楚，编译器会自动忽略
;命名中的DESC是描述的意思
DESC_G_4K equ 1_00000000000000000000000b ;第23位G 表示4K或者1MB位 段界限的单位值 此时为1则为4k 
DESC_D_32 equ 1_0000000000000000000000b  ;第22位D/B位 表示地址值用32位EIP寄存器 操作数与指令码32位
DESC_L    equ 0_000000000000000000000b   ;第21位 设置成0表示32位代码段而非64位代码段
DESC_AVL  equ 0_00000000000000000000b    ;第20位 CPU不用此位设置为0


;LIMIT代表段界限，我们打算在GPT里加入三个段：代码段、数据段、显存段(就是将之前显存的位置单独划分一个成一个段)
;我们对4GB的内存空间采用平坦模式，也就是说基址=0，偏移量最大范围=4GB（除了显存段外，显存段任然放置在0xB8000~0xBFFFF）
;DESC_LIMIT_CODE2代表定义代码段的段界限(第二部分)
DESC_LIMIT_CODE2  equ  1111_0000000000000000b   ;平坦模型要满足最大段界限*粒度=4GB，换算可知段界限必须为0xFFFFF,也就是全为1
DESC_LIMIT_DATA2  equ  DESC_LIMIT_CODE2         ;相同的值  数据段与代码段段界限相同
DESC_LIMIT_VIDEO2 equ	0000_0000000000000000b	;第16-19位 显存段任然放置在0xB8000~0xBFFFF，段基址应该为0xbffff,
                                                ;段界限应该为(0xbffff-0xb8000)/4k=7(高4位为0)


DESC_P            equ 	1_000000000000000b	  
DESC_DPL_0        equ  00_0000000000000b         
DESC_DPL_1        equ  01_0000000000000b	  
DESC_DPL_2        equ  10_0000000000000b
DESC_DPL_3        equ  11_0000000000000b
DESC_S_sys        equ  0_000000000000b           
DESC_S_CODE       equ  1_000000000000b        
DESC_S_DATA       equ  DESC_S_CODE


;这边存在一个问题，根据书本上的Type格式图里从3~0位数据段的排序应该是xwea，而代码部分则按照xewa的顺序，需要进一步确认
DESC_TYPE_CODE    equ  1000_00000000b            ;第9-11位表示该段状态 1000 可执行 不允许可读 已访问位0
;x=1 e=0 w=0 a=0
DESC_TYPE_DATA    equ  0010_00000000b            ;第9-11位type段   0010  可写  
;x=0 e=0 w=1 a=0



;代码段描述符高位4字节初始化 (0x00共8位 &lt;&lt;24 共32位初始化0) 
;4KB为单位 Data段32位操作数 初始化的部分段界限 最高权限操作系统代码段 P存在表示 状态 
DESC_CODE_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \
DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00

;数据段描述符高位4字节初始化
DESC_DATA_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00

;显存段描述符高位4字节初始ua
DESC_VIDEO_HIGH4   equ (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B  ;书本上末尾是0，但显存段段基址应该为0xbffff，也就是说这边末尾应该是B 



;-------------------- 选择子属性 --------------------------------
RPL0    equ 00b
RPL1    equ 01b
RPL2    equ 10b
RPL3    equ 11b
TI_GDT  equ 000b
TI_LDT  equ 100b


;-----------------------页目录和页表属性---------------------------------------     
PAGE_DIR_TABLE_POS equ 0x100000

PG_P    equ 1b
PG_RW_R equ 00b
PG_RW_W equ 10b
PG_US_S equ 000b
PG_US_U equ 100b
</code></pre>
<p>loader.S完成构建页表、页目录、以及启动分页机制：</p>
<pre><code>;loader.S 负责完成构建页表、页目录、以及启动分页机制
%include &quot;boot.inc&quot;
SECTION loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
jmp loader_start                      		   ;跳跃到代码区


    ;构建gpt及其内部的描述符
    ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
    ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
    GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                dd 0x00000000 

    CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                dd DESC_CODE_HIGH4

    ;这边数据段和栈段共用一个段
    ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
    ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
    ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
    ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
    DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                        dd DESC_DATA_HIGH4

    VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                dd DESC_VIDEO_HIGH4     	  
                    
    GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
    GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

    times 60 dq 0                              ;预留60个 四字型 描述符
    
    ;gdt指针
    gdt_ptr         dw GDT_LIMIT
                    dd GDT_BASE  
    
    ;构造16位的段选择子
    SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
    SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
    SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0  
    
    
loader_start:   
    ; --------------------------------- 设置进入保护模式 -----------------------------
    ; 1 打开A20 gate 
    in al,0x92                
    or al,0000_0010b
    out 0x92,al

    ; 2 加载gdt
    lgdt [gdt_ptr] 

    ; 3 将cr0 的 pg位置1
    mov eax,cr0                
    or  eax,0x00000001              
    mov cr0,eax
    
    ;-------------------------------- 已经打开保护模式 ---------------------------------------
    jmp dword SELECTOR_CODE:p_mode_start                       
    ;前面是16位指令，后面是32位指令，CPU由于流水线技术无法直接处理混合在一起的二者，利用无转跳指令刷新一下流水线即可
    ;dword指定访问数据为32位，进入了保护模式后，操作数变为32位，这里声明选择子和偏移量都是32位操作数


[bits 32]
p_mode_start: 
    ;是初始化段选择子
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax
    
    ;测试显存段
    mov byte [gs:160],&#39;P&#39; 
    
    ;开始构建页表以及页目录
    call setup_page 
    
    ;如果我们开启了分页机制，所有线性地址都将变成虚拟地址，为了保证gdt能正常运作，我们需要在它的线性基址上+0xc0000000(也就是上升到3GB以上的1MB内核空间)
    ;3GB以上的1MB内核空间会映射回原来的低端1MB物理地址，保证代码正常运行
    ;sgdt将GDTR里面的内容取出到gdt_ptr
    sgdt [gdt_ptr]
    
    ;将显存段的位置移动到内核中
    mov ebx,[gdt_ptr+2]
    or dword [ebx+0x18+4],0xc0000000
    
    ;修改gdt_base的位置
    add dword [gdt_ptr+2],0xc0000000

    ;修改栈顶指针位置
    add esp,0xc0000000
    
    ;向cr3传入页目录地址
    mov eax,PAGE_DIR_TABLE_POS
    mov cr3,eax
    
    ;在cr0里开启分页
    mov eax,cr0
    or eax,0x80000000
    mov cr0,eax
    
    
    lgdt [gdt_ptr] 
    
    ;测试显存段能否正常工作，本质上是测试GDT能否正常工作
    mov eax,SELECTOR_VIDEO
    mov gs,eax
    mov byte [gs:160],&#39;V&#39;

    ;文件末尾，让它死循环
    jmp $  
    

setup_page:
;建立页表以及页目录   

    ;先把页目录清0
    mov esi,0
    mov ecx,4096
.clear_page_dir:   
    mov byte [PAGE_DIR_TABLE_POS+esi],0
    inc esi
    loop .clear_page_dir
                            
                            
    ;建立页目录，令页目录中的第0项和第768项指向第一个页表，令页目录中的第1023项指向自己   
    mov edx,PAGE_DIR_TABLE_POS
    or edx,PG_P|PG_RW_W|PG_US_U
    add edx,0x1000   
    
    mov [PAGE_DIR_TABLE_POS+0x00],edx
    mov [PAGE_DIR_TABLE_POS+768*4],edx
    
    sub edx,0x1000
    mov [PAGE_DIR_TABLE_POS+4092],edx  
    
    
    ;建立剩下的第769~1022一共254个页目录 
    mov edx,PG_P|PG_RW_W|PG_US_U 
    add edx,PAGE_DIR_TABLE_POS
    add edx,0x2000
    mov ecx,254    
    mov esi,769
.set_page_dir:       
    mov [PAGE_DIR_TABLE_POS+esi*4],edx
    inc esi      
    add edx,0x1000
    loop .set_page_dir 
    
    
    
    ;构建第一个页表
    mov ebx,PAGE_DIR_TABLE_POS
    add ebx,0x1000 
    xor edx,edx
    or edx,PG_P|PG_RW_W|PG_US_U   
    mov esi,0   
    mov ecx,256
.set_page_table:
    mov [ebx+esi*4],edx
    inc esi
    add edx,0x1000
    loop .set_page_table  

    ret
    
</code></pre>
<h3 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h3><ol>
<li><p>使用<code>xp &#39;内存地址&#39;</code>查看几个关键节点映射是否正确</p>
</li>
<li><p>使用<code>info gdt</code> 查看新的gdt有没有被正常装载</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img16.png" alt="img"></p>
</li>
<li><p>使用<code>info tab</code>查看映射关系</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img17.png" alt="img"></p>
<p> 我们可以从图中看出五条映射，第1条映射是 <code>虚拟空间低端1MB-&gt;PD[0]-&gt;第0张页表-&gt;物理空间低端1MB</code>，第2条映射是 <code>虚拟空间3GB之上的内核1MB-&gt;PD[768]-&gt;第0张页表-&gt;物理空间低端1MB</code>，前面这两条映射都比较好理解。第3条映射、第4条映射、第5条映射比较奇怪，如果虚地址高10位全为1，就会检索到PD[1023]。由于我们把PD[1023]指向页目录起始地址（但硬件不这么认为，硬件认为PD[1023]指向的一定是页表，硬件就把页目录当成了页表处理），就引发了这三条奇怪的映射，这三条映射也是我们通过虚拟地址访问并改变页目录页表的关键。</p>
<p> 第三条映射：虚地址高10位全为1、虚地址中10位全为0，就把PD[0]当成自己的页表项，最终指向物理页地址0x101000</p>
<p> 第五条映射：虚地址高10位全为1、虚地址中10位全为1，就把PD[1023]当成自己的页表项,最终指向物理页地址0x100000</p>
<p> 第四条映射：虚地址高10位全为1、虚地址中10位处于一定范围内，就把PD[768]~PD[1022]当成自己的页表项目，最终指向物理地址0x101000及以上空间</p>
<p> 总结出不变的规律：</p>
<ul>
<li>要获取页目录表物理地址：让虚位高20位地址全为1，低12位全为0，即0xfffff000。这就是页目录自身的起始物理地址</li>
<li>要访问页目录中的页目录项，即获取页表物理地址：使虚拟地址为0xfffffxxx,其中xxx是页目录项的索引*4</li>
<li>访问页表中的页表项:虚拟地址公式为 0x3ff&lt;&lt;22+中间10位&lt;&lt;12+低12位（中间10位是页表的索引，低12位为页表内的偏移地址）</li>
</ul>
</li>
</ol>
<h3 id="TLB更新方法"><a href="#TLB更新方法" class="headerlink" title="TLB更新方法"></a>TLB更新方法</h3><p>TLB(Translation Lookaside Buffer)用来缓冲页目录，CPU访问内存时先用虚拟地址检测TLB，如果命中则无需再去页目录查找，如果没命中则去页表查找并更新TLB，TLB结构如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img18.png" alt="img"></p>
<p>TLB对程序员不可见，但可用两种方法间接更新：</p>
<ol>
<li><p>重新加载CR3</p>
</li>
<li><p>使用指令invlpg,例如<code>invlpg [0x1234]</code>可以更新虚拟地址0x1234对应的条目</p>
</li>
</ol>
<h1 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h1><h2 id="加载内核的步骤"><a href="#加载内核的步骤" class="headerlink" title="加载内核的步骤"></a>加载内核的步骤</h2><p>我们将告别汇编，用C编写内核文件kernel.bin,用C编写将会和之前有以下区别：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img19.png" alt="img"></p>
<p>加载内核要做的事如下：</p>
<ol>
<li><p>用C编写并使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里</p>
</li>
<li><p>修改loader.S，负责把kernel.bin文件加载到合适的位置(执行完第三步kernel.bin就没用了)</p>
</li>
<li><p>修改loader.S，负责初始化内核，即通过elf头文件信息 将kernel.bin文件里的每个段分别放置在elf头文件指定位置(elf中包含头文件，我们总不能把头文件里的元信息也放置到CPU上执行，所以需要拆解)</p>
</li>
<li><p>跳转到kernel的程序入口地址，loader.S交出最后一棒接力棒</p>
</li>
</ol>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>我们要讲内核加载到内存的哪里？请看下图低端1MB内存布局里三个打勾的位置：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img33.png" alt="img"></p>
<p>三个打勾的位置将会是我们内核存放的地方（加载在0x7c00的MBR的工作已经做完了，可以被覆盖。加载在0x900的loader里面包含gdt设置，不能被覆盖），从上述加载内核的步骤看我们需要两个地方来存储内核。</p>
<p>第一个地方存储kernel.bin(对应第2步)</p>
<p>第二个地方存储被loader.S处理后的真正的内核映像文件(对应第三步)</p>
<p>kernel.bin应尽量位于高地址，给不断增长的kernel映像文件腾出空间。预计kernel.bin不会超过100kb，计划存储在0x70000（0x70000~0x9fbff有190KB）。</p>
<p>kernel被处理后的映像文件应该尽量放在低地址同时不能覆盖loader。预计loader大小不会超过2000字节,0x900+2000&#x3D;0x10d0,取一个整数为kernel的映像文件地址0x1500。</p>
<p>上述我们说的都是物理地址，由于我们开启了分页机制后，写代码时里要将物理地址转化为虚拟地址，相应的两个虚拟地址分别是0xc0070000和0xc0001500</p>
<p>在加载完内核后，我们还需要选择一个新的地方作为内核代码的栈顶，可用空间的顶部0x9fc00作为栈顶是最合适的。但是由于pcb（后面章节讲）要求4KB对齐，所以栈顶既要接近0x9fc00又要是4KB的整数倍,所以我们选择了0x9f000作为内核代码的栈顶，转化为虚拟地址即是0xc009f000</p>
<h2 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h2><h3 id="elf文件布局"><a href="#elf文件布局" class="headerlink" title="elf文件布局"></a>elf文件布局</h3><p>elf文件&#x3D;二进制可执行文件+头文件(存储元信息)</p>
<p>一个elf文件的逻辑布局如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img20.png" alt="img"></p>
<p>物理布局如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img21.png" alt="img"></p>
<p>关于这两图我们要讲几点：</p>
<ol>
<li><p>Section和Segment的区别：</p>
<p> Section是写代码时为了更清楚的逻辑划分，程序员将代码主动划分为一节一节。（汇编语言中的section、segment关键字本质上划分的都是节）</p>
<p> Segment是编译器将相同类型的Section集合在一起形成了段，如代码段、数据段。（经过编译器链接后，我们才称为段）</p>
</li>
<li><p>我们关注的重点：</p>
<p> 大部分的Section经过编译器链接后成为了Segment，我们关注的重点在Segment，我们所要做的就是根据elf头文件的指示，将每一个Segment放到它该去的地方</p>
</li>
</ol>
<h3 id="elf-header结构"><a href="#elf-header结构" class="headerlink" title="elf header结构"></a>elf header结构</h3><p>elf格式的数据类型（它们就和int、double一样，只关注字节大小就好了）</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img22.png" alt="img"></p>
<p>elf header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img23.png" alt="img"></p>
<p>elf header具体数据成员意义描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:e_phoff、e_phentisize、e_phnum）：</p>
<ol>
<li><p>e_ident</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img24.png" alt="img"></p>
</li>
<li><p>e_type</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img25.png" alt="img"></p>
</li>
<li><p>e_machine</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img26.png" alt="img"></p>
</li>
<li><p>others</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img27.png" alt="img"></p>
</li>
</ol>
<h3 id="program-table-header结构"><a href="#program-table-header结构" class="headerlink" title="program table header结构"></a>program table header结构</h3><p>program table header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img28.png" alt="img"></p>
<p>program table header的成员描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:p_offset、p_vaddr、p_mensz）：</p>
<ol>
<li><p>p_type<br> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img29.png" alt="img"></p>
</li>
<li><p>p_flags<br> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img30.png" alt="img"></p>
</li>
<li><p>others<br> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img31.png" alt="img"></p>
</li>
</ol>
<p>实例：请参照<code>操作系统真相象还原</code>P218-5.3.4；我们可以使用命令<code>readelf -e &#39;文件名&#39;</code>来查看一个elf文件的头的具体数据,也可以使用<code>hd &#39;文件名&#39;</code>来查看一个elf文件的十六进制形式</p>
<h2 id="代码实战-1"><a href="#代码实战-1" class="headerlink" title="代码实战"></a>代码实战</h2><ol>
<li><p>用C编写main.c文件，然后并使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里</p>
<ul>
<li><p>main.c：</p>
<p>  int main(void){<br>  while(1);<br>  return 0;<br>  }</p>
</li>
<li><p>使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里：</p>
<pre><code>  gcc -m32 -c -o kernel/main.o kernel/main.c
  ;注意要编译成32位文件才能兼容
  ld -m elf_i386 kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin 
  # ld是链接程序，-Ttext指定起始的虚拟地址,为什么是0xc0001500后面详细说明，-e是指定程序入口地址(main符号代表main函数的起始地址)
  dd if=/home/sparkle2/codeset/kernel/kernel.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=200 seek=9 conv=notrunc
  # 内核程序预计不会超过100KB，于是一次性给它分配200个扇区的磁盘空间。存入磁盘号为9号，和loader程序之间腾出一些间隔
  # 现在磁盘hd60M.img的分布如下：0号扇区留给MBR  2~5号扇区位置留给loader 9~208号扇区位置留给kernel
</code></pre>
</li>
</ul>
</li>
<li><p>boot.inc添加加载内核相关宏</p>
<pre><code> ;--------------loader----------------

 LOADER_BASE_ADDR equ 0x900
 ;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
 ;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
 ;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

 LOADER_START_SECTOR equ 0x2
 ;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
 ;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区   

 ;--------------loader----------------



 ;--------------kernel----------------

 KERNEL_BIN_BASE_ADDR equ 0x70000 
 ;kernel.bin应尽量位于可用空间的高地址，给不断增长的kernel映像文件腾出空间。预计kernel.bin不会超过100kb，计划存储在0x70000

 KERNEL_BIN_START_SECTOR equ 0x9  
 PT_NULL equ 0 

 KERNEL_ENTER_ADDR equ 0xc0001500

 ;--------------kernel----------------




 ;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------
 ;为了方便我们将64位的gdt描述符分为高32位和低32位来定义，下面代码定义的都是低32位


 ;二进制数据中间的&#39;_&#39;符号没有任何意义，仅仅只是为了让程序员看得更清楚，编译器会自动忽略
 ;命名中的DESC是描述的意思
 DESC_G_4K equ 1_00000000000000000000000b ;第23位G 表示4K或者1MB位 段界限的单位值 此时为1则为4k 
 DESC_D_32 equ 1_0000000000000000000000b  ;第22位D/B位 表示地址值用32位EIP寄存器 操作数与指令码32位
 DESC_L    equ 0_000000000000000000000b   ;第21位 设置成0表示32位代码段而非64位代码段
 DESC_AVL  equ 0_00000000000000000000b    ;第20位 CPU不用此位设置为0


 ;LIMIT代表段界限，我们打算在GPT里加入三个段：代码段、数据段、显存段(就是将之前显存的位置单独划分一个成一个段)
 ;我们对4GB的内存空间采用平坦模式，也就是说基址=0，偏移量最大范围=4GB（除了显存段外，显存段任然放置在0xB8000~0xBFFFF）
 ;DESC_LIMIT_CODE2代表定义代码段的段界限(第二部分)
 DESC_LIMIT_CODE2  equ  1111_0000000000000000b   ;平坦模型要满足最大段界限*粒度=4GB，换算可知段界限必须为0xFFFFF,也就是全为1
 DESC_LIMIT_DATA2  equ  DESC_LIMIT_CODE2         ;相同的值  数据段与代码段段界限相同
 DESC_LIMIT_VIDEO2 equ	0000_0000000000000000b	;第16-19位 显存段任然放置在0xB8000~0xBFFFF，段基址应该为0xbffff,
                                                 ;段界限应该为(0xbffff-0xb8000)/4k=7(高4位为0)


 DESC_P            equ 	1_000000000000000b	  
 DESC_DPL_0        equ  00_0000000000000b         
 DESC_DPL_1        equ  01_0000000000000b	  
 DESC_DPL_2        equ  10_0000000000000b
 DESC_DPL_3        equ  11_0000000000000b
 DESC_S_sys        equ  0_000000000000b           
 DESC_S_CODE       equ  1_000000000000b        
 DESC_S_DATA       equ  DESC_S_CODE


 ;这边存在一个问题，根据书本上的Type格式图里从3~0位数据段的排序应该是xwea，而代码部分则按照xewa的顺序，需要进一步确认
 DESC_TYPE_CODE    equ  1000_00000000b            ;第9-11位表示该段状态 1000 可执行 不允许可读 已访问位0
 ;x=1 e=0 w=0 a=0
 DESC_TYPE_DATA    equ  0010_00000000b            ;第9-11位type段   0010  可写  
 ;x=0 e=0 w=1 a=0



 ;代码段描述符高位4字节初始化 (0x00共8位 &lt;&lt;24 共32位初始化0) 
 ;4KB为单位 Data段32位操作数 初始化的部分段界限 最高权限操作系统代码段 P存在表示 状态 
 DESC_CODE_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
 DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \
 DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00

 ;数据段描述符高位4字节初始化
 DESC_DATA_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
 DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \
 DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00

 ;显存段描述符高位4字节初始ua
 DESC_VIDEO_HIGH4   equ (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
 DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \
 DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B  ;书本上末尾是0，但显存段段基址应该为0xbffff，也就是说这边末尾应该是B 

 ;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------







 ;-------------------- 选择GDTR子属性 --------------------------------
 RPL0    equ 00b
 RPL1    equ 01b
 RPL2    equ 10b
 RPL3    equ 11b
 TI_GDT  equ 000b
 TI_LDT  equ 100b

 ;-------------------- 选择GDTR子属性 --------------------------------

     
     
     
 ;-----------------------页目录和页表属性---------------------------------------     
 PAGE_DIR_TABLE_POS equ 0x100000

 PG_P    equ 1b
 PG_RW_R equ 00b
 PG_RW_W equ 10b
 PG_US_S equ 000b
 PG_US_U equ 100b     

 ;-----------------------页目录和页表属性---------------------------------------
</code></pre>
</li>
<li><p>loader.S添加加载内核部分代码</p>
<pre><code> ;loader.S 负责完成构建页表、页目录、以及启动分页机制
 %include &quot;boot.inc&quot;
 SECTION loader vstart=LOADER_BASE_ADDR
 LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
 jmp loader_start                      		   ;跳跃到代码区


     ;构建gpt及其内部的描述符
     ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
     ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
     GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                 dd 0x00000000 

     CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                 dd DESC_CODE_HIGH4

     ;这边数据段和栈段共用一个段
     ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
     ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
     ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
     ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
     DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                         dd DESC_DATA_HIGH4

     VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                 dd DESC_VIDEO_HIGH4     	  
                     
     GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
     GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

     times 60 dq 0                              ;预留60个 四字型 描述符
     
     ;gdt指针
     gdt_ptr         dw GDT_LIMIT
                     dd GDT_BASE  
     
     ;构造16位的段选择子
     SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
     SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
     SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0  
     
     
 loader_start:   
 ; --------------------------------- 设置进入保护模式 -------------------------------------
     ; 1 打开A20 gate 
     in al,0x92                
     or al,0000_0010b
     out 0x92,al

     ; 2 加载gdt
     lgdt [gdt_ptr] 

     ; 3 将cr0 的 pe位置1
     mov eax,cr0                
     or  eax,0x00000001              
     mov cr0,eax
     
 ;-------------------------------- 设置进入保护模式 ---------------------------------------
     jmp dword SELECTOR_CODE:p_mode_start                       
     ;前面是16位指令，后面是32位指令，CPU由于流水线技术无法直接处理混合在一起的二者，利用无转跳指令刷新一下流水线即可
     ;dword指定访问数据为32位，进入了保护模式后，操作数变为32位，这里声明选择子和偏移量都是32位操作数


 [bits 32]
 p_mode_start: 
     ;初始化段选择子
     mov ax,SELECTOR_DATA
     mov ds,ax
     mov es,ax
     mov ss,ax
     mov esp,LOADER_STACK_TOP
     mov ax,SELECTOR_VIDEO
     mov gs,ax
     
     ;测试显存段
     mov byte [gs:0],&#39;P&#39; 
     
     ;开始构建页表以及页目录
     call setup_page    
     
     ;在保护模式打开前加载kernel到内存合适位置
     call kernel_load

 ; --------------------------------- 重新装载gdt并开启分页机制 -------------------------------------

     ;如果我们开启了分页机制，所有线性地址都将变成虚拟地址，为了保证gdt能正常运作，我们需要在它的线性基址上+0xc0000000(也就是上升到3GB以上的1MB内核空间)
     ;3GB以上的1MB内核空间会映射回原来的低端1MB物理地址，保证代码正常运行
     ;sgdt将GDTR里面的内容取出到gdt_ptr
     sgdt [gdt_ptr]
     
     ;将显存段的位置移动到内核中
     mov ebx,[gdt_ptr+2]
     or dword [ebx+0x18+4],0xc0000000
     
     ;修改gdt_base的位置
     add dword [gdt_ptr+2],0xc0000000

     ;修改栈顶指针位置
     add esp,0xc0000000
     
     ;向cr3传入页目录地址
     mov eax,PAGE_DIR_TABLE_POS
     mov cr3,eax
     
     ;在cr0里开启分页
     mov eax,cr0
     or eax,0x80000000
     mov cr0,eax
     
     
     lgdt [gdt_ptr] 
     
     ;测试显存段能否正常工作，本质上是测试GDT能否正常工作
     mov eax,SELECTOR_VIDEO
     mov gs,eax
     mov byte [gs:160],&#39;V&#39;   

 ; --------------------------------- 重新装载gdt并开启分页机制 ------------------------------------- 

         
         
 
 ;------------------------------ 刷新流水线并，进入内核-----------------------------------    
     jmp SELECTOR_CODE:enter_kernel
 enter_kernel:
     call kernel_init					          
     mov  esp,0xc009f000          
     ;可用空间的顶部0x9fc00作为栈顶是最合适的。
     ;但是由于pcb（后面章节讲）要求4KB对齐，所以栈顶既要接近0x9fc00又要是4KB的整数倍,
     ;所以我们选择了0x9f000作为内核代码的栈顶
     ;转化为虚拟地址即是0xc009f000
     jmp  KERNEL_ENTER_ADDR  ;跳转到程序入口地址，将接力棒交给kernel

 ;------------------------------ 刷新流水线并，进入内核-----------------------------------   


 


 ; ---------------------------------加载kernel.bin到合适位置 ------------------------------------- 
 kernel_load:
     mov eax, KERNEL_BIN_START_SECTOR
     mov ebx, KERNEL_BIN_BASE_ADDR
     
     mov cx,200
     call rd_disk_m_32 
     ret 
 ; ---------------------------------加载kernel.bin到合适位置 ------------------------------------- 

         
         
         
         
         
 ; ---------------------------------实现kernel的初始化 ------------------------------------- 
 kernel_init:
     xor eax,eax
     xor ebx,ebx     ;记录program header table地址
     xor ecx,ecx     ;记录program header table中他program header的数量
     xor edx,edx     ;记录program header尺寸，即e_phentsize
     
     mov dx,[KERNEL_BIN_BASE_ADDR+42]    ;kernel.bin偏移文件42字节处是e_phentsize
     mov ebx,[KERNEL_BIN_BASE_ADDR+28]   ;kernel.bin偏移文件28字节处是e_phoff
     add ebx,KERNEL_BIN_BASE_ADDR        
     mov cx,[KERNEL_BIN_BASE_ADDR+44]    ;kernel.bin偏移文件44字节处是e_phnum  
     
 .each_segment:       
     cmp byte [ebx+0],PT_NULL            ;[ebx+0]指向program_header的p_type
     je .PTNULL 
     
     ;为函数mem_cpy压入参数
     push dword [ebx+16]                 ;[ebx+16]指向program_header的p_filesz
     mov eax,[ebx+4]                     ;[ebx+4]指向program_header的p_offset
     add eax,KERNEL_BIN_BASE_ADDR
     push eax
     push dword [ebx+8]                  ;[ebx+8]指向program_header的p_vaddr
     
     call mem_cpy
     add esp,12                          ;清理栈中的三个参数
     

     
 .PTNULL:
     add ebx,edx
     loop .each_segment 
             
     ret
 ; ---------------------------------实现kernel的初始化 -------------------------------------   



 ; ---------------------------------mem_cpy(dst,src,size) 逐字节拷贝函数 -------------------------------------  
 mem_cpy:
     cld     ;设置movsb增长方向
     push ebp
     mov ebp,esp
     push ecx
     
     mov edi,[ebp+8]    ;dst
     mov esi,[ebp+12]   ;src
     mov ecx,[ebp+16]   ;size
     
     rep movsb          ;逐字节拷贝 
     
     pop ecx
     pop ebp
     ret

 ; ---------------------------------mem_cpy(dst,src,size) 逐字节拷贝函数 ------------------------------------- 
             
     
             
             
             
 ;------------------------ rd_disk_m_32------------------------------- ----------------------

 rd_disk_m_32: 
 ;调用rd_disk_m_32时利用32位寄存器传入参数
 ;eax记录LBA28
 ;ebx记录目标地址
 ;cx记录要移动的扇区数   
 ;实现从磁盘LBA28地址eax处赋值cx磁盘数据到ebx目标地址处

     mov esi,eax                 ;ax会在后续in/out指令被使用，所以备份参数
     mov di,cx                   ;di会在后续循环中被用到，所以备份参数


     ;第一步：先选择通道，往该通道的sector cout寄存器写入待操作的扇区数
     mov ax,di
     mov dx,0x1f2
     out dx,al

     mov eax,esi                  ;复原eax


     ;第二步往通道上的三个LBA写入扇区地址LBA28的低24位
     mov dx,0x1f3
     out dx,al

     mov cl,8
     shr eax,cl       
     mov dx,0x1f4     
     out dx,al

     shr eax,cl
     mov dx,0x1f5
     out dx,al

     
     ;第三步 往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式
     shr eax,cl
     and al,0x0f
     or al,0xe0
     mov dx,0x1f6
     out dx,al


     ;第四步往该通道的command寄存器写入命令（一旦写入立即执行）
     mov dx,0x1f7
     mov al,0x20
     out dx,al


     ;第五步读取status寄存器，判断硬盘工作是否完成(这边采用查询传输的方式)
 .not_ready:
     nop            ;增加循环查询的延迟
     in al,dx
     and al,0x88
     cmp al,0x08
     jnz .not_ready


     ;最后一步将硬盘数据读出
     mov ax,di
     mov dx,256
     mul dx
     mov cx,ax
     ;一个扇区512字节，要读取di个扇区，每次读取2字节(16位的data寄存器),一共要循环读取di*512/2次

     mov dx,0x1f0
 .go_on_read:
     in ax,dx
     mov [ebx],ax
     add ebx,2
     loop .go_on_read

     ;函数loader_ready_proc结束返回
     ret
         
 ;------------------------ rd_disk_m_32---------------------------------------------------

 


 ; ---------------------------------创建页目录和页表-函数 -------------------------------------
 setup_page:
 ;建立页表以及页目录   

     ;先把页目录清0
     mov esi,0
     mov ecx,4096
 .clear_page_dir:   
     mov byte [PAGE_DIR_TABLE_POS+esi],0
     inc esi
     loop .clear_page_dir
                             
                             
     ;建立页目录，令页目录中的第0项和第768项指向第一个页表，令页目录中的第1023项指向自己   
     mov edx,PAGE_DIR_TABLE_POS
     or edx,PG_P|PG_RW_W|PG_US_U
     add edx,0x1000   
     
     mov [PAGE_DIR_TABLE_POS+0x00],edx
     mov [PAGE_DIR_TABLE_POS+768*4],edx
     
     sub edx,0x1000
     mov [PAGE_DIR_TABLE_POS+4092],edx  
     
     
     ;建立剩下的第769~1022一共254个页目录 
     mov edx,PG_P|PG_RW_W|PG_US_U 
     add edx,PAGE_DIR_TABLE_POS
     add edx,0x2000
     mov ecx,254    
     mov esi,769
 .set_page_dir:       
     mov [PAGE_DIR_TABLE_POS+esi*4],edx
     inc esi      
     add edx,0x1000
     loop .set_page_dir 
     
     
     
     ;构建第一个页表
     mov ebx,PAGE_DIR_TABLE_POS
     add ebx,0x1000 
     xor edx,edx
     or edx,PG_P|PG_RW_W|PG_US_U   
     mov esi,0   
     mov ecx,256
 .set_page_table:
     mov [ebx+esi*4],edx
     inc esi
     add edx,0x1000
     loop .set_page_table  

     ret
 ;---------------------------------创建页目录和页表-函数 -------------------------------------
</code></pre>
</li>
</ol>
<h1 id="特权级：DPL、CPL、RPL"><a href="#特权级：DPL、CPL、RPL" class="headerlink" title="特权级：DPL、CPL、RPL"></a>特权级：DPL、CPL、RPL</h1><p>RPL是选择子上的特权级，DPL是段描述符上的特权级，CPL表示当前访问者(CPU)的特权级</p>
<p>特权世界有几条基本法则:</p>
<ol>
<li><p>CPL恒等于CS.RPL（代码段选择子上的RPL）</p>
</li>
<li><p>唯一一种特权级会从高到低的方式:从中断中返回</p>
</li>
<li><p>CPU从当前代码段跳转到目标代码段时:new_CPL&#x3D;目标代码段的DPL(一致性代码段除外)</p>
</li>
<li><p>特权级的检测只在你打算访问某个地方时检测一次</p>
</li>
</ol>
<h2 id="没有RPL的世界"><a href="#没有RPL的世界" class="headerlink" title="没有RPL的世界"></a>没有RPL的世界</h2><p>为了理解这三者，我们要做的第一件事就是忽视RPL(除了CS.RPL,它是特别的，我们以后就叫它CPL了)，脑子里只剩下CPL和DPL</p>
<p>CPL表示当前访问者(CPU)的特权级，DPL表示被访问段(代码段&#x2F;数据段&#x2F;栈段)的特权级，二者之间有如下关系：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img35.png" alt="img"></p>
<p><strong>PS：为什么一致性代码段要求CPL&gt;&#x3D;DPL，假想一下，如果你权力比我还大你干嘛还来求我办事？所以一致性代码段限制了只有权力小的人才可以来求权力大的人办事</strong></p>
<p>从图中可以看出特权世界的基本运行规则，我们发现农民的局限性太大了，哪怕有哪个地主愿意帮农民办事也得继续用农民的身份（这样他就同样无法行使地主特权）</p>
<h2 id="没有RPL世界，但是有了调用门"><a href="#没有RPL世界，但是有了调用门" class="headerlink" title="没有RPL世界，但是有了调用门"></a>没有RPL世界，但是有了调用门</h2><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img36.png" alt="img"></p>
<p>可以看出，调用门真正提供了一个渠道允许农民行地主之事(虽然不是所有农民都行)</p>
<p>例子：假设当前特权级是3，也就是说CPL&#x3D;3。当前代码(CPU&#x2F;访问者)想要访问内存里的一个目标段，目标段的DPL&#x3D;0。很明显CPL&gt;DPL,当前代码没有这个权力。它只能<code>call 调用门选择子</code>。我们跟着调用们选择子找到了调用门描述符（DPL&#x3D;3），也找到了被调用代码的描述符（DPL&#x3D;0）。首先进行一次特权级检测：调用门描述符（DPL&#x3D;3）&gt;&#x3D;CPL&gt;&#x3D;被调用代码的描述符（DPL&#x3D;0），允许使用该调用门。于是从当前代码段转跳到被调用代码段（new_CPL&#x3D;被调用代码段.DPL），同样被传到被调用代码段的还有之前代码段压入栈的参数，被调用代码段因为有着CPL&#x3D;0的特权级所以可以拿着参数做任意事情了。一切结束后会引发中断返回，CPL重新&#x3D;3</p>
<h2 id="调用门引发的危险"><a href="#调用门引发的危险" class="headerlink" title="调用门引发的危险"></a>调用门引发的危险</h2><p>假设当前代码段(CPL&#x3D;3)想要读取一个目标段(DPL&#x3D;0)的内容到自己的缓冲区(DPL&#x3D;3)。有一个当前代码段可以使用调用门，该调用门可以传入一个表示缓冲区地址的参数(用压栈方式)，如果成功调用了调用门，被调用的代码段(CPL&#x3D;0)就会把目标段(DPL&#x3D;0)的内容放入到参数指示的缓冲区(DPL&#x3D;3)。</p>
<p>上述的一切看上去都很和谐，就下图左边的情况：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img37.png" alt="img"></p>
<p>但如果当前代码段不怀好意，它故意把缓冲区指针指向了操作系统内核段(DPL&#x3D;0)，就会发生上图右边的情况。被调用代码凭着CPL&#x3D;0任意修改DPL&#x3D;0的操作系统内核段，导致操作系统内核段被破坏。问题的关键出在：DPL&#x3D;0的段无条件信任所有CPL&#x3D;0的代码，CPL&#x3D;0的代码当然不会主动去伤害DPL&#x3D;0的段，但没想到过CPL&#x3D;0的代码会没脑子的帮CPL&#x3D;3的代码做事。</p>
<p>因此，DPL&#x3D;0的段说我们不能在无条件的信任你了，我们必须增加一个条件来判断你是不是在帮别人做事，这个条件就是RPL</p>
<h2 id="RPL解决调用门危机"><a href="#RPL解决调用门危机" class="headerlink" title="RPL解决调用门危机"></a>RPL解决调用门危机</h2><p>先来看看引入了RPL后特权世界的基本规则变成什么样了：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img38.png" alt="img"></p>
<p>仔细分辨，你会发现未曾使用调用门的情况下，因为OS会进行赋值操作使RPL&#x3D;CPL，所以不论对谁都没有影响，和没有RPL世界的运行规律是一样的。</p>
<p>当有了RPL运行规律就不一样了,请看一下例子：</p>
<p>假设当前代码段(CPL&#x3D;3)想要读取一个目标段(DPL&#x3D;0)的内容到自己的缓冲区(DPL&#x3D;3)。有一个当前代码段可以使用调用门，该调用门可以传入一个表示缓冲区地址的参数(用压栈方式)，如果成功调用了调用门，被调用的代码段(CPL&#x3D;0)就会把目标段(DPL&#x3D;0)的内容放入到参数指示的缓冲区(DPL&#x3D;3)。</p>
<p>当前代码段使用<code>call 调用门选择子</code>时，OS会为其构造一个调用门选择子（RPL&#x3D;CPL&#x3D;3）。然后触发特权检测,<code>调用门描述符（DPL=3）&gt;=CPL=RPL&gt;=被调用代码的描述符（DPL=0）</code>运行该代码段使用调用门。在使用调用门前当前代码段需要压入一个指向缓冲区的参数，此时OS会为该参数构造一个指向缓冲区的选择子(RPL&#x3D;CPL&#x3D;3)。进入被调用代码段(new_CPL&#x3D;被调用代码的描述符的DPL&#x3D;0)，拿到参数后开始访问参数指向的地址（使用该参数的选择子）。这时又触发特权检测，如果缓冲区DPL&#x3D;3(也就是正常情况下，程序安分守己)，MAX(CPL,RPL)&#x3D;3&lt;&#x3D;DPL，代码正常运行。如果缓冲区的DPL&#x3D;0(也就是程序不安好心),MAX(CPL,RPL)&#x3D;3&gt;DPL,代码停止。</p>
<p>RPL完美解决了上述的调用门危机，现在的特权世界是这么一种情况：地主可以自由控制地主&#x2F;农民的地盘，农民只能自由控制农民的地盘，地主可以用地主的资源来帮农民打造(或毁坏)农民的地盘，决不允许地主帮农民打造(或毁坏)地主的地盘</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>画了一张图代表从第一章到第五章我们做的事，如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89/img34.png" alt="img"></p>

      </div>
      
      
      
    </div>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
