<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sparkle&#39;s Space">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sparkle's Space</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/10/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-10 13:28:18" itemprop="dateCreated datePublished" datetime="2023-11-10T13:28:18+08:00">2023-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-11 13:49:29" itemprop="dateModified" datetime="2023-11-11T13:49:29+08:00">2023-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们将在上一章节的基础上完善MBR,学会使用IO接口的两种方法</p>
<p>相应的本章一共要完成两个实验：一个是MBR使用显存和显卡沟通，另一个是MBR通过端口将磁盘上的loader程序加载到内存相应位置</p>
<h1 id="地址、section和vstart"><a href="#地址、section和vstart" class="headerlink" title="地址、section和vstart"></a>地址、section和vstart</h1><ol>
<li><p>地址</p>
<p> 地址只是数字，描述各种符号在源程序中的位置，它是源代码文件中符号<strong>偏移</strong>文件开头的位置。编译器的工作就是给代码里的各符号编址。</p>
<p> 下图给出了一个程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img1.png" alt="img"></p>
<p> 仔细观察图片可得到这样一种关系：地址&#x3D;上一个地址+上一个地址内容的长度</p>
<p> 于是我们得出一个关于地址的结论：编译器给程序中各符号（变量名或函数名）分配的地址就是各符号相对于文件开头的<strong>偏移量</strong></p>
</li>
<li><p>section</p>
<p> 编译器提供section关键字（伪指令）是为了让程序员在逻辑上将程序划分为几个部分。一般section的应用场景就是根据不同的属性人为地讲程序划分几部分，如数据放在一个section中，指令放在另一个section中。</p>
<p> 下图给出了一个包含section分段程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img2.png" alt="img"></p>
<p> <strong>PS：程序第三行地section.data.start代表地是名为data的section在本文件中相对于文件开头的偏移量</strong></p>
<p> 仔细观察图片我们得出结论：关键字section并没有对程序中的地址产生任何影响，seciton仅仅是为了让开发人员梳理程序之用。</p>
</li>
<li><p>vstart：</p>
<p> vstart的作用是为section内的数据指定一个虚拟的起始地址。</p>
<p> 下图给出了一个包含vstart修饰section分段程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img3.png" alt="img"></p>
<p> 仔细观察图片，首先我们确定vstart对数据本身在文件的真实物理地址没有任何影响。</p>
<p> 那vstart影响的是什么? vstart影响的是虚拟段基址的值。在没有vstart的情况下，每个段的虚拟段基址默认是上一个段的结尾（首段虚拟段基址默认为0）；有了vstart后，就人为规定了虚拟的段基址。</p>
<p> vstart的使用时机：我们预先知道我们的程序将来被加载到某地址。</p>
<p> <strong>PS：vstart&#x3D;xxxx，并不是告诉编译器要把程序加载到地址xxxx，而是开发人员事先知道这段程序会被加载到xxxx，为了保证程序后续地址（相对文件开头地址的偏移量）的正确性，我们使用vstart提前告诉编译器：这个文件数据的相对地址不再是相对于上一个段末尾或者0了，而是要相对于xxxx，编译器编译时就会计算<code>xxxx+地址（相对文件开头地址的偏移量）</code>得到正确地址</strong></p>
</li>
</ol>
<h1 id="CPU的实模式"><a href="#CPU的实模式" class="headerlink" title="CPU的实模式"></a>CPU的实模式</h1><p>实模式是指8086CPU的工作环境、工作内容、工作状态一整套内容（寻址方式、寄存器大小、指令用法等），而不是单一某个方面的内容。</p>
<p>实模式的特点如下：</p>
<ol>
<li><p>CPU只能寻址1MB的物理内存，因为它只有20位地址线</p>
</li>
<li><p>实模式下操作系统和应用程序的执行权限都一样，没有任何保护；实模式下应用程序也可随意修改操作系统的内存（当然这是不安全的）</p>
</li>
<li><p>实模式中CPU使用分段的内存管理模式，即<code>物理地址=段基址&lt;&lt;4+段内偏移</code>，实模式中的逻辑地址就是物理地址，没有虚拟地址一说。</p>
</li>
<li><p>实模式中CPU使用中断向量表来响应中断</p>
</li>
<li><p>实模式下所有寄存器都是16位</p>
</li>
<li><p>实模式的寻址方式可分为三大类寄存器寻址、立即数寻址、内存寻址；其中内存寻址又可以分为直接寻址、基址寻址、变址寻址、基址变址寻址</p>
</li>
</ol>
<p>总而言之：你在汇编语言中接触到的相关知识，基本就是实模式下的相关知识。建议学习<code>王爽的《汇编语言》</code></p>
<h1 id="改进MBR：通过显存与显卡沟通"><a href="#改进MBR：通过显存与显卡沟通" class="headerlink" title="改进MBR：通过显存与显卡沟通"></a>改进MBR：通过显存与显卡沟通</h1><p>上一章节中我们的MBR是通过BIOS提供的中断例程实现的，BIOS提供的中断例程利用了只有在实模式下才可使用的中断向量表，由于我们进入保护模式后无法调用BIOS提供的中断例程，所以我们必须学会直接显卡沟通。</p>
<ol>
<li><p>CPU如何与外设通信？</p>
<p> CPU与外设的通信采用：<code>CPU——IO接口——外设</code>的形式。不同外设有不同的协议、不同的规则、不同的速度等，CPU无需关心这些，由IO接口来负责二者之间的沟通交流，CPU只需要知道怎样和IO接口沟通就行，如图式结构：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img4.png" alt="img"></p>
<p> <strong>PS：南桥芯片又叫输入输出控制中心，用于连接一些低速设备，可以把它看作是IO接口的集合管理中心</strong></p>
</li>
<li><p>CPU如何与IO接口通信？</p>
<p> IO接口可以提供两种方式与CPU沟通，一种是IO内存、另一种是IO端口。</p>
<p> IO内存是将外设的寄存器映射到CPU的地址空间中，使得CPU可以用内存访问指令来访问外设，如同访问内存一样。此时写入特定位置的内存，就相当于写入外设的寄存器里。</p>
<p> IO端口是将外设的寄存器分配一个唯一的地址，使得CPU可以用专门的<code>in/out</code>(输入输出指令)来访问外设。</p>
</li>
<li><p>CPU使用IO内存与显卡沟通</p>
<p> 显存是显卡中的一块内存，显卡所做的工作就是不断将显存里的数据放到显示器上。</p>
<p> 显存被映射到CPU的内存中的地址如下：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img5.png" alt="img"></p>
<p> 我们只需要往<code>0xB80000~0xBFFFF</code>32KB大的显存映射范围内里写入数据，就可以实现直接让数据显示到显示屏上。</p>
<p> 显卡在加电后，屏幕默认输出格式是80*25，也就是一屏幕共可以输出2000个字符。其中每个字符需要两字节表示，低位字节代表字符的ASCII码，高位字节代表字符的属性信息。32KB&#x2F;4000Byte约等于8屏幕数据，也就是说显存一次输出可以输出8个屏幕的数据。</p>
<pre><code> ; 修改后的MBR代码如下：实现直接与显卡沟通在屏幕上打印字符

 SECTION MBR vstart=0x7c00
     ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

     mov ax,cs
     mov ds,ax
     mov es,ax
     mov ss,ax
     mov fs,ax
     ;利用CS=0初始化各个段寄存器
     mov sp,0x7c00
     ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

     mov ax,0xb800;
     mov gs,ax
     ;令附加段基址寄存器gs指向显存映射地址

 ;------------------------------------------------------------------------------------------
     ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

     mov ax,0x600
     mov bx,0x700
     mov cx,0
     mov dx,0x184f

     int 0x10

 ;------------------------------------------------------------------------------------------
     ;以下代码直接向显存输入数据，实现打印输出背景色绿色，前景色红色，并且跳动的字符串&#39;1 MBR&#39;

     mov byte [gs:0x00],&#39;1&#39;
     mov byte [gs:0x01],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x02],&#39; &#39;
     mov byte [gs:0x03],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x04],&#39;M&#39;
     mov byte [gs:0x05],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x06],&#39;B&#39;
     mov byte [gs:0x07],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x08],&#39;R&#39;
     mov byte [gs:0x09],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

 ;------------------------------------------------------------------------------------------

     jmp $ ;实现死循环，让程序悬停

     times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
     db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
</li>
</ol>
<h1 id="bochs的调试方法-插曲"><a href="#bochs的调试方法-插曲" class="headerlink" title="bochs的调试方法(插曲)"></a>bochs的调试方法(插曲)</h1><p>请运行bochs后，输入<code>help</code>，即可看到bochs相关的所有调试指令</p>
<p>指令大概分为四类：Debugger control、Execution control、Breakpoint control、CPU and memory contents</p>
<p>针对大类里的每一个指令，都可以输出<code>help &#39;指令关键字&#39;</code>来查看该指令的具体用法</p>
<p>不需要对每个指令死记硬背，多多尝试就熟悉了</p>
<h1 id="改进MBR：与磁盘沟通"><a href="#改进MBR：与磁盘沟通" class="headerlink" title="改进MBR：与磁盘沟通"></a>改进MBR：与磁盘沟通</h1><ol>
<li><p>in&#x2F;out 命令</p>
<p> CPU提供了专门的指令来和IO接口进行端口沟通：</p>
<ul>
<li><p>in指令用于从端口中读取数据，格式如下：</p>
<pre><code>  in al,dx
  in ax,dx
</code></pre>
<p>  只要使用in指令，源操作数必须是dx(存放端口号)，而目的操作数是用al，还是ax取决于dx端口指代的寄存器是8位宽还是16位宽</p>
</li>
<li><p>out 指令用于往端口中写数据，格式如下：</p>
<pre><code>  out dx,al
  out dx,ax
  out 立即数,al
  out 立即数,ax
</code></pre>
<p>  out指令的源操作数是ax还是al取决于目标端口指代的寄存器是8位宽还是16位宽，源操作数可以是立即数直接给出端口号，也可以用dx（存放端口号）</p>
</li>
</ul>
</li>
<li><p>磁盘IO端口相关知识</p>
<ul>
<li><p>什么是硬盘控制器？</p>
<p>  硬盘控制器是CPU于硬盘沟通中间的IO接口</p>
</li>
<li><p>Primary通道和Secondary通道</p>
<p>  以前的主机一般只接受四个并口磁盘。主板上提供了两个IDE（Integrated Drive Electronics，硬盘控制器和硬盘集成在一起的集成设备电路）插槽。用Primary通道和Secondary通道来区分这两个不同的IDE，用于连接硬盘和主板。每个通道可以挂载两个硬盘，分别称为主盘（Master）和从盘（Slave）。主盘和从盘的区别主要是在启动顺序和数据传输上，一般来说，主盘优先于从盘启动，而从盘的数据传输需要经过主盘。每个通道都有自己的一组端口寄存器，用于控制和访问硬盘。</p>
<p>  当然上面的描述是以前主机的硬盘布局，现在的大有不同了，但我们学习使用较为简单的以前主机的IO接口相关知识。</p>
</li>
<li><p>LBA和CHS</p>
<p>  一个磁盘里有很多个扇区，要描述一个扇区的具体位置可以通过多种方法。</p>
<p>  一般口头上描述扇区的位置可以用“柱面-磁头-扇区”来定位（Cylinder Head Sector），简称为CHS。CHS描述法的扇区并非是从0开始的，而是从1开始的。</p>
<p>  CHS描述是从物理结构上来描述的，但我们希望在编程时可以不用考虑磁盘的物理结构，只需要通过逻辑结构来定位扇区就行了，于是有了LBA（Logical Block Address）</p>
<p>  LBA有LBA28和LBA48两种。我们只介绍LBA28：就是通过28位bit来描述一个扇区的位置，最大的寻址范围是2^28。</p>
<p>  向磁盘沟通时，端口寄存器必须要知道你是向哪一块磁盘沟通，也就是说知道LBA28。我们用3个8位寄存器（LBA low、LBA mid、LBA high）以及device寄存器其中的4位一共28位表示LBA28</p>
</li>
<li><p>硬盘控制器主要端口寄存器</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img6.png" alt="img"></p>
<ul>
<li><p>我们在与磁盘沟通时，首先要确认我们是与哪一个通道的主盘&#x2F;从盘沟通，然后查看这张表中对应的端口号，以Primary通道为例：</p>
</li>
<li><p>0x1F3、0x1F4、0x1F5三个端口号不论是读操作还是写操作时都是用来记录LBA28低24位的地址的（标记你是与那一块扇区沟通）</p>
</li>
<li><p>0x1F0 端口号映射Data寄存器，写操作时，从外面往里面写数据进去；读操作时，从里面往外读数据出来。<strong>该端口是这里唯一的16位寄存器，其余端口都是8位</strong></p>
</li>
<li><p>0x1F1 读操作时用于存放失败状态信息，写操作时用于存放写操作参数</p>
</li>
<li><p>0x1F2 读操作时用于存放要读取的扇区数，写操作是用于存放要写入的扇区数</p>
</li>
<li><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img7.png" alt="img"></p>
<p>  0x1F6 读写时都是device寄存器，也就是驱动器，具体功能见上图：0~3位放置LBA28的高4位，4位指定是主盘还是从盘，5~7位指定寻址模式（CHS为101，LBA为111）</p>
<p>  0x1F7 写操作时用于写入命令，一旦写入命令磁盘立即指向，主要有三个命令(1) 0xEC，硬盘识别 （2）0x20，读扇区 （3）0x30，写扇区。读操作时则是statue寄存器，具体功能见上图</p>
</li>
</ul>
</li>
<li><p>约定好的IO端口沟通操作顺序</p>
<p>  了解了这些寄存器的功能后我们就可以知道如何与磁盘进行沟通了，但第一步我们先约定一个操作执行顺序，确保大家不会乱（当然你不按照这个顺序也行）：</p>
<ol>
<li><p>先选择通道，往该通道的sector cout寄存器写入待操作的扇区数</p>
</li>
<li><p>往通道上的三个LBA写入扇区地址LBA28的低24位</p>
</li>
<li><p>往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式</p>
</li>
<li><p>往该通道的command寄存器写入命令（一旦写入立即执行）</p>
</li>
<li><p>读取status寄存器，判断硬盘工作是否完成</p>
</li>
<li><p>如果上诉是写操作，则到此完工；如果上诉是读操作，则还需要一步</p>
</li>
<li><p>将硬盘数据读出</p>
</li>
</ol>
<p>  <strong>PS：操作并不是单纯的读，我们要读取一块扇区上的数据，我们要做的一步是把读取命令写入command寄存器，注意，是写入！也就是说读操作中也包含写入的过程</strong></p>
</li>
<li><p>常用的数据传输方式</p>
<p>  当我们要读取硬盘中的某个扇区，我们先写入读取命令并判断硬盘工作已经完成，在判断硬盘工作是否完成(上述5操作)这一步我们区分出了不同的数据传输方式</p>
<ol>
<li><p>无条件传输：数据源设备随时准备好数据，CPU随取随拿，如寄存器、内存等设备，CPU无需提前打招呼。</p>
</li>
<li><p>查询传送方式：CPU按照一定间隔不断去检测设备是否完成操作，如果完成，则CPU去取数据</p>
</li>
<li><p>中断传送方式：CPU无需不断检测，而是当设备完成时触发中断，由中断来通知CPU我数据已经准备好了</p>
</li>
<li><p>直接存储器存取方式（DMA）：不让CPU参与传输，完全由数据源设备和内存直接传输，CPU直接到内存中拿数据即可</p>
</li>
<li><p>I&#x2F;O处理机传送方式：引入完整的一套硬件来处理这些事，CPU甚至不知道有传输这回事</p>
</li>
</ol>
<p>  <strong>PS:方式1磁盘用不了，方式4、5则需要硬件支持，所以在我们与硬件沟通时采用方式2或3</strong></p>
</li>
</ul>
</li>
<li><p>接力第三棒：loader</p>
<p> 我们的MBR受限于512字节的关系，无法做太多的事：没法为内核准备好环境，更没法将内核成功加载到内存并允许。</p>
<p> 所以我们要在另一个程序中完成初始化环境以及加载内核的任务，这个程序就是加载器loader</p>
<p> loader的源代码自然也是存在磁盘里的，MBR要负责从硬盘上把loder加载到内存，并把接力棒交给loader</p>
</li>
<li><p>修改后的代码</p>
<ul>
<li><p>boot.inc(头文件)</p>
<pre><code>  LOADER_BASE_ADDR equ 0x900
  ;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
  ;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
  ;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

  LOADER_START_SECTOR equ 0x2
  ;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
  ;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区
</code></pre>
</li>
<li><p>MBR.S</p>
<pre><code>  ; 主引导程序 MBR ：实现从硬盘上加载loader到内存中，并将接力棒交给loader

  %include &quot;boot.inc&quot;
  ;连接头文件，定义了LOADER_BASW_ADDR、LOADER_START_SECTOR

  SECTION MBR vstart=0x7c00
      ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

      mov ax,cs
      mov ds,ax
      mov es,ax
      mov ss,ax
      mov fs,ax
      ;利用CS=0初始化各个段寄存器
      mov sp,0x7c00
      ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

      

  ;------------------------------------------------------------------------------------------
      ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

      mov ax,0x600
      mov bx,0x700
      mov cx,0
      mov dx,0x184f

      int 0x10

  ;------------------------------------------------------------------------------------------
      ;以下是通过寄存器传递参数并调用 loader_ready_proc

      mov eax,LOADER_START_SECTOR ;eax记录LBA28，也就是loader在磁盘上的扇区地址
      mov bx,LOADER_BASE_ADDR     ;bx记录loader将要被移动到内存里哪个位置
      mov cx,1                    ;cx记录移动的扇区数

      call loader_ready_proc      ;调用函数装载loader
      jmp LOADER_BASE_ADDR        ;跳转到被装载到内存里的loader，将接力棒交给它
  ;------------------------------------------------------------------------------------------
  ;该函数的功能是装载loader
  loader_ready_proc:
      mov esi,eax                 ;ax会在后续in/out指令被使用，所以备份参数
      mov di,cx                   ;di会在后续循环中被用到，所以备份参数


      ;第一步：先选择通道，往该通道的sector cout寄存器写入待操作的扇区数
      mov ax,di
      mov dx,0x1f2
      out dx,al

      mov eax,esi                  ;复原eax


      ;第二步往通道上的三个LBA写入扇区地址LBA28的低24位
      mov dx,0x1f3
      out dx,al

      mov cl,8
      shr eax,cl       
      mov dx,0x1f4     
      out dx,al

      shr eax,cl
      mov dx,0x1f5
      out dx,al

      
      ;第三步 往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式
      shr eax,cl
      and al,0x0f
      or al,0xe0
      mov dx,0x1f6
      out dx,al


      ;第四步往该通道的command寄存器写入命令（一旦写入立即执行）
      mov dx,0x1f7
      mov al,0x20
      out dx,al


      ;第五步读取status寄存器，判断硬盘工作是否完成(这边采用查询传输的方式)
  .not_ready:
      nop            ;增加循环查询的延迟
      in al,dx
      and al,0x88
      cmp al,0x08
      jnz .not_ready


      ;最后一步将硬盘数据读出
      mov ax,di
      mov dx,256
      mul dx
      mov cx,ax
      ;一个扇区512字节，要读取di个扇区，每次读取2字节(16位的data寄存器),一共要循环读取di*512/2次

      mov dx,0x1f0
  .go_on_read:
      in ax,dx
      mov [bx],ax
      add bx,2
      loop .go_on_read

      ;函数loader_ready_proc结束返回
      ret


      times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
      db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
</li>
<li><p>loader.S</p>
<pre><code>  ;这串代码并非实现真正的loader功能，而是只是在屏幕上打印字符，来验证我们是否真正装载并执行了loader


  %include &quot;boot.inc&quot;

  section loader vstart=LOADER_BASE_ADDR

      mov ax,0xb800;
      mov gs,ax
      ;令附加段基址寄存器gs指向显存映射地址

  ;输出背景色绿色，前景色红色，并且跳动闪烁的字符串&quot;2 LOADER&quot;

      mov byte [gs:0x00],&#39;2&#39;
      mov byte [gs:0x01],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x02],&#39; &#39;
      mov byte [gs:0x03],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x04],&#39;L&#39;
      mov byte [gs:0x05],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x06],&#39;O&#39;
      mov byte [gs:0x07],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x08],&#39;A&#39;
      mov byte [gs:0x09],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0A],&#39;D&#39;
      mov byte [gs:0x0B],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0C],&#39;E&#39;
      mov byte [gs:0x0D],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0E],&#39;R&#39;
      mov byte [gs:0x0F],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      jmp $
</code></pre>
</li>
<li><p>一个小细节<br>  这些代码中默认我们的虚拟磁盘是Primary通道的主盘，可能有人会疑惑为什么是Primary通道的主盘，详细信息请看配置文件bochsrc.disk，如下所示</p>
<pre><code>  ata0:enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14
  ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat,cylinders=121,heads=16,spt=63
  # ata0代表IDE0也就是Primary通道，atao-master代表的是Primary通道的主盘
</code></pre>
</li>
</ul>
</li>
<li><p>装载代码</p>
<p> 我们现在有三个文件：头文件boot.inc、mbr.S、loader.S</p>
<ul>
<li><p>boot.inc<br>  请在代码文件夹下创建一个文件夹include,把boot.inc放在include下面，用于被其他文件引用链接</p>
</li>
<li><p>mbr.S<br>  我们使用在原有的命令上添加了include路径：</p>
<pre><code>  nasm -I include/ -o mbr.bin mbr.S
</code></pre>
<p>  然后继续使用dd命令将他装载到hd60M.img的第一块扇区:</p>
<pre><code>  dd if=/home/sparkle2/codeset/mbr.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 conv=notrunc
</code></pre>
</li>
<li><p>loader.S<br>  我们同样用带有include路径的命令编译它:</p>
<pre><code>  nasm -I include/ -o loader.bin loader.S
</code></pre>
<p>  然后继续使用dd命令将他装载到hd60M.img的第三块扇区（seek&#x3D;2代表跳过两块）:</p>
<pre><code>  dd if=/home/sparkle2/codeset/loader.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 seek=2 conv=notrunc
</code></pre>
</li>
</ul>
<p> 最后运行命令<code>bin/bochs -f bochsrc.disk</code>看到屏幕上出现<code>2 loader</code>的输出字符实验就成功了</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/09/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/09/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-09 23:15:59" itemprop="dateCreated datePublished" datetime="2023-11-09T23:15:59+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-10 09:38:11" itemprop="dateModified" datetime="2023-11-10T09:38:11+08:00">2023-11-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在这一章，我们编写一段MBR程序并装载在磁盘里，开始接手操作系统的第一步。</p>
<h1 id="BIOS与MBR的职责和功能"><a href="#BIOS与MBR的职责和功能" class="headerlink" title="BIOS与MBR的职责和功能"></a>BIOS与MBR的职责和功能</h1><p>下图是1MB内存空间在实模式下的内存布局：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img1.jpg" alt="img"></p>
<p><strong>PS：0x00000~0x9FFFF是RAM，0xA0000~0xFFFFF是ROM</strong><br><strong>你可能会觉得疑惑：一定要如此布局吗？</strong><br><strong>该布局方式源于早期系统，其中一些魔数（特别的数，像是为什么MBR其实地址在0x7C00）也是早期约定好的规矩，而后来的设备为了可以兼容早期设备都遵守这些规矩</strong></p>
<p>BIOS全称叫Base Input&amp;Output System，即基本输入输出系统，是固化在ROM上的一段程序</p>
<p>电脑上电后运行的第一个软件就是BIOS，也就是CS:IP在硬件支持下一上电即为<code>0xF000:0xFFF0</code>（BIOS的入口地址）。BIOS的入口地址处是一条跳转指令<code>jmp far f000:e05b</code>,CPU跳转并开始执行BIOS的程序，开始检测内存、显卡等外设信息，初始化硬件，并在<code>0x000~0x3FFF</code>处建立中断向量</p>
<p>BIOS的最后一项工作是校验启动盘中位于<code>0盘0道1扇区</code>（相当于0盘0道0扇区，1扇区和0扇区只是描述方法不同）的内容，如果此时扇区末尾的两个字节分别是0x55和0xaa，BIOS便将该扇区的内容认定为待装载的MBR程序（Main Boot Record 主引导记录），将其加载道物理地址0x7c00处，然后将控制权MBR，执行MBR程序</p>
<p>通俗地说：BIOS就是接力手的第一棒，MBR就是第二棒</p>
<p>我们的目的就是编写MBR程序，并装载到启动盘的<code>0盘0道1扇区</code>处，由我们来接手第二棒</p>
<h1 id="必须要了解的相关知识点"><a href="#必须要了解的相关知识点" class="headerlink" title="必须要了解的相关知识点"></a>必须要了解的相关知识点</h1><ol>
<li><p>MBR的大小必须是512字节，而且得保证0x55和0xaa在该扇区的这两个魔数出现在510字节和511字节</p>
</li>
<li><p>x86平台是小端序（低位字节放在低地址），也就是说对于0xaa55这条指令来说，0xaa高位字节放在高地址（511），0x55低位字节放在低地址（510）</p>
</li>
<li><p>$和$$是NASM预留的关键字，$是表示本行代码起始地址的标号，$$是表示本section代码起始地址的标号</p>
</li>
<li><p>section可以用vstart&#x3D;xxxx修饰，表示section的虚拟起始地址设置为xxxx</p>
</li>
<li><p>我们知道BIOS在扫描完0xaa55后会装载并跳转道0x7c00，这一步也是由硬件支持，CS:IP会被强制设置为<code>0x0000:0x7c00</code></p>
</li>
<li><p>NASM指令格式：<code>nasm -f &lt;format&gt; &lt;filename&gt; [-o &lt;output&gt;]</code> 其中<code>-f &lt;format&gt;</code>是指令输出文件格式，<code>&lt;filename&gt;</code>是目标文件名， <code>-o &lt;output&gt;</code>是指令输出文件名</p>
</li>
<li><p>关于输出文件格式有很多种，我们这里只关注bin和elf：bin是纯二进制文件（给CPU就可以直接运行）；elf是二进制可执行文件（里面参杂了些和指令无关的修饰，是给操作系统的程序加载器使用的）</p>
</li>
</ol>
<h1 id="MBR程序"><a href="#MBR程序" class="headerlink" title="MBR程序"></a>MBR程序</h1><p>编写文本文件 mbr.S </p>
<pre><code>; 主引导程序 MBR ：实现屏幕上打印字符&#39;1 MBR&#39;

SECTION MBR vstart=0x7c00
    ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

    mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    ;利用CS=0初始化各个段寄存器
    mov sp,0x7c00
    ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

    mov ax,0x600
    mov bx,0x700
    mov cx,0
    mov dx,0x184f

    int 0x10

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的3号子功能，获取光标位置，在光标处打印字符

    mov ah,3
    mov bh,0
    
    int 0x10

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的13号子功能，实现打印字符

    mov ax,message
    mov bp,ax

    mov cx,5
    mov ax,0x1301
    mov bx,0x2
    
    int 0x10

;------------------------------------------------------------------------------------------

    jmp $ ;实现死循环，让程序悬停

    message db &quot;1 MBR&quot;
    times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
    db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
<p><strong>PS:代码中关于BIOS提供的历程int 10具体格式注释中并没有给出，因为这块不重要，如果想知道为什么int 10的功能调用要这么编写可以查BIOS的手册，也可以查看<code>操作系统真象还原 P61</code></strong></p>
<h1 id="编译、装载并启动"><a href="#编译、装载并启动" class="headerlink" title="编译、装载并启动"></a>编译、装载并启动</h1><ol>
<li><p>编译：</p>
<p> 接下来我们要用<code>nasm -f bin mbr.S -o mbr.bin</code>(也可以简写成<code>nasm -o mbr.bin mbr.s</code>)对mbr.S进行编译,编译成功你就可以看到mbr.bin文件了</p>
<p> 我们还得用指令<code>ls -l</code>查看当前目录下所有文件及属性，检测一下mbr.bin文件的大小，是不是刚好512字节不多也不少</p>
</li>
<li><p>转载：</p>
<p> 然后我们要把mbr.bin文件装载到虚拟磁盘<code>hd60M.img</code>中的0盘0道1扇区处，可以使用dd命令：<code>dd if=/home/sparkle2/codeset/mbr.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 conv=notrunc</code></p>
<p> dd命令中<code>if</code>指定要读取的文件路径；<code>of</code>指定装载文件的路径；<code>bs</code>指令块的大小，也就是字节数；<code>cout</code>指令拷贝的块数；<code>conv</code>指定转换文件方式，在追加数据时conv最好用notrunc<br> 方式</p>
</li>
<li><p>启动</p>
<p> 最后我们进入安装目录下，使用命令<code>bin/bochs -f bochsrc.disk</code>启动，bochs emulator处于黑屏状态 在控制台按<code>c</code>进入调试模式，看到如下结果则大功告成：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img2.png" alt="img"></p>
<p> <strong>PS:我们可以注意到启动后，电脑上有两个窗口，一个是bochs emulator，另一个是控制台；bochs emulator就是我们模拟的机器。我在关闭bochs emulator是遇到一些问题，请不要直接点击bochs emulator窗口右上角的红叉，会引发关闭不了的问题。正确的做法是可以点击bochs emulator右上角第二行的电源键关闭模拟机器，再关闭控制台。也可以在控制台<code>Ctrl+C</code>退出调试模式，然后输入<code>q</code>退出该进程。</strong></p>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到这里我们就正式接受了电脑启动后的第二棒接力棒，开始正式掌权了。如果看完本文章还有疑惑，建议看下<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117782012">《操作系统真象还原》第二章 —- 编写MBR主引导记录 初尝编写的快乐 雏形已显！</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/08/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/08/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-08 15:08:46" itemprop="dateCreated datePublished" datetime="2023-11-08T15:08:46+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-09 15:06:51" itemprop="dateModified" datetime="2023-11-09T15:06:51+08:00">2023-11-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本系列记录我跟随<code>《操作系统真象还原》</code>制作一个简易的操作系统的全过程</p>
<h1 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h1><p>VMware是一款可以帮你轻松建立并管理虚拟机的工具。<code>操作系统真象还原</code>推荐使用虚拟机管理工具virtualBox，但由于我之前使用过VMware所以选择继续使用VMware</p>
<p>VMware的许可证密钥可以在网上轻松获得</p>
<p>具体的安装步骤请参照<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">八分钟完成VMware和ubuntu系统安装</a>的前半部分</p>
<h1 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h1><p>Ubuntu是以Linux为内核的操作系统，也是我们将来要自制简易操作系统的环境。<code>操作系统真象还原</code>推荐虚拟机安装Centos操作系统（二者都是Linux内核，听说Centos7会有些问题所以选择Ubuntu）</p>
<p>其中我的虚拟机设置是：2*2核、40G硬盘、2G内存；Ubuntu版本是20.04.6（兼容gcc 4）</p>
<p>具体的安装步骤请参照<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">八分钟完成VMware和ubuntu系统安装</a>的后半部分</p>
<p><strong>PS：从安装完Ubuntu后应该在执行每一个重要的步骤前给虚拟机拍一个快照，如果执行出错了，我们就可以回到快照处，保证虚拟机的正确性</strong><br><strong>安装Ubuntu时Language选项请选择英语，可以省去很多后续麻烦</strong></p>
<h1 id="安装VMware-Tool"><a href="#安装VMware-Tool" class="headerlink" title="安装VMware Tool"></a>安装VMware Tool</h1><p>VMware Tool可以实现主机和虚拟机之间拖拽传输文件以及通用复制粘贴，大大简化两机之间的交互难度</p>
<p>具体安装步骤请参照该<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YA411k7Lm/?spm_id_from=333.880.my_history.page.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">VMwareTools安装教程</a></p>
<p>如果在执行第二步Ubuntu时不是自定义安装而是简易安装，就有可能会遇到一个问题：ubuntu安装VMware-tools时，虚拟机中的选项是灰色的，点击不了。那么请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhvngchvng/article/details/108603053">ubuntu安装VMware-tools时，虚拟机中的选项是灰色的，点击不了</a></p>
<p><strong>PS：有的虚拟机安装完操作系统就自带安装VMware Tool了，请安装完Ubuntu看看虚拟机菜单，如果选项是’重新安装BMware Tool’就代表已经按照完毕</strong></p>
<h1 id="安装Bochs"><a href="#安装Bochs" class="headerlink" title="安装Bochs"></a>安装Bochs</h1><p>Bochs是一个x86硬件平台的开源模拟器，它可以模拟各种硬件的配置。Bochs模拟的是整个PC平台，包括I&#x2F;O设备、内存和BIOS，某种程度上来说Bochs也是一个虚拟机，我们未来就是要在Bochs上实现操作系统的制作。</p>
<p>我安装的是Bochs2.6.8，Bochs的具体安装步骤请参考<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117751327">《操作系统真象还原》第一章 —- 安装Vmware Station 安装Ubuntu 装载配置Bochs 安装Vmware tools 开始乘帆历险！</a>上半部分。</p>
<p>Bochs的下载我们可以在主机上下载完压缩包后再直接复制到虚拟机里</p>
<p>在解压后的文件夹下打开终端并输入命令</p>
<pre><code>./configure \
--prefix=/home/sparkle2/bochs \
--enable-debugger \
--enable-disasm \
--enable-iodebug \
--enable-x86-debugger \
LIBS=&#39;-lX11&#39; \
--with-x \
--with-x11

#上面的代码中，prefix指定的是安装bochs的路径
#LIBS这一行是原书上没有的，是我遇到第四个报错后查阅资料添加的
#除了最后一句命令外每一句结尾都是&#39; \&#39;代表着命令还未输入完，运行换行继续输入
</code></pre>
<p>等到上述命令得以正确执行后，还需要在Bochs的解压目录下执行两条命令：</p>
<pre><code>make
make install
</code></pre>
<p>Bochs就安装成功了，我们可以在指定路径下看到安装后的bochs文件夹</p>
<p>整个安装过程中我遇到了四个报错</p>
<ol>
<li>缺少C编译器</li>
<li>C++ preprocessor fails sanity check</li>
<li>“ERROR: X windows gui was selected, but X windows libraries were not found.</li>
<li>undefined reference to symbol ‘XSetForeground’</li>
</ol>
<p>其中前两个报错在上述文章中都已解决，第三个报错请参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/geeker_12/article/details/11409009">Ubuntu下安装Bochs各种奇怪错误汇总</a>，第四个报错请参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/cloudblaze/article/details/52752912">[乱七八糟]bochs编译错误之’XSetForeground’</a></p>
<p><strong>PS:在使用apt命令更新或下载一些东西时，有时候需要换源，在etc&#x2F;apt&#x2F;source.list文件中把下载源改为中国地区,否则会出现下载慢下载失败等问题</strong></p>
<h1 id="配置Bochs"><a href="#配置Bochs" class="headerlink" title="配置Bochs"></a>配置Bochs</h1><p>配置Bochs请参照<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117751327">《操作系统真象还原》第一章 —- 安装Vmware Station 安装Ubuntu 装载配置Bochs 安装Vmware tools 开始乘帆历险！</a>下半部分</p>
<p>我的配置文件如下：</p>
<pre><code>megs: 32
# megs书本是32，博客是512，我跟着书本走

romimage: file=/home/sparkle2/bochs/share/bochs/BIOS-bochs-latest
vgaromimage: file=/home/sparkle2/bochs/share/bochs/VGABIOS-lgpl-latest

boot: disk

log: bochs.out

mouse:enabled=0
keyboard:keymap=/home/sparkle2/bochs/share/bochs/keymaps/x11-pc-us.map

ata0:enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14

ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat,cylinders=121,heads=16,spt=63
#新加入的代码，也就是新建立的虚拟磁盘

# gdbstub:enabled=1,port=1234,text_base=0,data_base=0,bss_base=0
</code></pre>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到此，第一步环境的部署就做完了，第二步就可以开始正式写代码了。</p>
<p>只是环境部署就用了将近两天时间，期间反复下载了4次虚拟机，长路漫漫。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">VScode编码不一致问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 22:15:24" itemprop="dateCreated datePublished" datetime="2023-11-04T22:15:24+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:19:23" itemprop="dateModified" datetime="2023-11-06T11:19:23+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文描述并解决在VSCode里遇到的控制台编码与文件编码不一致导致的乱码问题</p>
<h1 id="VSCode控制台介绍"><a href="#VSCode控制台介绍" class="headerlink" title="VSCode控制台介绍"></a>VSCode控制台介绍</h1><p>VSCode里不止只有1个控制台，如下图所示：</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img1.png" alt="img"></p>
<p>图中一共有四个控制台，可通过终端窗口右上角的<code>+</code>进行调整</p>
<ul>
<li><p>PowerShell：VSCode默认采用PowerShell，功能上比cmd更为强大，兼容cmd命令的同时有自己扩展的指令集，用来管理Windows系统和应用程序，执行复杂的脚本和自动化任务。</p>
</li>
<li><p>Git Bash：Git Bash是Git自带的一个终端模拟器，兼容cmd命令的同时扩展了Linux命令和git命令，它可以在Windows上模拟Bash环境（Linux的控制台）。适合习惯使用Linux的用户。</p>
</li>
<li><p>JavaScript调试终端：可以让你在VSCode中直接运行和调试JavaScript代码，而不需要额外的配置或者浏览器。</p>
</li>
<li><p>Command Prompt：基于Dos的传统的cmd命令行，cmd不兼容上述控制台，只能用来执行一些基本的命令和批处理文件。</p>
</li>
</ul>
<p>除了上述四个控制台外，还有在调试代码时跳出的针对不同语言不同的控制台，例如：用于调试C++&#x2F;C代码的cppdbg；用于调试python代码的python Debug Console等等，可以在调试代码时，查看终端窗口右上角的小标题来确定你现在使用的是哪一个控制台</p>
<p>注意：不同的控制台使用的编码是独立不相互影响的，千万不要使用A控制台却去调整B控制台的编码</p>
<h1 id="VSCode文件编码介绍"><a href="#VSCode文件编码介绍" class="headerlink" title="VSCode文件编码介绍"></a>VSCode文件编码介绍</h1><p>VSCode当前文件编码格式可以查看右下角</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img2.png" alt="img"></p>
<p>如图，当前文件编码是UTF-8</p>
<p>如果想要修改该文件编码，可以点击图中的UTF-8</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img3.png" alt="img"></p>
<p>先选择通过目标编码方式保存，再通过目标编码方式打开，这样就成功修改了当前文件的编码格式</p>
<h1 id="常见的编码介绍"><a href="#常见的编码介绍" class="headerlink" title="常见的编码介绍"></a>常见的编码介绍</h1><ul>
<li><p>GBK：针对中文的编码（国内cmd默认的编码方式），在国家标准GB2312的基础上扩展的，向下兼容GB2312，但在国外并不常用。代码是936</p>
</li>
<li><p>UTF-8：UTF-8是一种针对多语言的编码，它包含了全世界所有国家需要用到的字符，基于Unicode字符集的，向下兼容ASCII，在国际上通行。代码是65001</p>
</li>
</ul>
<h1 id="如何查看并改变控制台编码"><a href="#如何查看并改变控制台编码" class="headerlink" title="如何查看并改变控制台编码"></a>如何查看并改变控制台编码</h1><p>在控制台里输入以下命令可以查看当前控制台编码格式：</p>
<pre><code>chcp
</code></pre>
<p>在控制台里输入以下命令可临时转化当前控制台编码格式：</p>
<pre><code>chcp &#39;编码代码&#39;
</code></pre>
<p>综上，只要保证文件和控制台编码格式相同，就不会出现乱码问题</p>
<h1 id="本文尚未解决的问题"><a href="#本文尚未解决的问题" class="headerlink" title="本文尚未解决的问题"></a>本文尚未解决的问题</h1><p>本文只提供了临时更改控制台编码的方法，并没有提供更改各个控制台默认编码的方法</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">个人博客创建指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 15:23:38" itemprop="dateCreated datePublished" datetime="2023-11-04T15:23:38+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:16:01" itemprop="dateModified" datetime="2023-11-06T11:16:01+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&emsp;&emsp;这篇文章记录我第一次创建个人博客的过程，使用了Github个人账户域名，开源免费的Hexo博客框架以及Next主题。</p>
<h1 id="安装Git和Node-js"><a href="#安装Git和Node-js" class="headerlink" title="安装Git和Node.js"></a>安装Git和Node.js</h1><p>Git 是一种分布式版本控制系统，即，代码的本地克隆就是一个完整的版本控制存储库。 通过这些功能齐全的本地存储库，无论脱机还是远程都能轻松工作。 开发人员会在本地提交其工作，然后再将存储库的副本与服务器上的副本进行同步。（Github就是搭配Git使用的用于存储代码的克隆库）</p>
<p>Node.js可以让JavaScript脱离浏览器运行，它是一个开源、跨平台的JavaScript运行时环境，可以用来开发高性能的 Web 服务器和网络应用。</p>
<p>搭建个人博客为何需要安装Git和Node.js?我们基于Hexo搭建博客，Hexo必须依赖Node.js提供的环境运行。而Git并非是搭建个人博客的必备，但我们仍然推荐下载Git，使用Git的相关命令来从Hexo下载Next主题。</p>
<ol>
<li><p>从官网上安装Git并配置相关环境变量（PS：安装完Git后你可以使用Git Bash作为命令行窗口调用命令，Git Bash上可以使用Linux格式的命令，但由于Git Bash上安装下载无法看到进度条的问题，我个人更推荐用cmd来进行操作，本文后续无特殊声明命令行全采用cmd）</p>
</li>
<li><p>绑定Git和Github账号，在cmd里输入以下命令：</p>
<pre><code> git config --global user.name “Your Name”
 git config --global user.email email@example.com
 :: 其中Your Name和email@example.com替换成上面注册时的账户名和邮箱
</code></pre>
</li>
<li><p>从官网上安装Node.js并配置相关环境变量</p>
</li>
<li><p>执行完上述步骤可以用以下命令测试是否安装成功：</p>
<pre><code> git version
 node -v
 npm -v
</code></pre>
<p> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture1.png" alt="img"></p>
</li>
</ol>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>hexo是一个基于Node.js的静态博客框架，它可以让您使用Markdown（或其他渲染引擎）编写文章，并在几秒内生成静态网页。</p>
<p>npm是Node.js 的默认程序包管理器，它可以让您从 npm 服务器下载、安装、上传和管理 Node.js 的模块或包。模块或包是一些可以重用的代码，可以实现一些特定的功能或提供一些特定的服务</p>
<p>使用npm安装Hexo，命令如下：</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<h1 id="创建博客网站"><a href="#创建博客网站" class="headerlink" title="创建博客网站"></a>创建博客网站</h1><p>所有的准备工作都做好了后，现在需要生成一个文件夹作为个人博客网站的根目录，在你希望放置个人博客文件夹的地方使用如下命令：</p>
<pre><code>hexo init myBlog
:: 其中myBlog就是你的个人博客网站根目录，可以取自己喜欢的名字
cd myBlog
npm install
</code></pre>
<p>如果上面工作都没有出错的化，现在你的个人博客已经搭建成功了，你可以在个人博客根目录下输入以下命令在本地预览效果：</p>
<pre><code>hexo s
</code></pre>
<p><img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture2.png" alt="img"></p>
<p>并且我们可以在根目录下的_config.yml里对个人博客的初始设置进行配置，例如：姓名、标题等个性化设置</p>
<h1 id="选择你喜欢的主题"><a href="#选择你喜欢的主题" class="headerlink" title="选择你喜欢的主题"></a>选择你喜欢的主题</h1><p>大家可以去<a target="_blank" rel="noopener" href="https://hexo.io/themes/">Hexo官网</a>去寻找喜欢的主题下载下来，每个主题都可以点击预览，并且可以点击查看使用说明文档</p>
<p>我使用的<a target="_blank" rel="noopener" href="https://github.com/next-theme/hexo-theme-next">Next主题</a>是较为受欢迎的一款，风格简约大气</p>
<p>下载主题有两种方法，这边只介绍使用一种，在个人博客文件根目录下使用命令：</p>
<pre><code>git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
<p>如果下载成功则根目录下会出现该文件夹 &#x2F;themes&#x2F;next</p>
<p>我们就可以在NexT文件夹里的_config.yml里对该主题的一些设定进行配置，但这种方法存在弊端，官方推荐的配置方法以及具体的操作可以查看<a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/theme-settings/custom-pages">NexT官方说明文档</a></p>
<h1 id="将个人博客部署到Github上"><a href="#将个人博客部署到Github上" class="headerlink" title="将个人博客部署到Github上"></a>将个人博客部署到Github上</h1><p>Github能且仅能使用一个同名仓库的代码托管一个静态站点.</p>
<ol>
<li><p>在Github上创建一个名为：<code>用户名.github.io</code>的仓库</p>
</li>
<li><p>使用以下命令配置SSH钥匙：</p>
<pre><code> git config --global user.name &quot;用户名&quot;
 git config --global user.email &quot;邮箱地址&quot;
 ::之前已经配置过可直接输入第三条命令 
 ssh-keygen -t rsa -C &#39;上面的邮箱&#39;
</code></pre>
<p> 可在<code>C:\Users\用户名\.ssh\id_rsa.pub</code>文件里查看SSH公钥</p>
</li>
<li><p>首次使用还须使用以下命令确认并添加主机到本机SSH可信列表：</p>
<pre><code> ssh -T git@github.com
 ::若返回 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功
</code></pre>
</li>
<li><p>登陆Github添加刚刚生成的SSH key，在下图中Key部分处放入SSH公钥内容<br> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture3.png" alt="img"></p>
</li>
<li><p>在根目录底下_config.xml文件拉到最底部添加如下配置：</p>
<pre><code> deploy :
 type: git
 repo: https://github.com/1478540/1478540.github.io.git
 # repo是你的仓库地址
 branch: master
</code></pre>
</li>
<li><p>安装一个部署插件：</p>
<pre><code> npm install hexo-deployer-git --save
</code></pre>
</li>
<li><p>生成相应的博客文件并部署：</p>
<pre><code>hexo g 
::g是generate，生成相应文件
hexo d
::d则是部署，部署完以后就可以通过Github账户域名访问个人博客了
</code></pre>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>文章发布可以通过命令<code>hexo new &#39;文章标题&#39;</code>,也可以直接在<code>/sourse/_posts</code>文件夹下创建.md文件，文件的具体的编写可以使用<a target="_blank" rel="noopener" href="https://markdown.com.cn/basic-syntax/images.html">makedown语法</a></p>
<p>本文学习于B站教程<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.880.my_history.page.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">[教程]Hexo &amp; Github搭建自己的专属博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
