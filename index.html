<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sparkle&#39;s Space">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sparkle's Space</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/11/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（四）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-11 15:46:38" itemprop="dateCreated datePublished" datetime="2023-11-11T15:46:38+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-14 20:28:13" itemprop="dateModified" datetime="2023-11-14T20:28:13+08:00">2023-11-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这一章我们学习如何从实模式到保护模式，并编写加载器loader的代码，让他实现将系统从实模式切换到保护模式</p>
<h1 id="保护模式概述"><a href="#保护模式概述" class="headerlink" title="保护模式概述"></a>保护模式概述</h1><p>保护模式和实模式一样都是指工作状态、工作环境、工作命令等一整个方面的内容。</p>
<p>一开始是没有实模式、保护模式的概念的。16位CPU时代工作配置都是现有的实模式，但是当时并没有16位实模式的概念。直到人们觉得这种工作方式不安全，在32位CPU时代里推出了新的工作方式。由于32位CPU一定要可以兼容16位CPU的程序，所以为了区分新旧工作模式，引入了实模式（重点是真实的物理地址）、保护模式（重点突出保护）两个概念。</p>
<p>也就是说现代计算机是可以兼容实模式和保护模式，当然绝大多数时候都是使用保护模式</p>
<h2 id="为什么要有保护模式-实模式的缺点"><a href="#为什么要有保护模式-实模式的缺点" class="headerlink" title="为什么要有保护模式(实模式的缺点)"></a>为什么要有保护模式(实模式的缺点)</h2><ol>
<li><p>实模式下用户程序和操作系统同一等级，而且逻辑地址就是物理地址，用户程序可以随意修改段基址访问所有内存，不安全</p>
</li>
<li><p>实模式16位寄存器决定访问超过64KB的内存区域要切换段基址、麻烦</p>
</li>
<li><p>一次只能运行一个程序，无法充分利用计算机资源</p>
</li>
<li><p>只有20条地址线，最大可用内存的寻址范围只有1MB，不够用</p>
</li>
</ol>
<h2 id="保护模式的特点"><a href="#保护模式的特点" class="headerlink" title="保护模式的特点"></a>保护模式的特点</h2><ol>
<li><p>应用程序只能访问虚拟地址，虚拟地址由处理器和操作系统协作转换后才显示真正的物理地址</p>
</li>
<li><p>保护模式的运行环境是32位，寄存器、数据线、地址线也相应都被扩展到32位，指令格式也有了相应的扩展（允许32位源操作数）</p>
</li>
<li><p>保护模式不再使用中断向量表、段基址寄存器这些概念。取而代之的是段选择子寄存器、全局描述符、中断描述符表、各种门结构</p>
</li>
<li><p>保护模式引入了特权级的概念，应用程序不再和操作系统拥有同一特权级</p>
</li>
</ol>
<h2 id="保护模式的扩展"><a href="#保护模式的扩展" class="headerlink" title="保护模式的扩展"></a>保护模式的扩展</h2><ol>
<li><p>寄存器扩展：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img1.png" alt="img"></p>
<p> 保护模式下寄存器、地址线和数据总线都扩展到32位，内存寻址空间可达4GB，段内寻址空间也可达4GB。也就是说对内存的访问甚至可以让段基址&#x3D;0，只由一个记录偏移量的寄存器来访问内存，这也就是所谓的平坦模型</p>
<p> 另外一提：保护模式抛弃基址这个概念，而是在内存里放入一个全局描述符表，每一个表项都是一个段描述符，用来描述各个内存段的起始地址、大小、权限等信息。段寄存器保护的也不再是段基址了，而是“选择子”，选择子本质上就是全局描述符表中的索引，就像是数组下标一样的东西。</p>
</li>
<li><p>寻址扩展：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img2.png" alt="img"></p>
<p> 如图所示保护模式的寻址方式更加灵活多变，不仅在基址寄存器(所有通用寄存器都可)和变址寄存器(处理esp外的所有通用寄存器都可)有了更多选择外，还引入了比例因子</p>
</li>
<li><p>运行模式反转：</p>
<p> 由于32位CPU兼容保护模式和实模式，所以如果你在保护模式下使用实模式的命令，或者在实模式下使用保护模式的命令，都会触发运行模式反转，将会在二进制机器码前加上相应的反转前缀。</p>
<p> 注意：模式反转前缀只对单条指令有效，效果并非是全局的</p>
<pre><code> [bit 16] ;告诉编译器接下来的代码是实模式
 [bit 32] ;告诉编译器接下来的代码是保护模式
</code></pre>
<ul>
<li><p>操作数反转前缀 0x66</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img3.png" alt="img"></p>
<p>  如图上半部分是代码，下半部分是编译后的机器指令</p>
<p>  第三行在[bit 16]实模式下使用了eax，触发了保护模式转换，因此机器码前加了前缀0x66</p>
<p>  第五行在[bit 32]保护模式下使用了ax，触发了实模式转换，因此机器码前加了前缀0x66</p>
</li>
<li><p>寻址方式反转前缀 0x67</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img4.png" alt="img"></p>
<p>  第四行在[bit 16]实模式下同时使用了保护模式的32位源操作数和更加灵活的寻址方式，触发模式转换，机器码添加了前缀0x66、0x67</p>
</li>
</ul>
</li>
<li><p>指令扩展</p>
<p> 指令扩展后允许32位寄存器和32位源操作数</p>
</li>
</ol>
<h1 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h1><p>从实模式到保护模式我们要执行三个步骤：</p>
<ol>
<li>打开A20地址线</li>
<li>加载GDT</li>
<li>将CR0的PE位置1</li>
</ol>
<p>对于这三个步骤的讲解请看下文</p>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>到了保护模式下，内存段不再是简单用寄存器加载即可用，而是需要提前把段定义好才可使用。全局描述符就是用来存储对每个段描述的表，全局描述符中的每一个表项包含段描述符，段描述符就是对一个段的描述，64位段描述符格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img5.png" alt="img"></p>
<ol>
<li><p>段基址：</p>
<p> 每个段都有32位的段基址，在段描述符中被拆分成三块存储。</p>
<p> 为什么被拆分成三块？为的是兼容，实模式下段基址是16位，80286有关短暂的24位段基址，而现在则是32位段基址，为了兼容原本应该连续存放的段基址被拆分为16-8-8的形式。</p>
<p> 当需要查看段基址时，硬件会把三个分散的段基址取出来并拼接在一起得到一个完整的32位段基址。</p>
<p> <strong>PS：现在知道为什么有那么多屎山代码了，为了兼容旧时代的程序，屎山代码将成为每一个持续发展产品的最终归宿！</strong></p>
</li>
<li><p>段界限：</p>
<p> 段界限表示段边界的扩展最值，20位段界限被拆分为两部分(当然又是为了兼容)。</p>
<p> 段界限是一个单位量，单位要么是1字节，要么是4KB(单位由G段决定)。也就是说段的最大寻址范围要么是1*2^20&#x3D;1MB；要么是2*12*2^20&#x3D;4GB。(注意寻址范围!&#x3D;空间)</p>
<p> 实际的段界限边界值&#x3D;(描述符中段界限+1)*(段界限的粒度大小：4KB&#x2F;1Byte)-1</p>
</li>
<li><p>S字段和type字段：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img6.png" alt="img">    </p>
<p> S字段只有1位：S&#x3D;0 则说明是系统段(凡是硬件允许需要用到的东西，程序入口、调用门之类);S&#x3D;1 则说明是非系统段(凡是软件运行需要的东西，数据、代码、栈都是数据段)</p>
<p> type字段有4位：type字段只有在S确认后才有意义，X区分代码段和数据段，R代表是否可读，W代表是否可写，C代表是否一致，E代表向上扩展(E&#x3D;0,低地址到高地址)或向下扩展(E&#x3D;1，高地址到低地址)，A代表是否被CPU读过（CPU访问过则置1）</p>
</li>
<li><p>DPL（Descriptor Privilege Level）</p>
<p> 2位的DPL字段表示特权级，特权级从0~3,数字越低特权级越高，操作系统是0级，一般应用程序是3级</p>
</li>
<li><p>P字段（Present）：</p>
<p> 1位P表示段是否存在，有时候内存不够时，保护模式下CPU可能会按页(4KB)的单位将内存换到磁盘里，此时相当于该段不存在，即P&#x3D;0;</p>
</li>
<li><p>AVL字段（Avaliable）:</p>
<p> 1位AVL字段代表该段是否可用，是否可用是对用户来说，对操作系统来说可随意访问此位</p>
</li>
<li><p>L字段：</p>
<p> 1位L字段，L&#x3D;1表示代码段是64位，L&#x3D;0表示代码段是32位，我们在32位地址下编程将其设置为0即可</p>
</li>
<li><p>D&#x2F;B字段：</p>
<p> 1位D&#x2F;B字段指定有效地址及操作数大小，对不同段的意义不同</p>
<ul>
<li><p>如果争对代码段，D&#x3D;0时指令中有效地址和操作数是16位，指令有效地址用IP寄存器；D&#x3D;1时指令中有效地址和操作数是32位，指令有效地址用EIP寄存器</p>
</li>
<li><p>如果争对栈段，B&#x3D;0时栈使用SP寄存器，栈最大寻址范围为2^16；B&#x3D;1时栈使用ESP寄存器，栈最大寻址范围为2^32</p>
</li>
</ul>
</li>
<li><p>G段：</p>
<p> 1位G段用来指定段界限的单位大小，G&#x3D;0时，段界限的单位时1字节；G&#x3D;1时，段界限的单位是4KB</p>
</li>
</ol>
<h2 id="全局描述符号GDT、选择子以及GDTR寄存器"><a href="#全局描述符号GDT、选择子以及GDTR寄存器" class="headerlink" title="全局描述符号GDT、选择子以及GDTR寄存器"></a>全局描述符号GDT、选择子以及GDTR寄存器</h2><ol>
<li><p>GDT(Global Descriptor Table)相当于是段描述符的数组，每一表项都是一个段描述符</p>
</li>
<li><p>选择子是什么？选择子由三部分组成，如下图：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img7.png" alt="img"> </p>
<p> 0~1位用来存储RPL，即特权级；第2位是TI(Table Indicator)，用来表示选择子是GDT还是LDT的索引；3~5位是描述符的索引值，就是数组下表</p>
<p> <strong>PS：我们注意到索引一共是13位，也就是说一个GDT最多有2^13&#x3D;8192个表项</strong></p>
</li>
<li><p>LDT(Local Descriptor Table)是局部描述符，一个任务对应一个LDT，但它在现实中应用很少，我们的系统中也未用到LDT</p>
</li>
<li><p>GDTR(Global Descriptor Table Register)是用来指向GDT的寄存器，GDT存储在内存中，GDTR存储的则是GDT的地址。</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img8.png" alt="img"> </p>
<p> 如图所示是GDTR的结构，48位寄存器前16位是GDT以字节为单位的界限，后32位是GDT在内存中的起始地址</p>
<p> <strong>GDT界限范围有16位，也就是占有2^16个字节，而一个表项占有8字节，一个GDT一共可以存储2^16&#x2F;8&#x3D;8192个表项，和上面结论相符合</strong></p>
</li>
<li><p>ldgt(load Gloabal Descriptor Table)指令用来加载GPT，一般情况下从实模式进入保护模式我们需要使用命令ldgt来初始化GPTR，不仅如此，在保护模式中我们也可以使用ldgt命令来修改GPTR的值。ldgt的指令格式是：lgdt 48位内存数据</p>
</li>
<li><p>段描述符与内存的关系</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img9.png" alt="img"> </p>
<p> 如图可知，段描述符指向内存的各个地方。但是GDT的第0个段描述符是不可用的，因为GDT是用选择子来索引的，如果选择子忘记初始化就默认为0，这样选择子相当于索引到不可用的段描述符，而不会索引到其他内存空间。</p>
</li>
</ol>
<h2 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h2><ol>
<li><p>实模式下的地址回绕</p>
<p> 实模式下有20根地址线，也就是说最多可以索引1MB空间。实模式下我们用<code>16位段基址:16位偏移量</code>的形式来计算物理地址，我们发现假设16位段基址是0xFFFF，16位地址量是0xFFFF，最终计算得到的物理地址应该是：0xFFFF*16+0xFFFF&#x3D;0x10FFEF,我们发现这个地址已经超出了20位地址线所能传输的最大范围0xFFFFF。那当我们在实模式下访问超出0xFFFFF物理地址范围的空间时会发生什么事吗？其实并不会发生太糟糕的事，由于硬件原因，超出20位地址线的位将被舍弃，当你访问超过0x100000时就相当于访问0x00000,访问0x10FFEF时就相当于访问0x0FFEF。这个特点就叫做地址回绕。</p>
</li>
<li><p>32位CPU也要兼容地址回绕</p>
<p> 实模式下地址回绕的特性被许多程序员视为优点加以利用编程，但是保护模式却没有地址回绕这个问题。所以为了满足32位CPU必须兼容保护模式和实模式的特点，我们必须让32位CPU也要具备可以自由使用地址回绕的特点。</p>
<p> 我们知道32位CPU有32位的地址线，IBM在键盘控制器上的一些输出线来控制第21根地址线(A20)的有效性，成为A20Gate。</p>
<p> 如果A20Gate&#x3D;1，当访问0x100000~0x10FFEF之间的地址将会正常访问</p>
<p> 如果A20Gate&#x3D;0，当访问0x100000~0x10FFEF之间的地址将会触发地址回绕特性</p>
</li>
<li><p>打开A20地址线</p>
<p> 因此，当我们想从实模式进入保护模式时，我们必须打开A20Gate才能让保护模式的程序正常运行，打开A20Gate的代码如下：</p>
<pre><code> in al,0x92
 or al,0000_0010B
 out 0x92,al
</code></pre>
</li>
</ol>
<h2 id="保护模式的开关-CRO寄存器的PE位"><a href="#保护模式的开关-CRO寄存器的PE位" class="headerlink" title="保护模式的开关,CRO寄存器的PE位"></a>保护模式的开关,CRO寄存器的PE位</h2><p>想从实模式进入保护模式，我们还差最后一步。控制寄存器CRx是CPU的窗口，既可以用来展示CPU内部状态，又可以用来控制CPU运行机制。这次我们要用到CR0寄存器的PE（Protection Eanble）位，CR0寄存器构造如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img10.png" alt="img"> </p>
<p>右上方是CR0格式位，下方则是对每个位的描述，我们目前只需要关注PE位就行了，将PE位置1，让CPU知道我们要进入保护模式了，代码如下：</p>
<pre><code>mov eax,cr0
or eax,0x00000001
mov cr0,eax
</code></pre>
<h1 id="编写loader-S进入保护模式"><a href="#编写loader-S进入保护模式" class="headerlink" title="编写loader.S进入保护模式"></a>编写loader.S进入保护模式</h1><h2 id="头文件boot-inc更新"><a href="#头文件boot-inc更新" class="headerlink" title="头文件boot.inc更新"></a>头文件boot.inc更新</h2><pre><code>;--------------loader和kernel----------------

LOADER_BASE_ADDR equ 0x900
;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

LOADER_START_SECTOR equ 0x2
;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区

;------------gdt描述符属性（请对照段描述符格式理解以下代码）----------------------
;为了方便我们将64位的gdt描述符分为高32位和低32位来定义，下面代码定义的都是低32位


;二进制数据中间的&#39;_&#39;符号没有任何意义，仅仅只是为了让程序员看得更清楚，编译器会自动忽略
;命名中的DESC是描述的意思
DESC_G_4K equ 1_00000000000000000000000b ;第23位G 表示4K或者1MB位 段界限的单位值 此时为1则为4k 
DESC_D_32 equ 1_0000000000000000000000b  ;第22位D/B位 表示地址值用32位EIP寄存器 操作数与指令码32位
DESC_L    equ 0_000000000000000000000b   ;第21位 设置成0表示32位代码段而非64位代码段
DESC_AVL  equ 0_00000000000000000000b    ;第20位 CPU不用此位设置为0


;LIMIT代表段界限，我们打算在GPT里加入三个段：代码段、数据段、显存段(就是将之前显存的位置单独划分一个成一个段)
;我们对4GB的内存空间采用平坦模式，也就是说基址=0，偏移量最大范围=4GB（除了显存段外，显存段任然放置在0xB8000~0xBFFFF）
;DESC_LIMIT_CODE2代表定义代码段的段界限(第二部分)
DESC_LIMIT_CODE2  equ  1111_0000000000000000b   ;平坦模型要满足最大段界限*粒度=4GB，换算可知段界限必须为0xFFFFF,也就是全为1
DESC_LIMIT_DATA2  equ  DESC_LIMIT_CODE2         ;相同的值  数据段与代码段段界限相同
DESC_LIMIT_VIDEO2 equ	0000_0000000000000000b	;第16-19位 显存段任然放置在0xB8000~0xBFFFF，段基址应该为0xbffff,
                                                ;段界限应该为(0xbffff-0xb8000)/4k=7(高4位为0)


DESC_P            equ 	1_000000000000000b	  
DESC_DPL_0        equ  00_0000000000000b         
DESC_DPL_1        equ  01_0000000000000b	  
DESC_DPL_2        equ  10_0000000000000b
DESC_DPL_3        equ  11_0000000000000b
DESC_S_sys        equ  0_000000000000b           
DESC_S_CODE       equ  1_000000000000b        
DESC_S_DATA       equ  DESC_S_CODE


;这边存在一个问题，根据书本上的Type格式图里从3~0位数据段的排序应该是xwea，而代码部分则按照xewa的顺序，需要进一步确认
DESC_TYPE_CODE    equ  1000_00000000b            ;第9-11位表示该段状态 1000 可执行 不允许可读 已访问位0
;x=1 e=0 w=0 a=0
DESC_TYPE_DATA    equ  0010_00000000b            ;第9-11位type段   0010  可写  
;x=0 e=0 w=1 a=0



;代码段描述符高位4字节初始化 (0x00共8位 &lt;&lt;24 共32位初始化0) 
;4KB为单位 Data段32位操作数 初始化的部分段界限 最高权限操作系统代码段 P存在表示 状态 
DESC_CODE_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + \
DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00

;数据段描述符高位4字节初始化
DESC_DATA_HIGH4   equ  (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00

;显存段描述符高位4字节初始ua
DESC_VIDEO_HIGH4   equ (0x00&lt;&lt;24) + DESC_G_4K + DESC_D_32 + \
DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + \
DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0B  ;书本上末尾是0，但显存段段基址应该为0xbffff，也就是说这边末尾应该是B 



;-------------------- 选择子属性 --------------------------------
RPL0    equ 00b
RPL1    equ 01b
RPL2    equ 10b
RPL3    equ 11b
TI_GDT  equ 000b
TI_LDT  equ 100b
</code></pre>
<p><strong>PS：在本段代码中对数据段type字段x&#x3D;0 e&#x3D;0 w&#x3D;1 a&#x3D;0之间的顺序尚不明确，是个还没解决的问题，有机会再来回答</strong></p>
<h2 id="loader-S更新"><a href="#loader-S更新" class="headerlink" title="loader.S更新"></a>loader.S更新</h2><pre><code>;loader.S 负责进入保护模式

%include &quot;boot.inc&quot;
SECTION loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR 		   ;是个程序都需要有栈区 栈指针设置为代码段开始地址，一个向下增长，一个向上增长，互不干扰
jmp loader_start                      		   ;跳跃到代码区


    ;构建gpt及其内部的描述符
    ;一共放入4个段描述符，分别是空段描述符、代码段描述符、数据/栈段描述符（共用一个段）、显存段描述符
    ;由于小端序，所以高位字节应放置在高地址(越靠下面地址越高),低位字节放置在低地址
    GDT_BASE:   dd 0x00000000           ;我们说过gdt的第一个段描述符不能用，所以全部置0
                dd 0x00000000 

    CODE_DESC:  dd 0x0000FFFF         	;代码段的段界限应该为0xfffff，段基址应该为0
                dd DESC_CODE_HIGH4

    ;这边数据段和栈段共用一个段（因为栈段本身就是反方向增长的数据段）
    ;有一个小问题：栈段是向下增长的，数据段是向上增长的，它们段描述符type字段的e不相等怎么能共用呢？
    ;其实段描述符e字段并非真正规定了段的增长方向，而是给CPU检测界限的。
    ;比如一个段的界限是4，基址是8；如果e=0向上增长，CPU检测界限边界就是8+4=12，如果e=1向下增长，CPU检测界限边界就是8-4=4
    ;也就是说我把数据段和栈段共用(e=0)并不会影响栈段真正的增长方向，但是会影响CPU对栈顶边界的检测（不过我们这边为了方便就暂时不考虑这个问题。）
    DATA_STACK_DESC:    dd 0x0000FFFF   ;数据/栈段的段界限应该为0xfffff，段基址应该为0
                        dd DESC_DATA_HIGH4

    VIDEO_DESC: dd 0x80000007         		   ;显存基址是0xB8000（B在高32位），界限是(bFFFF-b8000)/4k = 0x7
                dd DESC_VIDEO_HIGH4     	  
                    
    GDT_SIZE    equ $ - GDT_BASE               ;当前位置减去GDT_BASE的地址 等于GDT的大小
    GDT_LIMIT   equ GDT_SIZE - 1   	           ;SIZE - 1即为最大偏移量，GDT的偏移量是要放在GDTR里的，单位固定是1字节，和段描述符中的段界限不同

    times 60 dq 0                              ;预留60个 四字型 描述符


    ;构造16位的段选择子
    SELECTOR_CODE        equ (0X0001&lt;&lt;3) + TI_GDT + RPL0    
    SELECTOR_DATA	  equ (0X0002&lt;&lt;3) + TI_GDT + RPL0
    SELECTOR_VIDEO       equ (0X0003&lt;&lt;3) + TI_GDT + RPL0


    ;gdt指针（要放置在GDTR的48位内存数据） 
    ;2字gdt界限放在前面 4字gdt地址放在后面 
    ;lgdt 48位格式 低位16位界限 高位32位起始地址
    gdt_ptr         dw GDT_LIMIT
                    dd GDT_BASE


    loadermsg db   &#39;welcome to loader zone!&#39;                  ;loadermsg 加载区显示字符


;以下代码则是正式进入保护模式
loader_start:

    ;这段和之前一样，调用BIOS提供的int10功能显示字符
    mov sp,LOADER_BASE_ADDR					
    mov bp,loadermsg                                           
    mov cx,23     
    mov ax,cs                                                 
    mov es,ax                                                 
    mov ax,0x1301                                             
    mov bx,0x001f                                           
    mov dx,0x1800                                             
    int 0x10
    
    ; --------------------------------- 设置进入保护模式 -----------------------------
    ; 1 打开A20 gate 
    in al,0x92                
    or al,0000_0010b
    out 0x92,al

    ; 2 加载gdt
    lgdt [gdt_ptr] 

    ; 3 将cr0 的 pe位置1
    mov eax,cr0                
    or  eax,0x00000001              
    mov cr0,eax
    
    ;-------------------------------- 已经打开保护模式 ---------------------------------------
    jmp dword SELECTOR_CODE:p_mode_start                       
    

[bits 32]
p_mode_start: 
    ;是初始化段选择子
    mov ax,SELECTOR_DATA
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov esp,LOADER_STACK_TOP
    mov ax,SELECTOR_VIDEO
    mov gs,ax
    
    ;测试显存段
    mov byte [gs:160],&#39;P&#39;
    
    jmp $     
</code></pre>
<h2 id="mbr-S更新"><a href="#mbr-S更新" class="headerlink" title="mbr.S更新"></a>mbr.S更新</h2><p>由于loader.S编译出来的loader.bin的大小已经超出了一个扇区也就是512字节，所以我们需要将mbr.S里调用装载loader函数前传参从<code>mov cx,1</code>改成<code>mov cx,4</code>（假设loader.bin占据了4个扇区，这样以后就不用每次更新都要修改）</p>
<p>还有dd指令装载loader.S时也要有相应的更改,将<code>count=1</code>改为<code>count=4</code></p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>屏幕显示如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img11.png" alt="img"></p>
<p>可以用<code>info gdt</code>查看构建的gdt:</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img12.png" alt="img">  </p>
<h1 id="处理器微架构简介-jmp清空流水线"><a href="#处理器微架构简介-jmp清空流水线" class="headerlink" title="处理器微架构简介(jmp清空流水线)"></a>处理器微架构简介(jmp清空流水线)</h1><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>指令并不是以原子的形式执行的，而是可以被拆分的。我们把一条指令拆分成三部分取指、译码、执行，CPU在一个时间段内无法执行两个执行，但是在一个时间段内可以同时执行取值&#x2F;译码&#x2F;执行。</p>
<p>这样可以大大缩短执行时间，三级流水线技术如下图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img13.png" alt="img"></p>
<p>如果原子性地执行3条指令需要9个周期，采用流水线技术就可以在5个周期内执行3条指令</p>
<p>在流水线基础上，我们发现一个规律：影响流水线效率地关键在分割的细度，分割得越细，执行得越快</p>
<p>你可以假想一下将一条指令划分为4个部分的四级流水线，4级流水线执行速度就将比3级更快</p>
<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>CPU并非一直按照顺序执行命令，而是按照一定的策略打乱执行顺序（当然，有相关关系的指令顺序不能被打乱），来提升速度</p>
<p>如以下代码：</p>
<pre><code>mov eax,[0x1234]
add ecx,ebx
</code></pre>
<p>两条指令并没有因果关系，因此在第一条指令等待内存访问时，第二条指令将会先执行，以此提高整体速度</p>
<p>再看以下代码：</p>
<pre><code>mov eax,[0x1234]
push eax
call function
</code></pre>
<p>第一条指令和第二条指令之间存在相关关系，那它就不能乱序执行了吗？不完全是。</p>
<p>第二条指令本质上可以被划分为两个微操作:<code>sub esp,4</code>和<code>mov [esp],eax</code>,我们发现只有<code>mov [esp],eax</code>和第一条指令相关。</p>
<p>因此CPU乱序执行可以在等待第一条指令的内存访问时执行<code>sub esp,4</code>，甚至还会先执行第三条指令</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>基于时间局部性和空间局部性原理发明的硬件(SRAM),当CPU需要去访问内存时先看看缓存，缓存有的话就不用去内存了，大大提高速度。</p>
<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>分支预测时针对有条件跳转指令(if&#x2F;switch&#x2F;for&#x2F;while)在流水线上糟糕的表现研发出的技术</p>
<p>我们发现流水线技术里你执行当前指令的同时（或者说当前指令还没执行完），你就必须知道下一条指令是什么并且进行操作。</p>
<p>如果所有指令都是顺序的话，那当然没什么问题。但是程序都是有分支的(有条件跳转指令)，假想我们现在在执行一条有条件跳转指令，那请问流水线的下一步要取那一条指令？要取左边的指令还是取右边的指令？如果出错了我们就必须花费一定的代价来清除流水线。</p>
<p>最简单的分支预测是根据上一次是否跳转来执行，如果上一次跳转了，那么我们预测这一次也跳转（想想循环指令就明白为什么了）</p>
<p>Intel的分支预测部件中用了分支目标缓冲区(Branch Target Buffer,BTB)如下图:</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img14.png" alt="img"></p>
<p>本质上就是根据过往统计次数来判断下一次是否跳转</p>
<h2 id="为什么使用远跳转指令来清空流水线"><a href="#为什么使用远跳转指令来清空流水线" class="headerlink" title="为什么使用远跳转指令来清空流水线"></a>为什么使用远跳转指令来清空流水线</h2><p>我们使用<code>jmp dword SELECTOR_CODE:p_mode_start</code>来更新流水线，究竟是为什么？</p>
<ol>
<li><p>段描述缓冲寄存器未更新</p>
<p> 32位CPU兼容保护模式和实模式，段缓存寄存器在实模式下和保护模式下都有用。实模式下：段描述缓冲寄存器用于缓存段基址，保护模式下：段描述缓冲寄存器缓存段描述符。只有当CPU重新引用一个段后，段描述缓冲寄存器才会更新。</p>
<p> 当我们从实模式到保护模式后，我们的段描述缓存寄存器存在的还是实模式下用的20位段基址，这当然是不行的。所以我们指令跳转到<code>SELECTOR_CODE:p_mode_start</code>相当于重新引用一个段，让它更新。</p>
</li>
<li><p>流水线中指令译码错误</p>
<p> 从实模式到保护模式，一开始我们是16位指令，后来是32位指令。因为CPU的流水线技术提前被加载进流水线的32位指令可能会被译码错误成16位指令。因此我们使用无条件跳转指令jmp,跳转过后会自动清空流水线，避免译码错误。</p>
</li>
<li><p>dword</p>
<p> dword则是让编译器将<code>p_mode_start</code>当成32位操作数处理保证得到正确的地址</p>
</li>
</ol>
<h1 id="保护模式提供的保护"><a href="#保护模式提供的保护" class="headerlink" title="保护模式提供的保护"></a>保护模式提供的保护</h1><p>这里围绕对内存段的保护做基本的阐述，其他方面的保护，如特权级以后再说</p>
<h2 id="向段寄存器加载选择子时提供的保护"><a href="#向段寄存器加载选择子时提供的保护" class="headerlink" title="向段寄存器加载选择子时提供的保护"></a>向段寄存器加载选择子时提供的保护</h2><p>当引用一个内存段时，实际上就是往段寄存器加载选择子，为了避免出现非法访问内存段的情况，处理器为做以下检测：</p>
<ol>
<li><p>判断选择子的索引值是否越界(0&lt;选择子的索引值&lt;8192)</p>
</li>
<li><p>检测段寄存器的用途和段类型是否匹配，大致原则如下：</p>
</li>
</ol>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/img15.png" alt="img"></p>
<ol start="3">
<li>检测段描述符的P位，判断其是否存在</li>
</ol>
<h2 id="对代码段和数据段的保护"><a href="#对代码段和数据段的保护" class="headerlink" title="对代码段和数据段的保护"></a>对代码段和数据段的保护</h2><p>CPU每访问一个地址，都要确定其地址不能超过其所在内存段的范围</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/10/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/10/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-10 13:28:18" itemprop="dateCreated datePublished" datetime="2023-11-10T13:28:18+08:00">2023-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-11 17:02:44" itemprop="dateModified" datetime="2023-11-11T17:02:44+08:00">2023-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们将在上一章节的基础上完善MBR,学会使用IO接口的两种方法</p>
<p>相应的本章一共要完成两个实验：一个是MBR使用显存和显卡沟通，另一个是MBR通过端口将磁盘上的loader程序加载到内存相应位置</p>
<h1 id="地址、section和vstart"><a href="#地址、section和vstart" class="headerlink" title="地址、section和vstart"></a>地址、section和vstart</h1><ol>
<li><p>地址</p>
<p> 地址只是数字，描述各种符号在源程序中的位置，它是源代码文件中符号<strong>偏移</strong>文件开头的位置。编译器的工作就是给代码里的各符号编址。</p>
<p> 下图给出了一个程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img1.png" alt="img"></p>
<p> 仔细观察图片可得到这样一种关系：地址&#x3D;上一个地址+上一个地址内容的长度</p>
<p> 于是我们得出一个关于地址的结论：编译器给程序中各符号（变量名或函数名）分配的地址就是各符号相对于文件开头的<strong>偏移量</strong></p>
</li>
<li><p>section</p>
<p> 编译器提供section关键字（伪指令）是为了让程序员在逻辑上将程序划分为几个部分。一般section的应用场景就是根据不同的属性人为地讲程序划分几部分，如数据放在一个section中，指令放在另一个section中。</p>
<p> 下图给出了一个包含section分段程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img2.png" alt="img"></p>
<p> <strong>PS：程序第三行地section.data.start代表地是名为data的section在本文件中相对于文件开头的偏移量</strong></p>
<p> 仔细观察图片我们得出结论：关键字section并没有对程序中的地址产生任何影响，seciton仅仅是为了让开发人员梳理程序之用。</p>
</li>
<li><p>vstart：</p>
<p> vstart的作用是为section内的数据指定一个虚拟的起始地址。</p>
<p> 下图给出了一个包含vstart修饰section分段程序的 源码、地址、反汇编代码：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img3.png" alt="img"></p>
<p> 仔细观察图片，首先我们确定vstart对数据本身在文件的真实物理地址没有任何影响。</p>
<p> 那vstart影响的是什么? vstart影响的是虚拟段基址的值。在没有vstart的情况下，每个段的虚拟段基址默认是上一个段的结尾（首段虚拟段基址默认为0）；有了vstart后，就人为规定了虚拟的段基址。</p>
<p> vstart的使用时机：我们预先知道我们的程序将来被加载到某地址。</p>
<p> <strong>PS：vstart&#x3D;xxxx，并不是告诉编译器要把程序加载到地址xxxx，而是开发人员事先知道这段程序会被加载到xxxx，为了保证程序后续地址（相对文件开头地址的偏移量）的正确性，我们使用vstart提前告诉编译器：这个文件数据的相对地址不再是相对于上一个段末尾或者0了，而是要相对于xxxx，编译器编译时就会计算<code>xxxx+地址（相对文件开头地址的偏移量）</code>得到正确地址</strong></p>
</li>
</ol>
<h1 id="CPU的实模式"><a href="#CPU的实模式" class="headerlink" title="CPU的实模式"></a>CPU的实模式</h1><p>实模式是指8086CPU的工作环境、工作内容、工作状态一整套内容（寻址方式、寄存器大小、指令用法等），而不是单一某个方面的内容。</p>
<p>实模式的特点如下：</p>
<ol>
<li><p>CPU只能寻址1MB范围的物理内存（并不代表内存大小1MB），因为它只有20位地址线</p>
</li>
<li><p>实模式下操作系统和应用程序的执行权限都一样，没有任何保护；实模式下应用程序也可随意修改操作系统的内存（当然这是不安全的）</p>
</li>
<li><p>实模式中CPU使用分段的内存管理模式，即<code>物理地址=段基址&lt;&lt;4+段内偏移</code>，实模式中的逻辑地址就是物理地址，没有虚拟地址一说。</p>
</li>
<li><p>实模式中CPU使用中断向量表来响应中断</p>
</li>
<li><p>实模式下所有寄存器都是16位</p>
</li>
<li><p>实模式的寻址方式可分为三大类寄存器寻址、立即数寻址、内存寻址；其中内存寻址又可以分为直接寻址、基址寻址、变址寻址、基址变址寻址</p>
</li>
</ol>
<p>总而言之：你在汇编语言中接触到的相关知识，基本就是实模式下的相关知识。建议学习<code>王爽的《汇编语言》</code></p>
<h1 id="改进MBR：通过显存与显卡沟通"><a href="#改进MBR：通过显存与显卡沟通" class="headerlink" title="改进MBR：通过显存与显卡沟通"></a>改进MBR：通过显存与显卡沟通</h1><p>上一章节中我们的MBR是通过BIOS提供的中断例程实现的，BIOS提供的中断例程利用了只有在实模式下才可使用的中断向量表，由于我们进入保护模式后无法调用BIOS提供的中断例程，所以我们必须学会直接显卡沟通。</p>
<ol>
<li><p>CPU如何与外设通信？</p>
<p> CPU与外设的通信采用：<code>CPU——IO接口——外设</code>的形式。不同外设有不同的协议、不同的规则、不同的速度等，CPU无需关心这些，由IO接口来负责二者之间的沟通交流，CPU只需要知道怎样和IO接口沟通就行，如图式结构：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img4.png" alt="img"></p>
<p> <strong>PS：南桥芯片又叫输入输出控制中心，用于连接一些低速设备，可以把它看作是IO接口的集合管理中心</strong></p>
</li>
<li><p>CPU如何与IO接口通信？</p>
<p> IO接口可以提供两种方式与CPU沟通，一种是IO内存、另一种是IO端口。</p>
<p> IO内存是将外设的寄存器映射到CPU的地址空间中，使得CPU可以用内存访问指令来访问外设，如同访问内存一样。此时写入特定位置的内存，就相当于写入外设的寄存器里。</p>
<p> IO端口是将外设的寄存器分配一个唯一的地址，使得CPU可以用专门的<code>in/out</code>(输入输出指令)来访问外设。</p>
</li>
<li><p>CPU使用IO内存与显卡沟通</p>
<p> 显存是显卡中的一块内存，显卡所做的工作就是不断将显存里的数据放到显示器上。</p>
<p> 显存被映射到CPU的内存中的地址如下：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img5.png" alt="img"></p>
<p> 我们只需要往<code>0xB80000~0xBFFFF</code>32KB大的显存映射范围内里写入数据，就可以实现直接让数据显示到显示屏上。</p>
<p> 显卡在加电后，屏幕默认输出格式是80*25，也就是一屏幕共可以输出2000个字符。其中每个字符需要两字节表示，低位字节代表字符的ASCII码，高位字节代表字符的属性信息。32KB&#x2F;4000Byte约等于8屏幕数据，也就是说显存一次输出可以输出8个屏幕的数据。</p>
<pre><code> ; 修改后的MBR代码如下：实现直接与显卡沟通在屏幕上打印字符

 SECTION MBR vstart=0x7c00
     ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

     mov ax,cs
     mov ds,ax
     mov es,ax
     mov ss,ax
     mov fs,ax
     ;利用CS=0初始化各个段寄存器
     mov sp,0x7c00
     ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

     mov ax,0xb800;
     mov gs,ax
     ;令附加段基址寄存器gs指向显存映射地址

 ;------------------------------------------------------------------------------------------
     ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

     mov ax,0x600
     mov bx,0x700
     mov cx,0
     mov dx,0x184f

     int 0x10

 ;------------------------------------------------------------------------------------------
     ;以下代码直接向显存输入数据，实现打印输出背景色绿色，前景色红色，并且跳动的字符串&#39;1 MBR&#39;

     mov byte [gs:0x00],&#39;1&#39;
     mov byte [gs:0x01],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x02],&#39; &#39;
     mov byte [gs:0x03],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x04],&#39;M&#39;
     mov byte [gs:0x05],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x06],&#39;B&#39;
     mov byte [gs:0x07],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

     mov byte [gs:0x08],&#39;R&#39;
     mov byte [gs:0x09],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

 ;------------------------------------------------------------------------------------------

     jmp $ ;实现死循环，让程序悬停

     times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
     db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
</li>
</ol>
<h1 id="bochs的调试方法-插曲"><a href="#bochs的调试方法-插曲" class="headerlink" title="bochs的调试方法(插曲)"></a>bochs的调试方法(插曲)</h1><p>请运行bochs后，输入<code>help</code>，即可看到bochs相关的所有调试指令</p>
<p>指令大概分为四类：Debugger control、Execution control、Breakpoint control、CPU and memory contents</p>
<p>针对大类里的每一个指令，都可以输出<code>help &#39;指令关键字&#39;</code>来查看该指令的具体用法</p>
<p>不需要对每个指令死记硬背，多多尝试就熟悉了</p>
<h1 id="改进MBR：与磁盘沟通"><a href="#改进MBR：与磁盘沟通" class="headerlink" title="改进MBR：与磁盘沟通"></a>改进MBR：与磁盘沟通</h1><ol>
<li><p>in&#x2F;out 命令</p>
<p> CPU提供了专门的指令来和IO接口进行端口沟通：</p>
<ul>
<li><p>in指令用于从端口中读取数据，格式如下：</p>
<pre><code>  in al,dx
  in ax,dx
</code></pre>
<p>  只要使用in指令，源操作数必须是dx(存放端口号)，而目的操作数是用al，还是ax取决于dx端口指代的寄存器是8位宽还是16位宽</p>
</li>
<li><p>out 指令用于往端口中写数据，格式如下：</p>
<pre><code>  out dx,al
  out dx,ax
  out 立即数,al
  out 立即数,ax
</code></pre>
<p>  out指令的源操作数是ax还是al取决于目标端口指代的寄存器是8位宽还是16位宽，源操作数可以是立即数直接给出端口号，也可以用dx（存放端口号）</p>
</li>
</ul>
</li>
<li><p>磁盘IO端口相关知识</p>
<ul>
<li><p>什么是硬盘控制器？</p>
<p>  硬盘控制器是CPU于硬盘沟通中间的IO接口</p>
</li>
<li><p>Primary通道和Secondary通道</p>
<p>  以前的主机一般只接受四个并口磁盘。主板上提供了两个IDE（Integrated Drive Electronics，硬盘控制器和硬盘集成在一起的集成设备电路）插槽。用Primary通道和Secondary通道来区分这两个不同的IDE，用于连接硬盘和主板。每个通道可以挂载两个硬盘，分别称为主盘（Master）和从盘（Slave）。主盘和从盘的区别主要是在启动顺序和数据传输上，一般来说，主盘优先于从盘启动，而从盘的数据传输需要经过主盘。每个通道都有自己的一组端口寄存器，用于控制和访问硬盘。</p>
<p>  当然上面的描述是以前主机的硬盘布局，现在的大有不同了，但我们学习使用较为简单的以前主机的IO接口相关知识。</p>
</li>
<li><p>LBA和CHS</p>
<p>  一个磁盘里有很多个扇区，要描述一个扇区的具体位置可以通过多种方法。</p>
<p>  一般口头上描述扇区的位置可以用“柱面-磁头-扇区”来定位（Cylinder Head Sector），简称为CHS。CHS描述法的扇区并非是从0开始的，而是从1开始的。</p>
<p>  CHS描述是从物理结构上来描述的，但我们希望在编程时可以不用考虑磁盘的物理结构，只需要通过逻辑结构来定位扇区就行了，于是有了LBA（Logical Block Address）</p>
<p>  LBA有LBA28和LBA48两种。我们只介绍LBA28：就是通过28位bit来描述一个扇区的位置，最大的寻址范围是2^28。</p>
<p>  向磁盘沟通时，端口寄存器必须要知道你是向哪一块磁盘沟通，也就是说知道LBA28。我们用3个8位寄存器（LBA low、LBA mid、LBA high）以及device寄存器其中的4位一共28位表示LBA28</p>
</li>
<li><p>硬盘控制器主要端口寄存器</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img6.png" alt="img"></p>
<ul>
<li><p>我们在与磁盘沟通时，首先要确认我们是与哪一个通道的主盘&#x2F;从盘沟通，然后查看这张表中对应的端口号，以Primary通道为例：</p>
</li>
<li><p>0x1F3、0x1F4、0x1F5三个端口号不论是读操作还是写操作时都是用来记录LBA28低24位的地址的（标记你是与那一块扇区沟通）</p>
</li>
<li><p>0x1F0 端口号映射Data寄存器，写操作时，从外面往里面写数据进去；读操作时，从里面往外读数据出来。<strong>该端口是这里唯一的16位寄存器，其余端口都是8位</strong></p>
</li>
<li><p>0x1F1 读操作时用于存放失败状态信息，写操作时用于存放写操作参数</p>
</li>
<li><p>0x1F2 读操作时用于存放要读取的扇区数，写操作是用于存放要写入的扇区数</p>
</li>
<li><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/img7.png" alt="img"></p>
<p>  0x1F6 读写时都是device寄存器，也就是驱动器，具体功能见上图：0~3位放置LBA28的高4位，4位指定是主盘还是从盘，5~7位指定寻址模式（CHS为101，LBA为111）</p>
<p>  0x1F7 写操作时用于写入命令，一旦写入命令磁盘立即指向，主要有三个命令(1) 0xEC，硬盘识别 （2）0x20，读扇区 （3）0x30，写扇区。读操作时则是statue寄存器，具体功能见上图</p>
</li>
</ul>
</li>
<li><p>约定好的IO端口沟通操作顺序</p>
<p>  了解了这些寄存器的功能后我们就可以知道如何与磁盘进行沟通了，但第一步我们先约定一个操作执行顺序，确保大家不会乱（当然你不按照这个顺序也行）：</p>
<ol>
<li><p>先选择通道，往该通道的sector cout寄存器写入待操作的扇区数</p>
</li>
<li><p>往通道上的三个LBA写入扇区地址LBA28的低24位</p>
</li>
<li><p>往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式</p>
</li>
<li><p>往该通道的command寄存器写入命令（一旦写入立即执行）</p>
</li>
<li><p>读取status寄存器，判断硬盘工作是否完成</p>
</li>
<li><p>如果上诉是写操作，则到此完工；如果上诉是读操作，则还需要一步</p>
</li>
<li><p>将硬盘数据读出</p>
</li>
</ol>
<p>  <strong>PS：操作并不是单纯的读，我们要读取一块扇区上的数据，我们要做的一步是把读取命令写入command寄存器，注意，是写入！也就是说读操作中也包含写入的过程</strong></p>
</li>
<li><p>常用的数据传输方式</p>
<p>  当我们要读取硬盘中的某个扇区，我们先写入读取命令并判断硬盘工作已经完成，在判断硬盘工作是否完成(上述5操作)这一步我们区分出了不同的数据传输方式</p>
<ol>
<li><p>无条件传输：数据源设备随时准备好数据，CPU随取随拿，如寄存器、内存等设备，CPU无需提前打招呼。</p>
</li>
<li><p>查询传送方式：CPU按照一定间隔不断去检测设备是否完成操作，如果完成，则CPU去取数据</p>
</li>
<li><p>中断传送方式：CPU无需不断检测，而是当设备完成时触发中断，由中断来通知CPU我数据已经准备好了</p>
</li>
<li><p>直接存储器存取方式（DMA）：不让CPU参与传输，完全由数据源设备和内存直接传输，CPU直接到内存中拿数据即可</p>
</li>
<li><p>I&#x2F;O处理机传送方式：引入完整的一套硬件来处理这些事，CPU甚至不知道有传输这回事</p>
</li>
</ol>
<p>  <strong>PS:方式1磁盘用不了，方式4、5则需要硬件支持，所以在我们与硬件沟通时采用方式2或3</strong></p>
</li>
</ul>
</li>
<li><p>接力第三棒：loader</p>
<p> 我们的MBR受限于512字节的关系，无法做太多的事：没法为内核准备好环境，更没法将内核成功加载到内存并允许。</p>
<p> 所以我们要在另一个程序中完成初始化环境以及加载内核的任务，这个程序就是加载器loader</p>
<p> loader的源代码自然也是存在磁盘里的，MBR要负责从硬盘上把loder加载到内存，并把接力棒交给loader</p>
</li>
<li><p>修改后的代码</p>
<ul>
<li><p>boot.inc(头文件)</p>
<pre><code>  LOADER_BASE_ADDR equ 0x900
  ;我们要将loader装载到内存中的可用区域，查询上一章节的1MB内存布局图可看出只有两个位置是可用的：0x500~0x7BFF,0x7E00~0x9FBFF
  ;我们希望让loader位置在低地址，以便可以空位更多的空间给未来的内核程序加载
  ;至于为什么不选择0x500而是0x900，则是因为想让程序与程序之间有一点空格 

  LOADER_START_SECTOR equ 0x2
  ;用LBA描述，磁盘里的第0块扇区已经用于存放MBR代码了
  ;为了保险起见让扇区之间有间隔，所以loader存放在第2块扇区
</code></pre>
</li>
<li><p>MBR.S</p>
<pre><code>  ; 主引导程序 MBR ：实现从硬盘上加载loader到内存中，并将接力棒交给loader

  %include &quot;boot.inc&quot;
  ;连接头文件，定义了LOADER_BASW_ADDR、LOADER_START_SECTOR

  SECTION MBR vstart=0x7c00
      ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

      mov ax,cs
      mov ds,ax
      mov es,ax
      mov ss,ax
      mov fs,ax
      ;利用CS=0初始化各个段寄存器
      mov sp,0x7c00
      ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

      

  ;------------------------------------------------------------------------------------------
      ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

      mov ax,0x600
      mov bx,0x700
      mov cx,0
      mov dx,0x184f

      int 0x10

  ;------------------------------------------------------------------------------------------
      ;以下是通过寄存器传递参数并调用 loader_ready_proc

      mov eax,LOADER_START_SECTOR ;eax记录LBA28，也就是loader在磁盘上的扇区地址
      mov bx,LOADER_BASE_ADDR     ;bx记录loader将要被移动到内存里哪个位置
      mov cx,1                    ;cx记录移动的扇区数

      call loader_ready_proc      ;调用函数装载loader
      jmp LOADER_BASE_ADDR        ;跳转到被装载到内存里的loader，将接力棒交给它
  ;------------------------------------------------------------------------------------------
  ;该函数的功能是装载loader
  loader_ready_proc:
      mov esi,eax                 ;ax会在后续in/out指令被使用，所以备份参数
      mov di,cx                   ;di会在后续循环中被用到，所以备份参数


      ;第一步：先选择通道，往该通道的sector cout寄存器写入待操作的扇区数
      mov ax,di
      mov dx,0x1f2
      out dx,al

      mov eax,esi                  ;复原eax


      ;第二步往通道上的三个LBA写入扇区地址LBA28的低24位
      mov dx,0x1f3
      out dx,al

      mov cl,8
      shr eax,cl       
      mov dx,0x1f4     
      out dx,al

      shr eax,cl
      mov dx,0x1f5
      out dx,al

      
      ;第三步 往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式
      shr eax,cl
      and al,0x0f
      or al,0xe0
      mov dx,0x1f6
      out dx,al


      ;第四步往该通道的command寄存器写入命令（一旦写入立即执行）
      mov dx,0x1f7
      mov al,0x20
      out dx,al


      ;第五步读取status寄存器，判断硬盘工作是否完成(这边采用查询传输的方式)
  .not_ready:
      nop            ;增加循环查询的延迟
      in al,dx
      and al,0x88
      cmp al,0x08
      jnz .not_ready


      ;最后一步将硬盘数据读出
      mov ax,di
      mov dx,256
      mul dx
      mov cx,ax
      ;一个扇区512字节，要读取di个扇区，每次读取2字节(16位的data寄存器),一共要循环读取di*512/2次

      mov dx,0x1f0
  .go_on_read:
      in ax,dx
      mov [bx],ax
      add bx,2
      loop .go_on_read

      ;函数loader_ready_proc结束返回
      ret


      times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
      db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
</li>
<li><p>loader.S</p>
<pre><code>  ;这串代码并非实现真正的loader功能，而是只是在屏幕上打印字符，来验证我们是否真正装载并执行了loader


  %include &quot;boot.inc&quot;

  section loader vstart=LOADER_BASE_ADDR

      mov ax,0xb800;
      mov gs,ax
      ;令附加段基址寄存器gs指向显存映射地址

  ;输出背景色绿色，前景色红色，并且跳动闪烁的字符串&quot;2 LOADER&quot;

      mov byte [gs:0x00],&#39;2&#39;
      mov byte [gs:0x01],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x02],&#39; &#39;
      mov byte [gs:0x03],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x04],&#39;L&#39;
      mov byte [gs:0x05],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x06],&#39;O&#39;
      mov byte [gs:0x07],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x08],&#39;A&#39;
      mov byte [gs:0x09],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0A],&#39;D&#39;
      mov byte [gs:0x0B],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0C],&#39;E&#39;
      mov byte [gs:0x0D],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      mov byte [gs:0x0E],&#39;R&#39;
      mov byte [gs:0x0F],0xA4   ;A 表示绿背景闪烁，4表示前景色红色

      jmp $
</code></pre>
</li>
<li><p>一个小细节<br>  这些代码中默认我们的虚拟磁盘是Primary通道的主盘，可能有人会疑惑为什么是Primary通道的主盘，详细信息请看配置文件bochsrc.disk，如下所示</p>
<pre><code>  ata0:enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14
  ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat,cylinders=121,heads=16,spt=63
  # ata0代表IDE0也就是Primary通道，atao-master代表的是Primary通道的主盘
</code></pre>
</li>
</ul>
</li>
<li><p>装载代码</p>
<p> 我们现在有三个文件：头文件boot.inc、mbr.S、loader.S</p>
<ul>
<li><p>boot.inc<br>  请在代码文件夹下创建一个文件夹include,把boot.inc放在include下面，用于被其他文件引用链接</p>
</li>
<li><p>mbr.S<br>  我们使用在原有的命令上添加了include路径：</p>
<pre><code>  nasm -I include/ -o mbr.bin mbr.S
</code></pre>
<p>  然后继续使用dd命令将他装载到hd60M.img的第一块扇区:</p>
<pre><code>  dd if=/home/sparkle2/codeset/mbr.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 conv=notrunc
</code></pre>
</li>
<li><p>loader.S<br>  我们同样用带有include路径的命令编译它:</p>
<pre><code>  nasm -I include/ -o loader.bin loader.S
</code></pre>
<p>  然后继续使用dd命令将他装载到hd60M.img的第三块扇区（seek&#x3D;2代表跳过两块）:</p>
<pre><code>  dd if=/home/sparkle2/codeset/loader.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 seek=2 conv=notrunc
</code></pre>
</li>
</ul>
<p> 最后运行命令<code>bin/bochs -f bochsrc.disk</code>看到屏幕上出现<code>2 loader</code>的输出字符实验就成功了</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/09/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/09/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-09 23:15:59" itemprop="dateCreated datePublished" datetime="2023-11-09T23:15:59+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-11 17:01:58" itemprop="dateModified" datetime="2023-11-11T17:01:58+08:00">2023-11-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在这一章，我们编写一段MBR程序并装载在磁盘里，开始接手操作系统的第一步。</p>
<h1 id="BIOS与MBR的职责和功能"><a href="#BIOS与MBR的职责和功能" class="headerlink" title="BIOS与MBR的职责和功能"></a>BIOS与MBR的职责和功能</h1><p>下图是1MB寻址范围内存空间在实模式下的内存布局（注意区分寻址范围和空间大小的区别，实模式由于20位地址总线所以最大寻址范围是1MB，但这不代表内存空间大小就1MB，实际内存大小是1MB*Byte）：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img1.jpg" alt="img"></p>
<p><strong>PS：0x00000~0x9FFFF是RAM，0xA0000~0xFFFFF是ROM</strong><br><strong>你可能会觉得疑惑：一定要如此布局吗？</strong><br><strong>该布局方式源于早期系统，其中一些魔数（特别的数，像是为什么MBR其实地址在0x7C00）也是早期约定好的规矩，而后来的设备为了可以兼容早期设备都遵守这些规矩</strong></p>
<p>BIOS全称叫Base Input&amp;Output System，即基本输入输出系统，是固化在ROM上的一段程序</p>
<p>电脑上电后运行的第一个软件就是BIOS，也就是CS:IP在硬件支持下一上电即为<code>0xF000:0xFFF0</code>（BIOS的入口地址）。BIOS的入口地址处是一条跳转指令<code>jmp far f000:e05b</code>,CPU跳转并开始执行BIOS的程序，开始检测内存、显卡等外设信息，初始化硬件，并在<code>0x000~0x3FFF</code>处建立中断向量</p>
<p>BIOS的最后一项工作是校验启动盘中位于<code>0盘0道1扇区</code>（相当于0盘0道0扇区，1扇区和0扇区只是描述方法不同）的内容，如果此时扇区末尾的两个字节分别是0x55和0xaa，BIOS便将该扇区的内容认定为待装载的MBR程序（Main Boot Record 主引导记录），将其加载道物理地址0x7c00处，然后将控制权MBR，执行MBR程序</p>
<p>通俗地说：BIOS就是接力手的第一棒，MBR就是第二棒</p>
<p>我们的目的就是编写MBR程序，并装载到启动盘的<code>0盘0道1扇区</code>处，由我们来接手第二棒</p>
<h1 id="必须要了解的相关知识点"><a href="#必须要了解的相关知识点" class="headerlink" title="必须要了解的相关知识点"></a>必须要了解的相关知识点</h1><ol>
<li><p>MBR的大小必须是512字节，而且得保证0x55和0xaa在该扇区的这两个魔数出现在510字节和511字节</p>
</li>
<li><p>x86平台是小端序（低位字节放在低地址），也就是说对于0xaa55这条指令来说，0xaa高位字节放在高地址（511），0x55低位字节放在低地址（510）</p>
</li>
<li><p>$和$$是NASM预留的关键字，$是表示本行代码起始地址的标号，$$是表示本section代码起始地址的标号</p>
</li>
<li><p>section可以用vstart&#x3D;xxxx修饰，表示section的虚拟起始地址设置为xxxx</p>
</li>
<li><p>我们知道BIOS在扫描完0xaa55后会装载并跳转道0x7c00，这一步也是由硬件支持，CS:IP会被强制设置为<code>0x0000:0x7c00</code></p>
</li>
<li><p>NASM指令格式：<code>nasm -f &lt;format&gt; &lt;filename&gt; [-o &lt;output&gt;]</code> 其中<code>-f &lt;format&gt;</code>是指令输出文件格式，<code>&lt;filename&gt;</code>是目标文件名， <code>-o &lt;output&gt;</code>是指令输出文件名</p>
</li>
<li><p>关于输出文件格式有很多种，我们这里只关注bin和elf：bin是纯二进制文件（给CPU就可以直接运行）；elf是二进制可执行文件（里面参杂了些和指令无关的修饰，是给操作系统的程序加载器使用的）</p>
</li>
</ol>
<h1 id="MBR程序"><a href="#MBR程序" class="headerlink" title="MBR程序"></a>MBR程序</h1><p>编写文本文件 mbr.S </p>
<pre><code>; 主引导程序 MBR ：实现屏幕上打印字符&#39;1 MBR&#39;

SECTION MBR vstart=0x7c00
    ;vstart 指定程序装载地址位0x7c00（约定的MBR装载到内存上的地址）

    mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    ;利用CS=0初始化各个段寄存器
    mov sp,0x7c00
    ;栈顶指针sp指向MBR代码装载处0x7c00，MBR代码向下增长，栈顶指针向上增长，二者不会相互影响

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的6号子功能，实现上卷窗口

    mov ax,0x600
    mov bx,0x700
    mov cx,0
    mov dx,0x184f

    int 0x10

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的3号子功能，获取光标位置，在光标处打印字符

    mov ah,3
    mov bh,0
    
    int 0x10

;------------------------------------------------------------------------------------------
    ;以下代码利用BIOS提供的int 10中断的13号子功能，实现打印字符

    mov ax,message
    mov bp,ax

    mov cx,5
    mov ax,0x1301
    mov bx,0x2
    
    int 0x10

;------------------------------------------------------------------------------------------

    jmp $ ;实现死循环，让程序悬停

    message db &quot;1 MBR&quot;
    times 510-($-$$) db 0  ;确保MBR程序有512个字节，不能少也不能多
    db 0x55,0xaa           ;确保MBR程序最后两个字节为0x55和0xaa，BIOS得以识别
</code></pre>
<p><strong>PS:代码中关于BIOS提供的历程int 10具体格式注释中并没有给出，因为这块不重要，如果想知道为什么int 10的功能调用要这么编写可以查BIOS的手册，也可以查看<code>操作系统真象还原 P61</code></strong></p>
<h1 id="编译、装载并启动"><a href="#编译、装载并启动" class="headerlink" title="编译、装载并启动"></a>编译、装载并启动</h1><ol>
<li><p>编译：</p>
<p> 接下来我们要用<code>nasm -f bin mbr.S -o mbr.bin</code>(也可以简写成<code>nasm -o mbr.bin mbr.s</code>)对mbr.S进行编译,编译成功你就可以看到mbr.bin文件了</p>
<p> 我们还得用指令<code>ls -l</code>查看当前目录下所有文件及属性，检测一下mbr.bin文件的大小，是不是刚好512字节不多也不少</p>
</li>
<li><p>转载：</p>
<p> 然后我们要把mbr.bin文件装载到虚拟磁盘<code>hd60M.img</code>中的0盘0道1扇区处，可以使用dd命令：<code>dd if=/home/sparkle2/codeset/mbr.bin of=/home/sparkle2/bochs/hd60M.img bs=512 count=1 conv=notrunc</code></p>
<p> dd命令中<code>if</code>指定要读取的文件路径；<code>of</code>指定装载文件的路径；<code>bs</code>指令块的大小，也就是字节数；<code>cout</code>指令拷贝的块数；<code>conv</code>指定转换文件方式，在追加数据时conv最好用notrunc<br> 方式</p>
</li>
<li><p>启动</p>
<p> 最后我们进入安装目录下，使用命令<code>bin/bochs -f bochsrc.disk</code>启动，bochs emulator处于黑屏状态 在控制台按<code>c</code>进入调试模式，看到如下结果则大功告成：</p>
<p> <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img2.png" alt="img"></p>
<p> <strong>PS:我们可以注意到启动后，电脑上有两个窗口，一个是bochs emulator，另一个是控制台；bochs emulator就是我们模拟的机器。我在关闭bochs emulator是遇到一些问题，请不要直接点击bochs emulator窗口右上角的红叉，会引发关闭不了的问题。正确的做法是可以点击bochs emulator右上角第二行的电源键关闭模拟机器，再关闭控制台。也可以在控制台<code>Ctrl+C</code>退出调试模式，然后输入<code>q</code>退出该进程。</strong></p>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到这里我们就正式接受了电脑启动后的第二棒接力棒，开始正式掌权了。如果看完本文章还有疑惑，建议看下<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117782012">《操作系统真象还原》第二章 —- 编写MBR主引导记录 初尝编写的快乐 雏形已显！</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/08/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/08/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-08 15:08:46" itemprop="dateCreated datePublished" datetime="2023-11-08T15:08:46+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-09 15:06:51" itemprop="dateModified" datetime="2023-11-09T15:06:51+08:00">2023-11-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本系列记录我跟随<code>《操作系统真象还原》</code>制作一个简易的操作系统的全过程</p>
<h1 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h1><p>VMware是一款可以帮你轻松建立并管理虚拟机的工具。<code>操作系统真象还原</code>推荐使用虚拟机管理工具virtualBox，但由于我之前使用过VMware所以选择继续使用VMware</p>
<p>VMware的许可证密钥可以在网上轻松获得</p>
<p>具体的安装步骤请参照<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">八分钟完成VMware和ubuntu系统安装</a>的前半部分</p>
<h1 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h1><p>Ubuntu是以Linux为内核的操作系统，也是我们将来要自制简易操作系统的环境。<code>操作系统真象还原</code>推荐虚拟机安装Centos操作系统（二者都是Linux内核，听说Centos7会有些问题所以选择Ubuntu）</p>
<p>其中我的虚拟机设置是：2*2核、40G硬盘、2G内存；Ubuntu版本是20.04.6（兼容gcc 4）</p>
<p>具体的安装步骤请参照<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1M94y1U7nc/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">八分钟完成VMware和ubuntu系统安装</a>的后半部分</p>
<p><strong>PS：从安装完Ubuntu后应该在执行每一个重要的步骤前给虚拟机拍一个快照，如果执行出错了，我们就可以回到快照处，保证虚拟机的正确性</strong><br><strong>安装Ubuntu时Language选项请选择英语，可以省去很多后续麻烦</strong></p>
<h1 id="安装VMware-Tool"><a href="#安装VMware-Tool" class="headerlink" title="安装VMware Tool"></a>安装VMware Tool</h1><p>VMware Tool可以实现主机和虚拟机之间拖拽传输文件以及通用复制粘贴，大大简化两机之间的交互难度</p>
<p>具体安装步骤请参照该<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YA411k7Lm/?spm_id_from=333.880.my_history.page.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">VMwareTools安装教程</a></p>
<p>如果在执行第二步Ubuntu时不是自定义安装而是简易安装，就有可能会遇到一个问题：ubuntu安装VMware-tools时，虚拟机中的选项是灰色的，点击不了。那么请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhvngchvng/article/details/108603053">ubuntu安装VMware-tools时，虚拟机中的选项是灰色的，点击不了</a></p>
<p><strong>PS：有的虚拟机安装完操作系统就自带安装VMware Tool了，请安装完Ubuntu看看虚拟机菜单，如果选项是’重新安装BMware Tool’就代表已经按照完毕</strong></p>
<h1 id="安装Bochs"><a href="#安装Bochs" class="headerlink" title="安装Bochs"></a>安装Bochs</h1><p>Bochs是一个x86硬件平台的开源模拟器，它可以模拟各种硬件的配置。Bochs模拟的是整个PC平台，包括I&#x2F;O设备、内存和BIOS，某种程度上来说Bochs也是一个虚拟机，我们未来就是要在Bochs上实现操作系统的制作。</p>
<p>我安装的是Bochs2.6.8，Bochs的具体安装步骤请参考<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117751327">《操作系统真象还原》第一章 —- 安装Vmware Station 安装Ubuntu 装载配置Bochs 安装Vmware tools 开始乘帆历险！</a>上半部分。</p>
<p>Bochs的下载我们可以在主机上下载完压缩包后再直接复制到虚拟机里</p>
<p>在解压后的文件夹下打开终端并输入命令</p>
<pre><code>./configure \
--prefix=/home/sparkle2/bochs \
--enable-debugger \
--enable-disasm \
--enable-iodebug \
--enable-x86-debugger \
LIBS=&#39;-lX11&#39; \
--with-x \
--with-x11

#上面的代码中，prefix指定的是安装bochs的路径
#LIBS这一行是原书上没有的，是我遇到第四个报错后查阅资料添加的
#除了最后一句命令外每一句结尾都是&#39; \&#39;代表着命令还未输入完，运行换行继续输入
</code></pre>
<p>等到上述命令得以正确执行后，还需要在Bochs的解压目录下执行两条命令：</p>
<pre><code>make
make install
</code></pre>
<p>Bochs就安装成功了，我们可以在指定路径下看到安装后的bochs文件夹</p>
<p>整个安装过程中我遇到了四个报错</p>
<ol>
<li>缺少C编译器</li>
<li>C++ preprocessor fails sanity check</li>
<li>“ERROR: X windows gui was selected, but X windows libraries were not found.</li>
<li>undefined reference to symbol ‘XSetForeground’</li>
</ol>
<p>其中前两个报错在上述文章中都已解决，第三个报错请参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/geeker_12/article/details/11409009">Ubuntu下安装Bochs各种奇怪错误汇总</a>，第四个报错请参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/cloudblaze/article/details/52752912">[乱七八糟]bochs编译错误之’XSetForeground’</a></p>
<p><strong>PS:在使用apt命令更新或下载一些东西时，有时候需要换源，在etc&#x2F;apt&#x2F;source.list文件中把下载源改为中国地区,否则会出现下载慢下载失败等问题</strong></p>
<h1 id="配置Bochs"><a href="#配置Bochs" class="headerlink" title="配置Bochs"></a>配置Bochs</h1><p>配置Bochs请参照<a target="_blank" rel="noopener" href="https://love6.blog.csdn.net/article/details/117751327">《操作系统真象还原》第一章 —- 安装Vmware Station 安装Ubuntu 装载配置Bochs 安装Vmware tools 开始乘帆历险！</a>下半部分</p>
<p>我的配置文件如下：</p>
<pre><code>megs: 32
# megs书本是32，博客是512，我跟着书本走

romimage: file=/home/sparkle2/bochs/share/bochs/BIOS-bochs-latest
vgaromimage: file=/home/sparkle2/bochs/share/bochs/VGABIOS-lgpl-latest

boot: disk

log: bochs.out

mouse:enabled=0
keyboard:keymap=/home/sparkle2/bochs/share/bochs/keymaps/x11-pc-us.map

ata0:enabled=1,ioaddr1=0x1f0,ioaddr2=0x3f0,irq=14

ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat,cylinders=121,heads=16,spt=63
#新加入的代码，也就是新建立的虚拟磁盘

# gdbstub:enabled=1,port=1234,text_base=0,data_base=0,bss_base=0
</code></pre>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到此，第一步环境的部署就做完了，第二步就可以开始正式写代码了。</p>
<p>只是环境部署就用了将近两天时间，期间反复下载了4次虚拟机，长路漫漫。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">VScode编码不一致问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 22:15:24" itemprop="dateCreated datePublished" datetime="2023-11-04T22:15:24+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:19:23" itemprop="dateModified" datetime="2023-11-06T11:19:23+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文描述并解决在VSCode里遇到的控制台编码与文件编码不一致导致的乱码问题</p>
<h1 id="VSCode控制台介绍"><a href="#VSCode控制台介绍" class="headerlink" title="VSCode控制台介绍"></a>VSCode控制台介绍</h1><p>VSCode里不止只有1个控制台，如下图所示：</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img1.png" alt="img"></p>
<p>图中一共有四个控制台，可通过终端窗口右上角的<code>+</code>进行调整</p>
<ul>
<li><p>PowerShell：VSCode默认采用PowerShell，功能上比cmd更为强大，兼容cmd命令的同时有自己扩展的指令集，用来管理Windows系统和应用程序，执行复杂的脚本和自动化任务。</p>
</li>
<li><p>Git Bash：Git Bash是Git自带的一个终端模拟器，兼容cmd命令的同时扩展了Linux命令和git命令，它可以在Windows上模拟Bash环境（Linux的控制台）。适合习惯使用Linux的用户。</p>
</li>
<li><p>JavaScript调试终端：可以让你在VSCode中直接运行和调试JavaScript代码，而不需要额外的配置或者浏览器。</p>
</li>
<li><p>Command Prompt：基于Dos的传统的cmd命令行，cmd不兼容上述控制台，只能用来执行一些基本的命令和批处理文件。</p>
</li>
</ul>
<p>除了上述四个控制台外，还有在调试代码时跳出的针对不同语言不同的控制台，例如：用于调试C++&#x2F;C代码的cppdbg；用于调试python代码的python Debug Console等等，可以在调试代码时，查看终端窗口右上角的小标题来确定你现在使用的是哪一个控制台</p>
<p>注意：不同的控制台使用的编码是独立不相互影响的，千万不要使用A控制台却去调整B控制台的编码</p>
<h1 id="VSCode文件编码介绍"><a href="#VSCode文件编码介绍" class="headerlink" title="VSCode文件编码介绍"></a>VSCode文件编码介绍</h1><p>VSCode当前文件编码格式可以查看右下角</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img2.png" alt="img"></p>
<p>如图，当前文件编码是UTF-8</p>
<p>如果想要修改该文件编码，可以点击图中的UTF-8</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img3.png" alt="img"></p>
<p>先选择通过目标编码方式保存，再通过目标编码方式打开，这样就成功修改了当前文件的编码格式</p>
<h1 id="常见的编码介绍"><a href="#常见的编码介绍" class="headerlink" title="常见的编码介绍"></a>常见的编码介绍</h1><ul>
<li><p>GBK：针对中文的编码（国内cmd默认的编码方式），在国家标准GB2312的基础上扩展的，向下兼容GB2312，但在国外并不常用。代码是936</p>
</li>
<li><p>UTF-8：UTF-8是一种针对多语言的编码，它包含了全世界所有国家需要用到的字符，基于Unicode字符集的，向下兼容ASCII，在国际上通行。代码是65001</p>
</li>
</ul>
<h1 id="如何查看并改变控制台编码"><a href="#如何查看并改变控制台编码" class="headerlink" title="如何查看并改变控制台编码"></a>如何查看并改变控制台编码</h1><p>在控制台里输入以下命令可以查看当前控制台编码格式：</p>
<pre><code>chcp
</code></pre>
<p>在控制台里输入以下命令可临时转化当前控制台编码格式：</p>
<pre><code>chcp &#39;编码代码&#39;
</code></pre>
<p>综上，只要保证文件和控制台编码格式相同，就不会出现乱码问题</p>
<h1 id="本文尚未解决的问题"><a href="#本文尚未解决的问题" class="headerlink" title="本文尚未解决的问题"></a>本文尚未解决的问题</h1><p>本文只提供了临时更改控制台编码的方法，并没有提供更改各个控制台默认编码的方法</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">个人博客创建指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 15:23:38" itemprop="dateCreated datePublished" datetime="2023-11-04T15:23:38+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:16:01" itemprop="dateModified" datetime="2023-11-06T11:16:01+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&emsp;&emsp;这篇文章记录我第一次创建个人博客的过程，使用了Github个人账户域名，开源免费的Hexo博客框架以及Next主题。</p>
<h1 id="安装Git和Node-js"><a href="#安装Git和Node-js" class="headerlink" title="安装Git和Node.js"></a>安装Git和Node.js</h1><p>Git 是一种分布式版本控制系统，即，代码的本地克隆就是一个完整的版本控制存储库。 通过这些功能齐全的本地存储库，无论脱机还是远程都能轻松工作。 开发人员会在本地提交其工作，然后再将存储库的副本与服务器上的副本进行同步。（Github就是搭配Git使用的用于存储代码的克隆库）</p>
<p>Node.js可以让JavaScript脱离浏览器运行，它是一个开源、跨平台的JavaScript运行时环境，可以用来开发高性能的 Web 服务器和网络应用。</p>
<p>搭建个人博客为何需要安装Git和Node.js?我们基于Hexo搭建博客，Hexo必须依赖Node.js提供的环境运行。而Git并非是搭建个人博客的必备，但我们仍然推荐下载Git，使用Git的相关命令来从Hexo下载Next主题。</p>
<ol>
<li><p>从官网上安装Git并配置相关环境变量（PS：安装完Git后你可以使用Git Bash作为命令行窗口调用命令，Git Bash上可以使用Linux格式的命令，但由于Git Bash上安装下载无法看到进度条的问题，我个人更推荐用cmd来进行操作，本文后续无特殊声明命令行全采用cmd）</p>
</li>
<li><p>绑定Git和Github账号，在cmd里输入以下命令：</p>
<pre><code> git config --global user.name “Your Name”
 git config --global user.email email@example.com
 :: 其中Your Name和email@example.com替换成上面注册时的账户名和邮箱
</code></pre>
</li>
<li><p>从官网上安装Node.js并配置相关环境变量</p>
</li>
<li><p>执行完上述步骤可以用以下命令测试是否安装成功：</p>
<pre><code> git version
 node -v
 npm -v
</code></pre>
<p> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture1.png" alt="img"></p>
</li>
</ol>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>hexo是一个基于Node.js的静态博客框架，它可以让您使用Markdown（或其他渲染引擎）编写文章，并在几秒内生成静态网页。</p>
<p>npm是Node.js 的默认程序包管理器，它可以让您从 npm 服务器下载、安装、上传和管理 Node.js 的模块或包。模块或包是一些可以重用的代码，可以实现一些特定的功能或提供一些特定的服务</p>
<p>使用npm安装Hexo，命令如下：</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<h1 id="创建博客网站"><a href="#创建博客网站" class="headerlink" title="创建博客网站"></a>创建博客网站</h1><p>所有的准备工作都做好了后，现在需要生成一个文件夹作为个人博客网站的根目录，在你希望放置个人博客文件夹的地方使用如下命令：</p>
<pre><code>hexo init myBlog
:: 其中myBlog就是你的个人博客网站根目录，可以取自己喜欢的名字
cd myBlog
npm install
</code></pre>
<p>如果上面工作都没有出错的化，现在你的个人博客已经搭建成功了，你可以在个人博客根目录下输入以下命令在本地预览效果：</p>
<pre><code>hexo s
</code></pre>
<p><img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture2.png" alt="img"></p>
<p>并且我们可以在根目录下的_config.yml里对个人博客的初始设置进行配置，例如：姓名、标题等个性化设置</p>
<h1 id="选择你喜欢的主题"><a href="#选择你喜欢的主题" class="headerlink" title="选择你喜欢的主题"></a>选择你喜欢的主题</h1><p>大家可以去<a target="_blank" rel="noopener" href="https://hexo.io/themes/">Hexo官网</a>去寻找喜欢的主题下载下来，每个主题都可以点击预览，并且可以点击查看使用说明文档</p>
<p>我使用的<a target="_blank" rel="noopener" href="https://github.com/next-theme/hexo-theme-next">Next主题</a>是较为受欢迎的一款，风格简约大气</p>
<p>下载主题有两种方法，这边只介绍使用一种，在个人博客文件根目录下使用命令：</p>
<pre><code>git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
<p>如果下载成功则根目录下会出现该文件夹 &#x2F;themes&#x2F;next</p>
<p>我们就可以在NexT文件夹里的_config.yml里对该主题的一些设定进行配置，但这种方法存在弊端，官方推荐的配置方法以及具体的操作可以查看<a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/theme-settings/custom-pages">NexT官方说明文档</a></p>
<h1 id="将个人博客部署到Github上"><a href="#将个人博客部署到Github上" class="headerlink" title="将个人博客部署到Github上"></a>将个人博客部署到Github上</h1><p>Github能且仅能使用一个同名仓库的代码托管一个静态站点.</p>
<ol>
<li><p>在Github上创建一个名为：<code>用户名.github.io</code>的仓库</p>
</li>
<li><p>使用以下命令配置SSH钥匙：</p>
<pre><code> git config --global user.name &quot;用户名&quot;
 git config --global user.email &quot;邮箱地址&quot;
 ::之前已经配置过可直接输入第三条命令 
 ssh-keygen -t rsa -C &#39;上面的邮箱&#39;
</code></pre>
<p> 可在<code>C:\Users\用户名\.ssh\id_rsa.pub</code>文件里查看SSH公钥</p>
</li>
<li><p>首次使用还须使用以下命令确认并添加主机到本机SSH可信列表：</p>
<pre><code> ssh -T git@github.com
 ::若返回 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功
</code></pre>
</li>
<li><p>登陆Github添加刚刚生成的SSH key，在下图中Key部分处放入SSH公钥内容<br> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture3.png" alt="img"></p>
</li>
<li><p>在根目录底下_config.xml文件拉到最底部添加如下配置：</p>
<pre><code> deploy :
 type: git
 repo: https://github.com/1478540/1478540.github.io.git
 # repo是你的仓库地址
 branch: master
</code></pre>
</li>
<li><p>安装一个部署插件：</p>
<pre><code> npm install hexo-deployer-git --save
</code></pre>
</li>
<li><p>生成相应的博客文件并部署：</p>
<pre><code>hexo g 
::g是generate，生成相应文件
hexo d
::d则是部署，部署完以后就可以通过Github账户域名访问个人博客了
</code></pre>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>文章发布可以通过命令<code>hexo new &#39;文章标题&#39;</code>,也可以直接在<code>/sourse/_posts</code>文件夹下创建.md文件，文件的具体的编写可以使用<a target="_blank" rel="noopener" href="https://markdown.com.cn/basic-syntax/images.html">makedown语法</a></p>
<p>本文学习于B站教程<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.880.my_history.page.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">[教程]Hexo &amp; Github搭建自己的专属博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
