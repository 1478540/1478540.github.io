<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sparkle&#39;s Space">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sparkle's Space</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/01/SimpleOS-8-%E5%B7%A5%E5%85%B7%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/01/SimpleOS-8-%E5%B7%A5%E5%85%B7%E5%BA%93/" class="post-title-link" itemprop="url">SimpleOS-8-工具库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-01-01 19:38:09 / Modified: 10:31:21" itemprop="dateCreated datePublished" datetime="2024-01-01T19:38:09+08:00">2024-01-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="位图bitmap"><a href="#位图bitmap" class="headerlink" title="位图bitmap"></a>位图bitmap</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>位图本质上就是一个数组<br>一个位图可以表示一个空间的内存块分配情况<br>位图上的每一位的值，代表相应单位空间是否空闲(0空闲，1已使用)<br>例如：内存位图一般1位代表1页(4KB)，硬盘位图一般1页代表1扇区(512KB)</p>
<p><img src="/img/SimpleOS-8-%E5%B7%A5%E5%85%B7%E5%BA%93/img1.png" alt="img"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code>struct bitmap&#123;
    uint32_t btmp_bytes_len;    //位图字节长度
    uint8_t* bits;              //位图起始地址
&#125;;
</code></pre>
<h2 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h2><pre><code>/*
@brief: 初始化位图，将位图btmp全部清0
@param: 略
@retval:无
*/
void bitmap_init(struct bitmap* btmp);

/*
@brief: 返回btmp中第bit_idx位的状态
@param: 略
@retval:略
*/
bool bitmap_scan_test(struct bitmap* btmp,uint32_t bit_idx);

/*
@brief: 寻找btmp中第一个 连续cnt位为0(相当于连续cnt个页空闲)
@param: 略
@retval:成功返回偏移地址，失败返回-1
*/
int bitmap_scan(struct bitmap* btmp,uint32_t cnt);

/*
@brief: 设置btmp中第bit_idx位为value
@param: 略
@retval:无
*/
void bitmap_set(struct bitmap* btmp,uint32_t bit_idx,int8_t value);
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/01/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/01/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">SimpleOS-7-文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-01-01 10:29:13" itemprop="dateCreated datePublished" datetime="2024-01-01T10:29:13+08:00">2024-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-02 12:20:34" itemprop="dateModified" datetime="2024-01-02T12:20:34+08:00">2024-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整体设计方案"><a href="#整体设计方案" class="headerlink" title="整体设计方案"></a>整体设计方案</h1><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img7.png" alt="img"></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><pre><code>/* 分区结构:一个分区就是一个文件系统 */
struct partition &#123;
    uint32_t start_lba;		    // 起始扇区
    uint32_t sec_cnt;		    // 扇区数
    struct disk* my_disk;	    // 分区所属的硬盘
    struct list_elem part_tag;	// 用于队列中的标记，用于将分区形成链表进行管理
    char name[8];		        // 分区名称

    struct super_block* sb;	    // 本分区的超级块
    struct bitmap block_bitmap;	// 块位图
    struct bitmap inode_bitmap;	// inode位图
    struct list open_inodes;	// 本分区打开的inode缓冲队列
&#125;;

/* 超级块：文件系统元信息的配置文件 */
struct super_block &#123;
    uint32_t magic;		            // 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型

    uint32_t sec_cnt;		        // 本分区总共的扇区数
    uint32_t inode_cnt;		        // 本分区中inode数量
    uint32_t part_lba_base;	        // 本分区的起始lba地址

    uint32_t block_bitmap_lba;	    // 块位图本身起始扇区地址
    uint32_t block_bitmap_sects;    // 扇区位图本身占用的扇区数量

    uint32_t inode_bitmap_lba;	    // i结点位图起始扇区lba地址
    uint32_t inode_bitmap_sects;	// i结点位图占用的扇区数量

    uint32_t inode_table_lba;	    // i结点表起始扇区lba地址
    uint32_t inode_table_sects;	    // i结点表占用的扇区数量

    uint32_t data_start_lba;	    // 数据区开始的第一个扇区号
    uint32_t root_inode_no;	        // 根目录所在的I结点号
    uint32_t dir_entry_size;	    // 目录项大小

    uint8_t  pad[460];		        // 加上460字节,凑够512字节1扇区大小
    
&#125; __attribute__ ((packed));

/* inode：文件的实质 */
struct inode &#123;
    uint32_t i_no;                  // inode编号

    uint32_t i_size;                //当此inode是普通文件时,i_size是指普通文件大小
                                    //若此inode是目录,i_size是指该目录下所有目录项大小之和*/

    uint32_t i_open_cnts;           // 记录此文件被打开的次数
    bool write_deny;	            // 写文件不能并行,进程写文件前检查此标识
                        
    uint32_t i_sectors[13];         // i_sectors[0-11]是直接块,
                                    // i_sectors[12]用来存储一级间接块指针
    struct list_elem inode_tag;     //用于文件缓冲队列中
&#125;;

/* 文件结构 */
struct file
&#123;
    uint32_t fd_pos;        // 记录当前文件操作的偏移地址，文件尾为-1
    uint32_t fd_flag;       // 文件操作标识符
    struct inode *fd_inode;
&#125;;

/* 目录结构 */
struct dir &#123;
    struct inode* inode;   
    uint32_t dir_pos;	    // 记录在目录内的偏移
    uint8_t dir_buf[512];   // 目录的数据缓存
&#125;;

/* 目录项结构 */
struct dir_entry &#123;
    char filename[MAX_FILE_NAME_LEN];   // 普通文件或目录名称
    uint32_t i_no;		                // 普通文件或目录对应的inode编号
    enum file_types f_type;	            // 文件类型
&#125;;
</code></pre>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img2.png" alt="img"></p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img3.png" alt="img"></p>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><h2 id="fs-fs-c"><a href="#fs-fs-c" class="headerlink" title="fs&#x2F;fs.c"></a>fs&#x2F;fs.c</h2><pre><code>//------------------------文件系统初始化相关函数---------------------------------------

/*
@brief: 在磁盘上搜索文件系统，落没有则格式化分区创建文件系统
@detail:1.遍历整个磁盘，对每个已存在的分区创建文件系统
        2.挂载默认分区
        3.将当前分区的根目录打开
        4.初始化文件表
@param: 无
@retval:无
*/
void filesys_init();

/*
@brief: 初始化part分区的元信息,创建文件系统
@detail:初始化超级块、空闲块位图、inode位图、inode数组、根目录并全部写入磁盘
@param: 略
@retval:无
*/
static void partition_format(struct partition* part);

/*
@brief: 挂载名为part_name(arg)的分区
@detail:将硬盘中的超级块、空闲块位图、inode位图全部读取到内存中
        给cur_part赋值
@param: 略
@retval:无
*/
static bool mount_partition(struct list_elem *pelem, int arg);

//------------------------文件系统初始化相关函数---------------------------------------


//------------------------路径解析相关函数-----------------------

/*
@brief: 将最上层路径名称解析出来，存储到name_store,并返回子路径
@param: 略
@retval:无
*/
static char *path_parse(char *pathname, char *name_store);

/*
@brief: 返回路径深度
@param: 略
@retval:无
*/
int32_t path_depth_cnt(char *pathname);

/*
@brief: 搜索文件路径pathname,找到则返回其inode号,否则返回-1
@param: search_record:记录搜索过程中的父路径
@retval:无
@PS：   调用该函数后，会打开目标文件的父目录，并不会关闭，需要调用者关闭该目录
*/
static int search_file(const char *pathname, struct path_search_record *searched_record);

//------------------------路径解析相关函数-----------------------


//-------------------------系统调用-普通文件相关-------------------------

/*
@brief: 打开或创建普通文件
@detail：   1.先搜索该普通文件是否存在
            2.存在则打开，不存在则创建并打开
@param: flags:文件操作标识符
@retval:成功后,返回文件描述符,否则返回-1
*/
int32_t sys_open(const char *pathname, uint8_t flags);

/*
@brief: 关闭文件描述符fd指向的文件
@detail：   1.调用file_close()关闭普通文件;
            2.PCB-&gt;fd_table[fd]=-1;令文件描述符对应的数组可用
@param: flags:文件操作标识符
@retval:成功返回0,否则返回-1
*/
int32_t sys_close(int32_t fd)

/*
@brief: 将buf中连续count个字节写入文件描述符fd
@param: 略
@retval:成功则返回写入的字节数,失败返回-1
*/
int32_t sys_write(int32_t fd, const void *buf, uint32_t count);

/*
@brief: 从文件描述符fd指向的文件中读取count个字节到buf
@param: 略
@retval:若成功则返回读出的字节数,到文件尾则返回-1
*/
int32_t sys_read(int32_t fd, void *buf, uint32_t count);

/*
@brief: 重置用于文件读写操作的偏移指针(重置为:offset+文件指针位置)
@param: whence:文件指针位置标识符
        offset:相对于文件指针位置的偏移量
@retval:成功时返回新的偏移量,出错时返回-1
*/
int32_t sys_lseek(int32_t fd, int32_t offset, uint8_t whence);

/*
@brief: 删除普通文件(普通文件已打开则删除失败)
@param: 略
@retval:成功返回0,失败返回-1 
*/
int32_t sys_unlink(const char *pathname);
//-------------------------系统调用-普通文件相关-------------------------


//-------------------------系统调用-目录文件相关-------------------------

/*
@brief: 创建目录文件(并不打开)
@detail:1.申请inode位图，并同步到磁盘
        2.申请block位图，并同步到磁盘(先分配一个块就够用)
        3.往inode指向的数据块写入目录项&#39;.&#39;和&#39;..&#39;
        4.要将本目录的inode初始化，并同步到磁盘(无需申请内存空间)
        5.将关于本目录的目录项写入父目录数据块(写入磁盘)
        6.父目录inode更新大小并同步到磁盘
@param: pathname:目录文件路径
@retval:成功返回0,失败返回-1 
*/
int32_t sys_mkdir(const char *pathname);

/*
@brief: 打开目录文件，并返回目录指针
@detail:调用dir_open()来打开目录
        （目录打开只涉及part-&gt;open_inodes不涉及文件表、文件描述符数组等）
@param: 略
@retval:成功返回目录指针,失败返回-1 
*/
struct dir *sys_opendir(const char *name);

/*
@brief: 关闭目录
@detail:调用dir_close()来关闭目录
@param: 略
@retval:成功返回0,失败返回-1
*/
int32_t sys_closedir(struct dir *dir);

/*
@brief: 根据dir当前偏移位置，读取一个目录项，并更新偏移位置(调用dir_read()实现)
@param: 略
@retval:成功后返回其目录项地址,到目录尾时或出错时返回NULL
*/
struct dir_entry *sys_readdir(struct dir *dir);

/*
@brief: 把目录dir的指针dir_pos置0
@param: 略
@retval:无
*/
void sys_rewinddir(struct dir *dir);

/*
@brief: 删除空目录(调用dir_remove()实现)
@param: 略
@retval:成功时返回0,失败时返回-1
*/
int32_t sys_rmdir(const char *pathname);
//-------------------------系统调用-目录文件相关-------------------------


//-------------------------系统调用-cwd相关-------------------------

/*
@brief: 获得父目录的inode编号(利用目录项目&#39;..&#39;)
@param: 略
@retval:无
*/
static uint32_t get_parent_dir_inode_nr(uint32_t child_inode_nr, void *io_buf);

/*
@brief: 在inode编号为p_inode_nr的目录中查找inode编号为c_inode_nr的子目录的名字，将名字存入缓冲区path. 
@param: 略
@retval:成功返回0,失败返-1
*/
static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char *path, void *io_buf);

/*
@brief: 把当前工作目录绝对路径写入buf, size是buf的大小. 
@detail:根据PCB-&gt;cwd_inode_nr一层层向上追溯求得当前工作目录路径
@param: 略
@retval:成功返回buf,失败返NULL
*/
char *sys_getcwd(char *buf, uint32_t size);

/*
@brief: 更改当前工作目录为绝对路径path 
@detail:实质是修改PCB-&gt;cwd_inode_nr
@param: 略
@retval:成功则返回0,失败返回-1
*/
int32_t sys_chdir(const char *path);
//-------------------------系统调用-cwd相关-------------------------


//-------------------------系统调用-文件属性相关-------------------------
/*
@brief: 在buf中填充文件结构相关信息 
@param: 略
@retval:成功时返回0,失败返回-1
*/
int32_t sys_stat(const char *path, struct stat *buf);

//-------------------------系统调用-文件属性相关-------------------------


//------------------------转换函数----------------------
/*
@brief: 将文件描述符转化为文件表的下标
@param: 略
@retval:无
*/
static uint32_t fd_local2global(uint32_t local_fd);

//------------------------转换函数----------------------
</code></pre>
<h2 id="fs-dir-c"><a href="#fs-dir-c" class="headerlink" title="fs&#x2F;dir.c"></a>fs&#x2F;dir.c</h2><pre><code>/*
@brief: 打开根目录
@detail:1.利用inode_open()打开根目录
        2.并给root_dir赋值
@param: 略
@retval:无
*/
void open_root_dir(struct partition *part);

/*
@brief: 在分区part上打开节点号为inode_no的目录并返回目录指针 
@detail:1.利用inode_open()打开目录文件
        2.给目录结构pdir申请空间，初始化并返回
        （目录打开只涉及part-&gt;open_inodes不涉及文件表、文件描述符数组等）
@param: 略
@retval:无
*/
struct dir *dir_open(struct partition *part, uint32_t inode_no);

/*
@brief: 关闭目录
@detaili:1.利用inode_close()关闭目录，根目录不能被关闭
        2.释放目录结构dir的空间
@param: 略
@retval:无
*/
void dir_close(struct dir *dir);

/*
@brief: 在目录中寻找指定目录项
@detail:在part分区内的pdir目录内寻找包含name文件或目录的目录项
@param: 略
@retval:找到后返回true并将其目录项存入dir_e,否则返回false
*/
bool search_dir_entry(struct partition *part, struct dir *pdir, const char *name, struct dir_entry *dir_e);

/*
@brief: 在内存中初始化目录项p_de
@param: 略
@retval:无
*/
void create_dir_entry(char *filename, uint32_t inode_no, uint8_t file_type, struct dir_entry *p_de);

/*
@brief:     将目录项p_de写入父目录parent_dir中(直接写入磁盘)
@param:     io_buf:主调函数提供的缓冲区
@retval:    成功返回true，失败返回false
@PS：       父目录的inode.size更改过了，但并没有同步到磁盘的inode_table里！！
            调用者要负责把父目录的inode同步到磁盘
*/
bool sync_dir_entry(struct dir *parent_dir, struct dir_entry *p_de, void *io_buf);

/*
@brief: 把分区part目录pdir中关于inode_no的目录项删除（会将更新过的父目录inode写入磁盘）
@param: 略
@retval:成功返回true，失败返回false
*/
bool delete_dir_entry(struct partition *part, struct dir *pdir, uint32_t inode_no, void *io_buf);

/*
@brief: 根据dir当前偏移位置，读取一个目录项，并更新偏移位置
@param: 略
@retval:成功返回目录项，失败返回NULL
*/
struct dir_entry *dir_read(struct dir *dir);

/*
@brief: 判断目录是否为空
@detail:目录为空则代表目录中只含有.和..两个目录项
@param: 略
@retval:空返回true,非空返回false
*/
bool dir_is_empty(struct dir *dir);

/*
@brief: 移除目录child_dir
@detail:1.调用delete_dir_entry在父目录中移除本目录的目录项
        2.调用inode_release()回收本目录的inode
@param: 略
@retval:成功返回目录项，失败返回NULL
*/
int32_t dir_remove(struct dir *parent_dir, struct dir *child_dir);
</code></pre>
<h2 id="fs-inode-c"><a href="#fs-inode-c" class="headerlink" title="fs&#x2F;inode.c"></a>fs&#x2F;inode.c</h2><pre><code>/*
@brief: 打开并返回part分区里目标inode节点
        两个重要的功能：一个是打开inode、一个是返回inode节点
@detail:1.现在inode缓冲区队列中寻找该inode，若已打开则增加inode-&gt;i_open_cnts并返回inode
        2.没找到就去磁盘中寻找该inode读取到内存里，并放到inode缓冲区队列，返回inode
@param: part:目标分区
        inode_no:要打开的inode节点的i_no号
@retval:无
*/
struct inode *inode_open(struct partition *part, uint32_t inode_no);

/*
@brief: 关闭inode
@detail:1.减少inode-&gt;i_open_cnts
        2.inode-&gt;i_pen_cnts减少后若为0，则将从inode缓冲队列里去除，并释放为inode分配的空间
@param: 略
@retval:无
*/
void inode_close(struct inode *inode)

/*
@brief: 初始化new_inode，为其赋值
@param: 略
@retval:无
*/
void inode_init(uint32_t inode_no, struct inode *new_inode)


/*
@brief: 定位inode在扇区的位置
@detail:在part里获取inode所在的扇区和扇区内的偏移量并存到inode_pos中
@param: 略
@retval:无
*/
static void inode_locate(struct partition *part, uint32_t inode_no, struct inode_position *inode_pos);

/*
@brief: 将inode写入到磁盘的分区part中
@param: 略
@retval:无
*/
void inode_sync(struct partition *part, struct inode *inode, void *io_buf);


/*
@brief: 回收inode
@detail:1.回收分配给inode的所有block(修改block_bitmap)
        2.回收inode(修改inode_bitmap)
        3.调用inode_delete删除硬盘上的inode数据（可以不用这步）
        4.确保该inode完全关闭
@param: 略
@retval:无
*/
void inode_release(struct partition *part, uint32_t inode_no);

/*
@brief: 将硬盘分区part上的对应的inode清除(修改磁盘上的inode_table)
@param: inode_no:要清楚的inode号
@retval:无
*/
void inode_delete(struct partition *part, uint32_t inode_no, void *io_buf);
</code></pre>
<h2 id="fs-file-c"><a href="#fs-file-c" class="headerlink" title="fs&#x2F;file.c"></a>fs&#x2F;file.c</h2><pre><code>//------------------------文件表 文件描述符数组 相关操作-----------------------

/*
@brief: 从文件表file_table中获取一个空闲位
@param: 无
@retval:成功返回文件表下标,失败返回-1 
@PS:如果file_table[fd_idx].fd_inode == NULL，则判断文件结构可用
*/
int32_t get_free_slot_in_global(void);

/*
@brief: 将全局描述符(文件表下标)安装到进程或线程自己的文件描述符数组fd_table中 
@param: globa_fd_idx:文件表的下标（全局文件描述符）
@retval:成功返回文件描述符(文件描述符数组的下标),失败返回-1
*/
int32_t pcb_fd_install(int32_t globa_fd_idx);

//------------------------文件表 文件描述符数组 相关操作-----------------------


//---------------------------位图操作-------------------------
/*
@brief: 从inode位图里分配一个inode结点 (内存操作)
@param: 略
@retval:返回节点号i_no(就是inode在位图中的位置)
*/
int32_t inode_bitmap_alloc(struct partition *part);

/*
@brief: 从block位图里分配1个空闲块(1扇区),返回其扇区地址(内存操作)
@param: 略
@retval:略
*/
int32_t block_bitmap_alloc(struct partition *part);

/*
@brief: 同步内存里的位图结构到磁盘上
@detail:将内存中bitmap第bit_idx位所在的512字节同步到硬盘
@param: btmp_type:标识是inode位图还是block位图
@retval:略
*/
void bitmap_sync(struct partition *part, uint32_t bit_idx, uint8_t btmp_type);
//---------------------------位图操作-------------------------


//-------------------------------普通文件相关操作--------------------------------
/*
@brief: 创建并打开普通文件(磁盘操作)
@detail:1.创建new_inode(修改inode位图、inode分配内存、inode初始化)
        2.修改父目录(对应目录项写入父目录(写入磁盘)，修改父目录inode.size)
        3.同步 父目录inode、new_inode、inode位图
        4.打开该文件(添加到file_table、PCB中的fd_table、Part中的open_inodes)
@param: flag:文件操作标识符
@retval:成功则返回文件描述符,否则返回-1
*/
int32_t file_create(struct dir *parent_dir, char *filename, uint8_t flag);

/*
@brief: 打开编号为inode_no的inode对应的普通文件
@detail:1.修改file_table
        2.修改PCB-&gt;fd_table
        3.调用inode_open()修改part-&gt;open_inodes
@param: 略
@retval:成功则返回文件描述符,否则返回-1
*/
int32_t file_open(uint32_t inode_no, uint8_t flag);

/*
@brief: 关闭文件结构
@detail:1.调用inode_close()修改part-&gt;open_inodes
        2. file-&gt;fd_inode = NULL; 使文件结构可用
@param: file:要关闭的文件结构
@retval:失败返回-1，成功返回0
@PS:没有将PCB中的文件描述符数组对应位置-1！！！
    调用者要负责将PCB-&gt;fd_table[]置-1
*/
int32_t file_close(struct file *file);

/*
@brief: 把buf中的count个字节写入file
@param: 略
@retval:成功则返回写入的字节数,失败则返回-1
*/
int32_t file_write(struct file *file, const void *buf, uint32_t count);

/*
@brief: 从文件file中读取count个字节写入buf
@param: 略
@retval:返回读出的字节数,若到文件尾则返回-1
*/
int32_t file_read(struct file *file, void *buf, uint32_t count);
//-------------------------------普通文件相关操作--------------------------------
</code></pre>
<h1 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a>关键函数说明</h1><h2 id="文件系统初始化函数"><a href="#文件系统初始化函数" class="headerlink" title="文件系统初始化函数"></a>文件系统初始化函数</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img6.png" alt="img"></p>
<h2 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img4.png" alt="img"></p>
<h2 id="工作路径相关函数"><a href="#工作路径相关函数" class="headerlink" title="工作路径相关函数"></a>工作路径相关函数</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img5.png" alt="img"></p>
<h2 id="fs-file-c-file-create"><a href="#fs-file-c-file-create" class="headerlink" title="fs&#x2F;file.c&#x2F;file_create()"></a>fs&#x2F;file.c&#x2F;file_create()</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img8.png" alt="img"></p>
<h2 id="fs-file-c-file-write"><a href="#fs-file-c-file-write" class="headerlink" title="fs&#x2F;file.c&#x2F;file_write()"></a>fs&#x2F;file.c&#x2F;file_write()</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img9.png" alt="img"></p>
<h2 id="fs-file-c-file-read"><a href="#fs-file-c-file-read" class="headerlink" title="fs&#x2F;file.c&#x2F;file_read()"></a>fs&#x2F;file.c&#x2F;file_read()</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img10.png" alt="img"></p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="inode、super-block、目录、目录项、超级块与文件系统布局"><a href="#inode、super-block、目录、目录项、超级块与文件系统布局" class="headerlink" title="inode、super_block、目录、目录项、超级块与文件系统布局"></a>inode、super_block、目录、目录项、超级块与文件系统布局</h2><h2 id="硬盘驱动"><a href="#硬盘驱动" class="headerlink" title="硬盘驱动"></a>硬盘驱动</h2><h1 id="工具图表"><a href="#工具图表" class="headerlink" title="工具图表"></a>工具图表</h1><h2 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img1.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/31/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/31/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">SimpleOS-3-内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-12-31 09:31:53 / Modified: 16:31:07" itemprop="dateCreated datePublished" datetime="2023-12-31T09:31:53+08:00">2023-12-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整体设计方案"><a href="#整体设计方案" class="headerlink" title="整体设计方案"></a>整体设计方案</h1><p>内存管理模块整体方案如下：</p>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img6.png" alt="img"></p>
<p>物理内存池划分如下：</p>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img1.png" alt="img"></p>
<p>虚拟内存池划分如下：</p>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img2.png" alt="img"></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><pre><code>//物理内存池
struct pool&#123;
    struct bitmap pool_bitmap;  //物理内存池位图
    uint32_t phy_addr_start;    //管理空间起始地址
    uint32_t pool_size;         //管理空间长度

    struct lock lock;           //进程申请物理内存时需要上锁
&#125;;

//虚拟内存池
struct virtual_addr&#123;
    struct bitmap vaddr_bitmap; //虚拟内存池位图
    uint32_t vaddr_start;       //管理空间起始地址
&#125;;

/* 内存块 */
struct mem_block &#123;
    struct list_elem free_elem;
&#125;;

/* 内存块描述符 */
struct mem_block_desc &#123;
    uint32_t block_size;		 // 内存块大小
    uint32_t blocks_per_arena;	 // 本arena中可容纳此mem_block的数量.
    struct list free_list;	 // 目前可用的mem_block链表
&#125;;

/* 内存仓库arena元信息 */
struct arena &#123;
    struct mem_block_desc* desc;	 // 此arena关联的mem_block_desc
    uint32_t cnt;
    bool large;		                // large为ture时,cnt表示的是页框数。否则cnt表示空闲mem_block数量
&#125;;
</code></pre>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img5.png" alt="img"></p>
<p>内存池提供以页为单位的内存空间<br>对于每一页内存空间都由元信息arena来组织，并将剩余空间切分成小块<br>每一个元信息arena组织的内存仓库 都按照块的大小有着相应的mem_block_desc<br>由mem_block_desc中的free_list来串起所有同一大小的空闲内存块</p>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><ul>
<li><p>kernel&#x2F;memory.c</p>
<pre><code>  //-------------------------------------内存系统初始化相关函数---------------------------

  /*
  @brief: 初始化内存相关数据结构(内存池、内存仓库、内存块描述符)
  @param: 无
  @retval:无
  */
  void mem_init();

  /*
  @brief: 内存池初始化(物理内核内存池、物理用户内存池、虚拟内核内存池)
  @param: all_mem:物理内存总量
  @retval:无
  */
  static void mem_pool_init(uint32_t all_mem);

  /*
  @brief: 初始化内存块描述符数组(管理7种不同的内存块描述符(16、32、64、128、256、512、1024))
  @param: desc_array：要初始化的内存块描述符数组
  @retval:无
  */
  void block_desc_init(struct mem_block_desc* desc_array);

  //-------------------------------------内存系统初始化相关函数---------------------------

  //-------------------------------------内存分配相关函数---------------------------

  /*
  @brief: 分配pg_cnt页的内存空间
  @param: pf:内存池类型标识符(内核/用户)
          pg_nct:申请分配的页数
  @retval:成功返回起始虚拟地址,失败返回NULL
  */
  void* malloc_page(enum pool_flags pf,uint32_t pg_cnt);

  /*
  @brief: 向虚拟内存池申请pg_cnt页的空间
  @param: pf:内存池类型标识符(内核/用户)
          pg_nct:申请分配的页数
  @retval:成功返回起始虚拟地址,失败返回NULL
  */
  static void* vaddr_get(enum pool_flags pf,uint32_t pg_cnt);

  /*
  @brief: 向物理内核/用户内存池申请1页空间，
  @param: m_pool:申请的物理内存池(用户/内核)
  @retval:成功返回地址起点，失败返回-1
  */
  static void* palloc(struct pool* m_pool);

  /*
  @brief: 建立从虚拟地址到物理地址的映射(以页为单位)(建立相应的页表/页目录)
  @param: _vaddr:虚拟地址
          _page_phyaddr:物理地址
  @retval:无
  */
  static void page_table_add(void* _vaddr,void* _page_phyaddr);

  /*
  @brief: 给内核分配pg_cnt页内存，
  @param: 略
  @retval:成功则返回虚拟地址，失败返回NULL
  */
  void* get_kernel_pages(uint32_t pg_cnt);

  /*
  @brief: 给用户分配pg_cnt页内存，
  @param: 略
  @retval:成功则返回虚拟地址，失败返回NULL
  */
  void* get_user_pages(uint32_t pg_cnt);

  /*
  @brief: 在堆(即内存池)中申请size字节内存(灵活申请)
  @param: 略
  @retval:无
  */
  void* sys_malloc(uint32_t size);

  /*
  @brief: 给指定虚拟地址分配一页内存
  @param: pf:内存池表示符
          vaddr:指定虚拟地址
  @retval:成功则返回虚拟地址，失败返回NULL
  */
  void* get_a_page(enum pool_flags pf,uint32_t vaddr);
  //-------------------------------------内存分配相关函数---------------------------
              
  //-------------------------------------内存回收相关函数---------------------------

  /*
  @brief: 释放 内核/用户 内存池种以虚拟地址vaddr为起点的cnt个物理页框 
  @param: pf:内存池标识符
          _vaddr:要回收的虚拟地址
          pg_cnt:要回收的页数
  @retval:无
  */
  void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt);


  /*
  @brief: 将1张物理页回收到物理内存池，实质就是清除物理内存池中位图的位
  @param: pg_pyh_addr:要回收页的物理地址
  @retval:无
  */
  void pfree(uint32_t pg_phy_addr);

  /*
  @brief: 将以_vaddr起始的连续pg_cnt个虚拟页回收到虚拟内存池，实质就是清除虚拟内存池中位图的位
  @param: pf:内存池标识符
          _vaddr:要回收的虚拟地址
          pg_cnt:要回收的页数
  @retval:无
  */
  static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt)

  /*
  @brief: 解除页表中虚拟地址vaddr的映射,实质是将vaddr对应的pte存在位置0
  @param: 略
  @retval:无
  */
  static void page_table_pte_remove(uint32_t vaddr);

  /*
  @brief: 回收ptr指向的内存块(内存块大小由arena指出)
  @param: 略
  @retval:无
  */
  void sys_free(void* ptr);

  //-------------------------------------内存回收相关函数---------------------------

  //------------------------------工具函数-----------------------------------------

  /*
  @brief: 返回虚拟地址映射的物理地址 
  @param: 略
  @retval:略
  */
  uint32_t addr_v2p(uint32_t vaddr);

  /*
  @brief: 返回arena中第idx个内存块的地址
  @param: 略
  @retval:略
  */
  static struct mem_block* arena2block(struct arena* a, uint32_t idx);

  /*
  @brief: 返回内存块b所在的arena地址
  @param: 略
  @retval:略
  */
  static struct arena* block2arena(struct mem_block* b);

  /*
  @brief: 得到虚拟地址vaddr对应的pte指针
  @param: 略
  @retval:略
  */
  uint32_t* pte_ptr(uint32_t vaddr);

  /*
  @brief: 得到虚拟地址vaddr对应的pde指针
  @param: 略
  @retval:略
  */
  uint32_t* pde_ptr(uint32_t vaddr)

  //------------------------------工具函数-----------------------------------------
</code></pre>
</li>
</ul>
<h1 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a>关键函数说明</h1><ul>
<li><p>kernel&#x2F;memory.c&#x2F;内存分配相关函数</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img3.png" alt="img"></p>
</li>
<li><p>kernel&#x2F;memory.c&#x2F;内存回收相关函数</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img8.png" alt="img"></p>
</li>
<li><p>kernel&#x2F;memory.c&#x2F;page_table_add()</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img4.png" alt="img"></p>
</li>
<li><p>kernel&#x2F;memory.c&#x2F;sys_malloc()</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img7.png" alt="img"></p>
</li>
</ul>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="pool-virtual-addr"><a href="#pool-virtual-addr" class="headerlink" title="pool-virtual_addr"></a>pool-virtual_addr</h2><h2 id="arena-mem-block-desc"><a href="#arena-mem-block-desc" class="headerlink" title="arena-mem_block_desc"></a>arena-mem_block_desc</h2><h1 id="工具图表"><a href="#工具图表" class="headerlink" title="工具图表"></a>工具图表</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/30/SimpleOS-2-Boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/30/SimpleOS-2-Boot/" class="post-title-link" itemprop="url">SimpleOS-2-Boot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-30 15:45:05" itemprop="dateCreated datePublished" datetime="2023-12-30T15:45:05+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-31 16:30:38" itemprop="dateModified" datetime="2023-12-31T16:30:38+08:00">2023-12-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整体设计方案"><a href="#整体设计方案" class="headerlink" title="整体设计方案"></a>整体设计方案</h1><p><img src="/img/SimpleOS-2-Boot/img4.png" alt="img"></p>
<p>如图电脑的启动后接力棒的第一棒从BIOS开始，第二棒MBR负责把硬盘上的loader加载到内存里，第三棒loader处理完5个子功能后把接力棒正式交给内核。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>无</p>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><ul>
<li><p>boot&#x2F;mbr.S</p>
<pre><code>  /*
  @brief: 该函数负责把磁盘上的loader装载到内存里(汇编函数/寄存器传参)
  @param: loader_start_sector是loader的LBA28扇区地址
          loader_base_addr是内存起始地址
          sector_cnt是移动的扇区数目
  @retval:无
  */
  void loader_ready_proc(loader_start_sector,loader_base_addr,sector_cnt);
</code></pre>
</li>
<li><p>boot&#x2F;loader.S</p>
<pre><code>  /*
  @brief: 该函数负责5件事分布如下：(汇编函数)
          1. 计算内存并存储到0xb00
          2. 从实模式到保护模式
          3. 构建内核页表页目录，开启分页机制
          4. 加载kernel到内核中
          5. 初始化kernel
  @param: 无
  @retval:无
  */
  void loader_start();
</code></pre>
</li>
</ul>
<h1 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a>关键函数说明</h1><ul>
<li><p>boot&#x2F;loader.S&#x2F;loader_start()&#x2F;3.构建内核页表页目录，开启分页机制</p>
<p>  <img src="/img/SimpleOS-2-Boot/img11.png" alt="img"></p>
<ol>
<li><p>虚拟空间<code>0x00~0x100000</code>和<code>0xc0000000~0xc0100000</code>两个区间都映射到物理空间的低端1MB内核代码区间</p>
</li>
<li><p>PD[1023]指向页目录本身，为的是实现在开启分页机制后还能正确访问页表和页目录</p>
<p> 如果虚地址高10位全为1、虚地址中10位全为0，就把PD[0]当成自己的页表项，最终指向物理页地址0x101000<br> 如果虚地址高10位全为1、虚地址中10位全为1，就把PD[1023]当成自己的页表项,最终指向物理页地址0x100000<br> 如果虚地址高10位全为1、虚地址中10位处于一定范围内，就把PD[768]~PD[1022]当成自己的页表项目，最终指向物理地址0x101000及以上空间</p>
<p> 总结出不变的规律：</p>
<ul>
<li>要获取页目录表物理地址：让虚位高20位地址全为1，低12位全为0，即0xfffff000。这就是页目录自身的起始物理地址</li>
<li>要访问页目录中的页目录项，即获取页表物理地址：使虚拟地址为0xfffffxxx,其中xxx是页目录项的索引*4</li>
<li>访问页表中的页表项:虚拟地址公式为 0x3ff&lt;&lt;22+中间10位&lt;&lt;12+低12位（中间10位是页表的索引，低12位为页表内的偏移地址）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="从实模式进入保护模式"><a href="#从实模式进入保护模式" class="headerlink" title="从实模式进入保护模式"></a>从实模式进入保护模式</h2><p>从实模式到保护模式我们要执行三个步骤：</p>
<ol>
<li>打开A20地址线</li>
<li>加载GDT</li>
<li>将CR0的PE位置1</li>
</ol>
<h2 id="GDT-段描述符-GDTR-段选择子"><a href="#GDT-段描述符-GDTR-段选择子" class="headerlink" title="GDT-段描述符-GDTR-段选择子"></a>GDT-段描述符-GDTR-段选择子</h2><h2 id="二级分页"><a href="#二级分页" class="headerlink" title="二级分页"></a>二级分页</h2><h2 id="启用分页机制"><a href="#启用分页机制" class="headerlink" title="启用分页机制"></a>启用分页机制</h2><p>启用分页机制要做的三个步骤</p>
<ol>
<li>准备好页目录以及页表</li>
<li>将页目录地址写入控制寄存器cr3</li>
<li>寄存器cr0的PG位置1</li>
</ol>
<h2 id="kernel初始化-elf文件的格式拓展"><a href="#kernel初始化-elf文件的格式拓展" class="headerlink" title="kernel初始化-elf文件的格式拓展"></a>kernel初始化-elf文件的格式拓展</h2><h1 id="工具图表"><a href="#工具图表" class="headerlink" title="工具图表"></a>工具图表</h1><h2 id="低端物理内存1MB布局"><a href="#低端物理内存1MB布局" class="headerlink" title="低端物理内存1MB布局"></a>低端物理内存1MB布局</h2><p><img src="/img/SimpleOS-2-Boot/img1.png" alt="img"></p>
<ol>
<li><p>我们整个SimpleOS的代码实际上只会装载到<code>0x500~0x9FFFF</code>这块内存区间</p>
</li>
<li><p>512字节的MBR将会装载到<code>0x7C00~0x7DFF</code>内存区间，（MBR运行一次就没用了，可以被覆盖）</p>
</li>
<li><p>2048字节的loader将会加载到<code>0x900~0x1100</code>内存区间</p>
</li>
<li><p>200扇区kernel.bin，将其装载在<code>0x70000~0x89000</code>,内核代码应该装载在可用空间的尽可能高位，为内核映像文件腾出位置</p>
</li>
<li><p>0xc0001500(虚)作为内核代码的入口</p>
</li>
<li><p>一般来说可用空间的上界限0xc009fc00是最好的栈顶，但是为了让内存的每一块都形成4KB的自然页，所以栈顶最好取4KB的整数倍，因此栈顶设置为<code>0xc009f000</code></p>
</li>
<li><p><code>0xc009e000~0xc009f00</code>分给内核主线程PCB</p>
</li>
<li><p><code>0xc009a000~0xc009e000</code>这四个页的空间(可管理一共512MB空间)大小全给位图(物理内核内存池位图、物理用户内存池位图、虚拟内核内存池位图)</p>
</li>
</ol>
<h2 id="磁盘驱动相关寄存器"><a href="#磁盘驱动相关寄存器" class="headerlink" title="磁盘驱动相关寄存器"></a>磁盘驱动相关寄存器</h2><p><img src="/img/SimpleOS-2-Boot/img2.png" alt="img"></p>
<p><img src="/img/SimpleOS-2-Boot/img3.png" alt="img"></p>
<h3 id="写操作时Command寄存器可以写入三个命令"><a href="#写操作时Command寄存器可以写入三个命令" class="headerlink" title="写操作时Command寄存器可以写入三个命令:"></a>写操作时Command寄存器可以写入三个命令:</h3><ol>
<li>identify:0xEC 即磁盘识别</li>
<li>read secotr:0x20</li>
<li>write sector: 0x30</li>
</ol>
<h3 id="与端口交互的in-out指令"><a href="#与端口交互的in-out指令" class="headerlink" title="与端口交互的in&#x2F;out指令:"></a>与端口交互的in&#x2F;out指令:</h3><ol>
<li><p>in指令用于从端口中读取数据，格式如下：</p>
<pre><code> in al,dx
 in ax,dx
</code></pre>
<p> 只要使用in指令，源操作数必须是dx(存放端口号)，而目的操作数是用al，还是ax取决于dx端口指代的寄存器是8位宽还是16位宽</p>
</li>
<li><p>out 指令用于往端口中写数据，格式如下：</p>
<pre><code> out dx,al
 out dx,ax
 out 立即数,al
 out 立即数,ax
</code></pre>
<p> out指令的源操作数是ax还是al取决于目标端口指代的寄存器是8位宽还是16位宽，源操作数可以是立即数直接给出端口号，也可以用dx（存放端口号）</p>
</li>
</ol>
<h3 id="硬盘操作约定顺序"><a href="#硬盘操作约定顺序" class="headerlink" title="硬盘操作约定顺序"></a>硬盘操作约定顺序</h3><ol>
<li>先选择通道，往该通道的sector cout寄存器写入待操作的扇区数</li>
<li>往通道上的三个LBA写入扇区地址LBA28的低24位</li>
<li>往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式</li>
<li>第四步往该通道的command寄存器写入命令（一旦写入立即执行）</li>
<li>读取status寄存器，判断硬盘工作是否完成</li>
<li>将硬盘数据读出(如果是写硬盘则无需这步)</li>
</ol>
<h2 id="分段相关"><a href="#分段相关" class="headerlink" title="分段相关"></a>分段相关</h2><h3 id="段描述符格式"><a href="#段描述符格式" class="headerlink" title="段描述符格式"></a>段描述符格式</h3><p><img src="/img/SimpleOS-2-Boot/img5.png" alt="img"></p>
<ol>
<li><p>段基址：</p>
<p> 每个段都有32位的段基址，在段描述符中被拆分成三块存储。</p>
<p> 为什么被拆分成三块？为的是兼容，实模式下段基址是16位，80286有关短暂的24位段基址，而现在则是32位段基址，为了兼容原本应该连续存放的段基址被拆分为16-8-8的形式。</p>
<p> 当需要查看段基址时，硬件会把三个分散的段基址取出来并拼接在一起得到一个完整的32位段基址。</p>
<p> <strong>PS：现在知道为什么有那么多屎山代码了，为了兼容旧时代的程序，屎山代码将成为每一个持续发展产品的最终归宿！</strong></p>
</li>
<li><p>段界限：</p>
<p> 段界限表示段边界的扩展最值，20位段界限被拆分为两部分(当然又是为了兼容)。</p>
<p> 段界限是一个单位量，单位要么是1字节，要么是4KB(单位由G段决定)。也就是说段的最大寻址范围要么是1*2^20&#x3D;1MB；要么是2*12*2^20&#x3D;4GB。(注意寻址范围!&#x3D;空间)</p>
<p> 实际的段界限边界值&#x3D;(描述符中段界限+1)*(段界限的粒度大小：4KB&#x2F;1Byte)-1</p>
</li>
<li><p>S字段和type字段：</p>
<p> <img src="/img/SimpleOS-2-Boot/img6.png" alt="img">   </p>
<p> S字段只有1位：S&#x3D;0 则说明是系统段(凡是硬件允许需要用到的东西，程序入口、调用门之类);S&#x3D;1 则说明是非系统段(凡是软件运行需要的东西，数据、代码、栈都是数据段)</p>
<p> type字段有4位：type字段只有在S确认后才有意义，X区分代码段和数据段，R代表是否可读，W代表是否可写，C代表是否一致，E代表向上扩展(E&#x3D;0,低地址到高地址)或向下扩展(E&#x3D;1，高地址到低地址)，A代表是否被CPU读过（CPU访问过则置1）</p>
</li>
<li><p>DPL（Descriptor Privilege Level）</p>
<p> 2位的DPL字段表示特权级，特权级从0~3,数字越低特权级越高，操作系统是0级，一般应用程序是3级</p>
</li>
<li><p>P字段（Present）：</p>
<p> 1位P表示段是否存在，有时候内存不够时，保护模式下CPU可能会按页(4KB)的单位将内存换到磁盘里，此时相当于该段不存在，即P&#x3D;0;</p>
</li>
<li><p>AVL字段（Avaliable）:</p>
<p> 1位AVL字段代表该段是否可用，是否可用是对用户来说，对操作系统来说可随意访问此位</p>
</li>
<li><p>L字段：</p>
<p> 1位L字段，L&#x3D;1表示代码段是64位，L&#x3D;0表示代码段是32位，我们在32位地址下编程将其设置为0即可</p>
</li>
<li><p>D&#x2F;B字段：</p>
<p> 1位D&#x2F;B字段指定有效地址及操作数大小，对不同段的意义不同</p>
<ul>
<li><p>如果争对代码段，D&#x3D;0时指令中有效地址和操作数是16位，指令有效地址用IP寄存器；D&#x3D;1时指令中有效地址和操作数是32位，指令有效地址用EIP寄存器</p>
</li>
<li><p>如果争对栈段，B&#x3D;0时栈使用SP寄存器，栈最大寻址范围为2^16；B&#x3D;1时栈使用ESP寄存器，栈最大寻址范围为2^32</p>
</li>
</ul>
</li>
<li><p>G段：</p>
<p> 1位G段用来指定段界限的单位大小，G&#x3D;0时，段界限的单位时1字节；G&#x3D;1时，段界限的单位是4KB</p>
</li>
</ol>
<h3 id="段选择子格式"><a href="#段选择子格式" class="headerlink" title="段选择子格式"></a>段选择子格式</h3><p><img src="/img/SimpleOS-2-Boot/img7.png" alt="img"></p>
<h3 id="GDTR寄存器"><a href="#GDTR寄存器" class="headerlink" title="GDTR寄存器"></a>GDTR寄存器</h3><p><img src="/img/SimpleOS-2-Boot/img8.png" alt="img"></p>
<p>如图所示是GDTR的结构，48位寄存器前16位是GDT以字节为单位的界限，后32位是GDT在内存中的起始地址<br><strong>GDT界限范围有16位，也就是占有2^16个字节，而一个表项占有8字节，一个GDT一共可以存储2^16&#x2F;8&#x3D;8192个表项</strong></p>
<h2 id="分页相关"><a href="#分页相关" class="headerlink" title="分页相关"></a>分页相关</h2><h3 id="页目录基址寄存器CR3"><a href="#页目录基址寄存器CR3" class="headerlink" title="页目录基址寄存器CR3"></a>页目录基址寄存器CR3</h3><p><img src="/img/SimpleOS-2-Boot/img9.png" alt="img"></p>
<ol>
<li><p>PCD(Page-level Cache Disable)页表高速缓冲禁止位，别管那么多，置0就行</p>
</li>
<li><p>PWT（Page-level Write-Through）页级通写位，别管那么多，置0就行</p>
</li>
</ol>
<h3 id="页表项和页目录项格式"><a href="#页表项和页目录项格式" class="headerlink" title="页表项和页目录项格式"></a>页表项和页目录项格式</h3><p><img src="/img/SimpleOS-2-Boot/img10.png" alt="img"></p>
<ol>
<li><p>为什么页目录项的页表物理地址只有20位而不是32位？因为内存是以4KB每页为单位划分的，因此只要20位地址就可以找到对应的页表了</p>
</li>
<li><p>为什么页表项的物理页地址也只有20位？这20位足够索引到内存中的对应页了，剩下的12位是段内偏移量由线性地址的最后12位组成</p>
</li>
<li><p>AVL是Available位，表示可用，是给软件看的。操作系统可以不管该位</p>
</li>
<li><p>G，全局位。G&#x3D;1，则代表缓存在TLB（页表缓冲寄存器）中了，可以不用经过地址转换，直接通过TLB取值</p>
</li>
<li><p>PAT（Page Attribute Table）此位比较复杂，直接置0即可</p>
</li>
<li><p>D(Dirty)脏位，CPU对一个页进行写操作时，对应的页表项D位置1，表示该页已被修改过</p>
</li>
<li><p>A（Accessd）访问位，每当CPU访问过该页时，对应的A位置1。过一段时间后由操作系统同一置0，操作系统可以通过置0的频率来判断该页是否被经常使用</p>
</li>
<li><p>US（User&#x2F;Supervisor）普通用户&#x2F;超级用户位，为1表示User级，任意特权程序可访问。为0表示Supervisor级，特权级别3的程序不可访问</p>
</li>
<li><p>RW（Read&#x2F;Write）1表示可读可写，0表示可读不可写</p>
</li>
<li><p>P（Present） 存在位，P&#x3D;0表示该表不在物理内存中</p>
</li>
</ol>
<h2 id="elf文件格式相关"><a href="#elf文件格式相关" class="headerlink" title="elf文件格式相关"></a>elf文件格式相关</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/30/SimpleOS-1-%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/30/SimpleOS-1-%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">SimpleOS-1-简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-12-30 12:35:07 / Modified: 15:41:35" itemprop="dateCreated datePublished" datetime="2023-12-30T12:35:07+08:00">2023-12-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本系列博客将用于展示、刨析项目SimpleOS的设计思路，以及提供一些实战时必不可少的工具图表。</p>
<p>SimpleOS是我跟着《操作系统真象还原》一书学习制作的在bochs上运行的简易操作系统。这本书实践性强，知名度高，网络上也有许多关于这本书的教学博客或视频。因此本博客的核心不在于教学如何搭建SimpleOS，本博客的核心是服务于我自己：让本人可以在只有博客的情况下从零开始搭建一个SimpleOS项目。而对于其他读者来说，本博客可以让你从整体上把握SimpleOS并有一个更深入的了解。</p>
<h1 id="自学建议"><a href="#自学建议" class="headerlink" title="自学建议"></a>自学建议</h1><p>如果你想自己体会一步一步搭建SimpleOS的全过程，这边给出了建议：</p>
<ol>
<li><p>《操作系统真象还原》——这本书的实践部分写得非常详细，跟着这本书一步步做可以解决80%的问题。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37500516/article/details/119133589">《操作系统真象还原》从零开始自制操作系统 全流程记录</a>——这篇博客在我搭建SimpleOS时提供了必不可少的帮助，该博客可以帮你解决剩下10%的问题（别小看着10%，帮我省了不少时间）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/xukanshan/the_truth_of_operation_system/blob/main/README.md">本仓库是自己学习操作系统真象还原的代码仓库，请配合本人的笔记与视频使用</a>——最后10%的问题我是通过该Github仓库解决的，该Github仓库提供了从第一章到最后一章每一步的SimpleOS详细代码，并在B站上有视频教程。</p>
</li>
</ol>
<h1 id="SimpleOS系统框架"><a href="#SimpleOS系统框架" class="headerlink" title="SimpleOS系统框架"></a>SimpleOS系统框架</h1><p><img src="/img/SimpleOS-1-%E7%AE%80%E4%BB%8B/img1.png" alt="img"></p>
<p>该系统分为6大模块：Boot程序、内存管理、进程管理、驱动程序、文件系统、Shell</p>
<p>接下来将有7篇博客，前6篇分别介绍这6个模块，最后一篇模块则是介绍通用的工具代码。</p>
<p>对于每一个模块本博客将会采用如下结构进行详细介绍：整体设计方案-数据结构-函数表-关键函数说明-背景知识-工具图表</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>window环境下的虚拟机管理软件采用VMware17</p>
<p>开发环境用linux操作系统Ubuntu20.04.6</p>
<p>C编译器用gcc4(gcc过高将和本书的介绍的elf格式不兼容)</p>
<p>SimpleOS将会安装在PC模拟软件(也是虚拟机)Bochs2.6.8</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/24/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（十四）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-24 01:15:47" itemprop="dateCreated datePublished" datetime="2023-12-24T01:15:47+08:00">2023-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-30 11:57:11" itemprop="dateModified" datetime="2023-12-30T11:57:11+08:00">2023-12-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件系统的核心是管理</p>
<h2 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h2><p>用于描述管理信息（大小一共512字节，一扇区也是一块）</p>
<pre><code>/* 超级块 */
struct super_block &#123;
    uint32_t magic;		    // 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型

    //描述总分区信息
    uint32_t sec_cnt;		    // 本分区总共的扇区数
    uint32_t inode_cnt;		    // 本分区中inode数量
    uint32_t part_lba_base;	    // 本分区的起始lba地址


    //描述空闲块位图
    uint32_t block_bitmap_lba;	    // 块位图本身起始扇区地址
    uint32_t block_bitmap_sects;     // 扇区位图本身占用的扇区数量


    //描述inode位图
    uint32_t inode_bitmap_lba;	    // i结点位图起始扇区lba地址
    uint32_t inode_bitmap_sects;	    // i结点位图占用的扇区数量


    //描述inode表
    uint32_t inode_table_lba;	    // i结点表起始扇区lba地址
    uint32_t inode_table_sects;	    // i结点表占用的扇区数量


    //描述数据区(包含根目录)
    uint32_t data_start_lba;	    // 数据区开始的第一个扇区号
    uint32_t root_inode_no;	    // 根目录所在的I结点号
    uint32_t dir_entry_size;	    // 目录项大小

    uint8_t  pad[460];		    // 加上460字节,凑够512字节1扇区大小
&#125; __attribute__ ((packed));
</code></pre>
<h3 id="空闲块位图"><a href="#空闲块位图" class="headerlink" title="空闲块位图"></a>空闲块位图</h3><h3 id="inode位图"><a href="#inode位图" class="headerlink" title="inode位图"></a>inode位图</h3><h3 id="inode表"><a href="#inode表" class="headerlink" title="inode表"></a>inode表</h3><h3 id="根目录数据区"><a href="#根目录数据区" class="headerlink" title="根目录数据区"></a>根目录数据区</h3><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>inode相当于是文件的本身，一个inode就是一个文件</p>
<pre><code>/* inode结构 */
struct inode &#123;
    uint32_t i_no;    // inode编号

    /* 当此inode是文件时,i_size是指文件大小,
    若此inode是目录,i_size是指该目录下所有目录项大小之和*/
    uint32_t i_size;

    uint32_t i_open_cnts;   // 记录此文件被打开的次数
    bool write_deny;	   // 写文件不能并行,进程写文件前检查此标识

    /* i_sectors[0-11]是直接块, i_sectors[12]用来存储一级间接块指针 */
    uint32_t i_sectors[13];
    struct list_elem inode_tag;
&#125;;
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/12/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/12/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（十一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-12-12 13:24:49 / Modified: 18:42:09" itemprop="dateCreated datePublished" datetime="2023-12-12T13:24:49+08:00">2023-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>用户进程</p>
<h1 id="任务状态段TSS"><a href="#任务状态段TSS" class="headerlink" title="任务状态段TSS"></a>任务状态段TSS</h1><p>TSS结构如下：<br><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/img1.png" alt="img"></p>
<p>TSS是用于切换任务时保存当前环境的工具。TTS提供了三个特权级栈，当该任务提升特权级时就会对应使用相应的特权级栈（使用不同的栈保证低特权级无法访问到高特权级的资源）</p>
<p>在Linux系统中，用户程序处于特权级3，内核程序处于特权级0，Linux不使用TTS结构来保存上下文环境，Linux只使用了TSS中的0特权级栈一个结构。</p>
<p>LinuxOS的逻辑如下：只维护一个TSS，每次切换任务时修改TSS0特权级栈，其他功能一律不使用。至于上下文环境Linux则是保存在PCB结构中。</p>
<p>TSS结构本质上是一个特殊的段，因此要在GDT中构造TSS专用的TSS描述符，同时也得构造TSS选择子，我们可以通过TSS选择子在GDT中寻找到TSS描述符，进而寻找到TSS结构。</p>
<p>TR寄存器通过TSS选择子寻找到TSS结构，然后存储TSS的起始地址以及偏移大小。（TR加载命令如下：<code>ltr 16位TTS选择子</code>）</p>
<p>TR结构如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/img3.png" alt="img"></p>
<p>通过TSS选择子寻找TSS的逻辑如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/img2.png" alt="img"></p>
<h1 id="定义并初始化TSS"><a href="#定义并初始化TSS" class="headerlink" title="定义并初始化TSS"></a>定义并初始化TSS</h1><p>我们所要做的事如下：</p>
<ol>
<li><p>定义TSS段描述符，并装载在gdt中</p>
</li>
<li><p>定义TSS段描述符，并用 ltr 命令装载到 TR 里</p>
</li>
<li><p>初始化TSS（初始化一次TSS后就无需再更换了，后续切换任务只修改TSS中0特权级栈的内容）</p>
</li>
</ol>
<p>代码如下：</p>
<ul>
<li><p>kernel&#x2F;global.h</p>
<pre><code>  #ifndef __KERNEL_GLOBAL_H
  #define __KERNEL_GLOBAL_H
  #include &quot;stdint.h&quot;

  #define	 RPL0  0
  #define	 RPL1  1
  #define	 RPL2  2
  #define	 RPL3  3
  #define	 PG_SIZE  4096

  #define TI_GDT 0
  #define TI_LDT 1

  //--------------   GDT描述符属性  ------------

  #define DESC_G_4K	1
  #define DESC_D_32	1
  #define DESC_L		0
  #define DESC_AVL	0
  #define DESC_P		1
  #define DESC_DPL_0	0
  #define DESC_DPL_1	1
  #define DESC_DPL_2	2
  #define DESC_DPL_3	3

  #define DESC_S_CODE	1
  #define DESC_S_DATA	DESC_S_CODE
  #define DESC_S_SYS	0
  #define DESC_TYPE_CODE	8

  #define DESC_TYPE_DATA 2
  #define DESC_TYPE_TSS  9

  /*KERNEL段*/
  #define SELECTOR_K_CODE	   ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)
  #define SELECTOR_K_DATA	   ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)
  #define SELECTOR_K_STACK          SELECTOR_K_DATA 
  #define SELECTOR_K_GS	           ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)
  /*这里是TSS*/
  /*USER段*/
  #define SELECTOR_U_CODE  	   ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)
  #define SELECTOR_U_DATA	   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)
  #define SELECTOR_U_STACK	   SELECTOR_U_DATA

  #define GDT_ATTR_HIGH		   ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))

  #define GDT_CODE_ATTR_LOW_DPL3    ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)

  #define GDT_DATA_ATTR_LOW_DPL3    ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)



  //--------------   IDT描述符属性  ------------
  #define	 IDT_DESC_P	 1 
  #define	 IDT_DESC_DPL0   0
  #define	 IDT_DESC_DPL3   3
  #define	 IDT_DESC_32_TYPE     0xE   // 32位的门
  #define	 IDT_DESC_16_TYPE     0x6   // 16位的门，不用，定义它只为和32位门区分
  #define	 IDT_DESC_ATTR_DPL0  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL0 &lt;&lt; 5) + IDT_DESC_32_TYPE)
  #define	 IDT_DESC_ATTR_DPL3  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL3 &lt;&lt; 5) + IDT_DESC_32_TYPE)


  //--------------   TSS描述符属性  ------------
  #define	 TSS_DESC_D 0
  #define 	 TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0X0)
  #define 	 TSS_ATTR_LOW  ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)

  #define 	 SELECTOR_TSS  ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)

  /*描述符结构*/
  struct gdt_desc
  &#123;
      uint16_t limit_low_word;
      uint16_t base_low_word;
      uint8_t  base_mid_byte;
      uint8_t  attr_low_byte;
      uint8_t  limit_high_attr_high;
      uint8_t  base_high_byte;
  &#125;;

  #endif
</code></pre>
</li>
<li><p>userprog&#x2F;tss.c</p>
<pre><code>  #include &quot;tss.h&quot;
  #include &quot;global.h&quot;
  #include &quot;thread.h&quot;
  #include &quot;print.h&quot;
  #include &quot;string.h&quot;
  #include &quot;stdint.h&quot;

  struct tss
  &#123;
      uint32_t backlink;
      uint32_t* esp0;
      uint32_t ss0;
      uint32_t* esp1;
      uint32_t ss1;
      uint32_t* esp2;
      uint32_t ss2;
      uint32_t cr3;
      uint32_t (*eip) (void);  //eip是一个函数指针
      uint32_t eflags;
      uint32_t eax;
      uint32_t ecx;
      uint32_t edx;
      uint32_t ebx;
      uint32_t esp;
      uint32_t ebp;
      uint32_t esi;
      uint32_t edi;
      uint32_t es;
      uint32_t cs;
      uint32_t ss;
      uint32_t ds;
      uint32_t fs;
      uint32_t gs;
      uint32_t ldt;
      uint32_t trace;
      uint32_t io_base;
  &#125;;

  static struct tss tss;

  //切换tss的0特权级栈，相当于任务切换
  void updata_tss_esp(struct task_struct* pthread)
  &#123;
      tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
  &#125;


  struct gdt_desc make_gdt_desc(uint32_t* desc_addr,uint32_t limit,uint8_t attr_low,uint8_t attr_high)
  &#123;
      struct gdt_desc desc;
      uint32_t desc_base = (uint32_t) desc_addr;
      desc.limit_low_word =  limit &amp; 0x0000ffff;
      desc.base_low_word = desc_base &amp; 0x0000ffff;
      desc.base_mid_byte = ((desc_base &amp; 0x00ff0000) &gt;&gt; 16);
      desc.attr_low_byte = (uint8_t)(attr_low);
      desc.limit_high_attr_high = (((limit &amp; 0x000f0000) &gt;&gt; 16) + (uint8_t)(attr_high));
      desc.base_high_byte = desc_base &gt;&gt; 24;
      return desc;
  &#125;

  void tss_init()
  &#123;
      put_str(&quot;tss_init start\n&quot;);
      uint32_t tss_size = sizeof(tss);
      memset(&amp;tss,0,tss_size);
      tss.ss0 = SELECTOR_K_STACK;
      tss.io_base = tss_size;
      
      //之前的gdt放在了0xc0000903的位置
      *((struct gdt_desc*)0xc0000923) = make_gdt_desc((uint32_t*)&amp;tss,tss_size-1,TSS_ATTR_LOW,TSS_ATTR_HIGH);
      *((struct gdt_desc*)0xc000092b) = make_gdt_desc((uint32_t*)0,0xfffff,GDT_CODE_ATTR_LOW_DPL3,\
                                              GDT_ATTR_HIGH);
      *((struct gdt_desc*)0xc0000933) = make_gdt_desc((uint32_t*)0,0xfffff,GDT_DATA_ATTR_LOW_DPL3,\
                                              GDT_ATTR_HIGH);
      
      uint64_t gdt_operand = \
      ((8*7 - 1) | ((uint64_t)(uint32_t)0xc0000903 &lt;&lt; 16));
      

      //重新加载gdt
      asm volatile(&quot;lgdt %0&quot; :: &quot;m&quot;(gdt_operand));

      //将tss加载到tr
      asm volatile(&quot;ltr %w0&quot; :: &quot;r&quot;(SELECTOR_TSS));

      put_str(&quot;tss_init and ltr done\n&quot;);
  &#125;
</code></pre>
</li>
</ul>
<p>程序运行后现在可以看到gdt里一共有7个段描述符：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/img4.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/30/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/30/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（十）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-30 16:15:51" itemprop="dateCreated datePublished" datetime="2023-11-30T16:15:51+08:00">2023-11-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-12 12:30:58" itemprop="dateModified" datetime="2023-12-12T12:30:58+08:00">2023-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="同步机制——锁"><a href="#同步机制——锁" class="headerlink" title="同步机制——锁"></a>同步机制——锁</h1><p>当多个线程共同使用一样公共资源时，就有可能会出现竞争问题。在我们上一章节主线程、A线程和B线程都在打印字符，显存以及put_str()就是我们的公共资源。正是因为竞争问题，所以在上一章节中运行过程会出现字符串错误，并且运行到最后会报错(显存越界)。</p>
<p>所以我们需要实现一个锁，只有持有锁的人才能操作公共资源。我们将使用二元信号量实现锁的同步机制。</p>
<p>函数逻辑关系如图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img1.png" alt="img"></p>
<p>代码如下：</p>
<ul>
<li><p>thread&#x2F;thread.c(新增部分)</p>
<pre><code>  void thread_block(enum task_status stat)&#123;
      ASSERT((stat==TASK_BLOCKED)||(stat==TASK_HANGING)||(stat==TASK_WAITING));
      enum intr_status old_status=intr_disable();

      struct task_struct* cur_thread=running_thread();
      cur_thread-&gt;status=stat;
      schedule();

      intr_set_status(old_status);
  &#125;

  void thread_unblock(struct task_struct* pthread)&#123;
      enum intr_status old_status=intr_disable();

      ASSERT((pthread-&gt;status==TASK_BLOCKED)||(pthread-&gt;status==TASK_HANGING)||(pthread-&gt;status==TASK_WAITING));
      if(pthread-&gt;status!=TASK_READY)&#123;
          ASSERT(!elem_fimd(&amp;thread_ready_list,&amp;pthread-&gt;general_tag));
          if(elem_fimd(&amp;thread_ready_list,&amp;pthread-&gt;general_tag))&#123;
              PANIC(&quot;thread_unblock:blocked thread in ready_list\n&quot;);
          &#125;
          list_push(&amp;thread_ready_list,&amp;pthread-&gt;general_tag);
          pthread-&gt;status=TASK_READY;
      &#125;

      intr_set_status(old_status);
  &#125;
</code></pre>
</li>
<li><p>thread&#x2F;sync.h</p>
<pre><code>  #ifndef __THREAD_SYNC_H__
  #define __THREAD_SYNC_H__

  #include &quot;list.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;thread.h&quot;


  struct semaphore&#123;
      uint8_t value;
      struct list waiters;
  &#125;;


  struct lock&#123;
      struct task_struct* holder;
      struct semaphore semaphore;  //用二元信号量实现锁
      uint32_t holder_repeat_nr;
  &#125;;

  void sema_init(struct semaphore* psema,uint8_t value);
  void lock_init(struct lock* plock);
  void sema_down(struct semaphore* psema);
  void sema_up(struct semaphore* psema);
  void lock_acquire(struct lock* plock);
  void lock_release(struct lock* plock);

  #endif
</code></pre>
</li>
<li><p>thread&#x2F;sync.c</p>
<pre><code>  #include &quot;sync.h&quot;

  void sema_init(struct semaphore* psema,uint8_t value)&#123;

      psema-&gt;value=value;
      list_init(&amp;psema-&gt;waiters);

  &#125;

  void lock_init(struct lock* plock)&#123;
      plock-&gt;holder=NULL;
      plock-&gt;holder_repeat_nr=0;
      sema_init(&amp;plock-&gt;semaphore,1);
  &#125;


  //信号量-1操作
  void sema_down(struct semaphore* psema)&#123;
      enum intr_status old_status=intr_disable();

      while(psema-&gt;value==0)&#123;
          ASSERT(!elem_find(&amp;psema-&gt;waiters,&amp;running_thread()-&gt;general_tag));

          if(elem_find(&amp;psema-&gt;waiters,&amp;running_thread()-&gt;general_tag))&#123;
              PANIC(&quot;sema_down:thread blocked has been in waiters_list\n&quot;);
          &#125;

          list_append(&amp;psema-&gt;waiters,&amp;running_thread()-&gt;general_tag);
          thread_block(TASK_BLOCKED);
      &#125;
      psema-&gt;value--;
      ASSERT(psema-&gt;value==0);

      intr_set_status(old_status);
  &#125;

  //信号量+1操作
  void sema_up(struct semaphore* psema)&#123;
      enum intr_status old_status=intr_disable();
      
      ASSERT(psema-&gt;value==0);
      if(!list_empty(&amp;psema-&gt;waiters))&#123;
          struct task_struct* thread_blocked =elem2entry(struct task_struct, general_tag,list_pop(&amp;psema-&gt;waiters));
          thread_unblock(thread_blocked);
      &#125;
      psema-&gt;value++;
      ASSERT(psema-&gt;value==1);

      intr_set_stauts(old_status);
  &#125;

  //获取锁plock
  void lock_acquire(struct lock* plock)&#123;
      if(plock-&gt;holder!=running_thread())&#123;
          sema_down(&amp;plock-&gt;semaphore);
          plock-&gt;holder=running_thread();
          ASSERT(plock-&gt;holder_repeat_nr==0);
          plock-&gt;holder_repeat_nr=1;
      &#125;else&#123;
          plock-&gt;holder_repeat_nr++;
      &#125;
  &#125;

  //释放锁plock
  void lock_release(struct lock* plock)&#123;
      ASSERT(plock-&gt;holder==running_thread());
      if(plock-&gt;holder_repeat_nr&gt;1)&#123;
          plock-&gt;holder_repeat_nr--;
          return;
      &#125;
      ASSERT(plock-&gt;holder_repeat_nr==1);
      
      plock-&gt;holder=NULL;
      plock-&gt;holder_repeat_nr=0;
      sema_up(&amp;plock-&gt;semaphore);
  &#125;
</code></pre>
</li>
</ul>
<p>接下来我们将在控制台作为一个公共资源，在控制台上打印字符就必须获得控制台的锁，实现代码如下</p>
<ul>
<li><p>device&#x2F;console.h</p>
<pre><code>  #ifndef __DEVICE_CONSOLE_H__
  #define __DEVICE_CONSOLE_H__
  #include &quot;stdint.h&quot;

  void console_init(void);

  void console_release(void);

  void console_acquire(void);

  void console_put_char(uint8_t char_asci);

  void console_put_str(char* str);

  void console_put_int(uint32_t num);

  #endif
</code></pre>
</li>
<li><p>device&#x2F;console.c</p>
<pre><code>  #include &quot;console.h&quot;
  #include &quot;print.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;sync.h&quot;
  #include &quot;thread.h&quot;

  static struct lock console_lock;

  void console_init()&#123;
      lock_init(&amp;console_lock);
  &#125;

  void console_release()&#123;
      lock_release(&amp;console_lock);
  &#125;

  void console_acquire()&#123;
      lock_acquire(&amp;console_lock);
  &#125;

  void console_put_char(uint8_t char_asci)&#123;
      console_acquire();
      put_char(char_asci);
      console_release();
  &#125;

  void console_put_str(char* str)&#123;
      console_acquire();
      put_str(str);
      console_release();  
  &#125;

  void console_put_int(uint32_t num)&#123;
      console_acquire();
      put_int(num);
      console_release();  
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;main.c(将原本的put_str()换成console_put_str())</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;
  #include &quot;debug.h&quot;
  #include &quot;memory.h&quot;
  #include &quot;thread.h&quot;
  #include &quot;console.h&quot;

  void k_thread_a(void*);
  void k_thread_b(void*);

  int main(void) &#123;
  put_str(&quot;I am kernel\n&quot;);
  init_all();


  thread_start(&quot;k_thread_a&quot;,31,k_thread_a,&quot;argA &quot;);
  thread_start(&quot;k_thread_b&quot;,8,k_thread_b,&quot;argB &quot;);

  intr_enable();
  while(1)&#123;
      console_put_str(&quot;Main &quot;);
  &#125;;
  
  return 0;
  &#125;


  //在线程中运行的函数
  void k_thread_a(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      console_put_str(para);
  &#125;
  &#125;

  void k_thread_b(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      console_put_str(para);
  &#125;
  &#125;
</code></pre>
</li>
</ul>
<p>我们就可以正确的打印字符而不报错了。</p>
<h1 id="编写键盘驱动程序"><a href="#编写键盘驱动程序" class="headerlink" title="编写键盘驱动程序"></a>编写键盘驱动程序</h1><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img2.png" alt="img"></p>
<p>如上图所示，键盘上有芯片8048用于捕获按键的扫描码并传递给8042，8042是再主机上的键盘控制器负责CPU和键盘之间的沟通，8042会将从8048里收到的不同格式的扫描码统一成第一套键盘扫描码并向8259A发送键盘中断信号，8259A就是我们的老朋友了，用于中断管理。</p>
<p>工作流程如下：每当我们按下键盘的任一一个按键时，8048会捕获该按键的扫描码并发送给8042。8042接受扫描码后会将其翻译成第一套键盘扫描码(统一格式)，每一个按键的扫描码可能是一个字节也可能是两个字节（甚至可能是多个字节）。但8042只会一个字节一个字节的放到自己的缓冲区里并通知CPU来取数据(通过键盘中断),CPU不取走上一个数据，8042就不会放下一个数据，如此循环直到键盘按键的所有信息都被传输给了CPU</p>
<p>第一套键盘扫描码格式如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img3.png" alt="img"></p>
<p>8048工作内容以及寄存器如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img4.png" alt="img"></p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img5.png" alt="img"></p>
<p><strong>PS：在8048中的4个寄存器我们只需要从0x60的输出缓冲区里不断读取数据</strong></p>
<p>写下来我们要编写键盘驱动程序，键盘驱动程序的核心就是一个中断处理函数intr_keyboard_handler(void);该函数负责把从8042中取得的第一套扫描码转化成相应的ASCII码，然后用put_char()输出。</p>
<p>看上去很简单对吧，但这是在没有组合键的请看下，组合键shift、Ctrl、Capslk让一切都变得有些麻烦(当我们按下组合键时并不会输入任何字符，但是当我们同时搭配组合键和普通按键时却会改变普通按键的功能)，请直接看代码。</p>
<ul>
<li><p>kernel&#x2F;kernel.S(添加几个中断入口，支持的中断数由原本的33个变成48个)</p>
<pre><code>  VECTOR 0X20 ,ZERO					;时钟中断
  VECTOR 0X21 ,ZERO					;键盘中断
  VECTOR 0X22 ,ZERO					;级联
  VECTOR 0X23 ,ZERO					;串口2
  VECTOR 0X24 ,ZERO					;串口1
  VECTOR 0X25 ,ZERO					;并口2
  VECTOR 0X26 ,ZERO					;软盘
  VECTOR 0X27 ,ZERO					;并口1
  VECTOR 0X28 ,ZERO					;实时时钟
  VECTOR 0X29 ,ZERO					;重定向
  VECTOR 0X2A ,ZERO					;保留
  VECTOR 0x2B ,ZERO					;保留
  VECTOR 0x2C ,ZERO					;ps/2 鼠标
  VECTOR 0x2D ,ZERO					;fpu 浮点单元异常
  VECTOR 0x2E ,ZERO					;硬盘
  VECTOR 0x2F ,ZERO					;保留
</code></pre>
</li>
<li><p>device&#x2F;keyboard.c</p>
<pre><code>  #include &quot;keyboard.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;io.h&quot;
  #include &quot;global.h&quot;
  #include &quot;stdint.h&quot;

  #define KBD_BUF_PORT 0x60

  //定义部分字符控制键的转义字符（可直接用put_char处理）
  #define esc     &#39;\0x33&#39;     //八进制ASCII码转义
  #define backspace &#39;\b&#39;
  #define tab       &#39;\t&#39;
  #define enter       &#39;\r&#39;
  #define delete      &#39;\177&#39;  //八进制ASCII码转义

  //定义不可见字符为0
  #define char_invisible 0
  #define ctrl_l_char char_invisible
  #define ctrl_r_char char_invisible
  #define shift_l_char char_invisible
  #define shift_r_char char_invisible
  #define alt_l_char char_invisible
  #define alt_r_char char_invisible
  #define caps_lock_char char_invisible


  //定义控制字符的通码和断码
  #define shift_l_make 0x2a
  #define shift_r_make 0x36
  #define alt_l_make 0x38
  #define alt_r_make 0xe038
  #define alt_r_break 0xe0b8
  #define ctrl_l_make 0x1d
  #define ctrl_r_make 0xe01d
  #define ctrl_r_break 0xe09d
  #define caps_lock_make 0x3a


  bool ctrl_status = false,shift_status = false,alt_status = false,caps_lock_status = false,ext_scancode = false;


  //该二维数组的索引是扫描码，元素0代表未按下shift键时的输出字符，元素1代表按下shift键时的输出字符
  char keymap[][2] = &#123;
  /* 0x00 */	&#123;0,	0&#125;,		
  /* 0x01 */	&#123;esc,	esc&#125;,		
  /* 0x02 */	&#123;&#39;1&#39;,	&#39;!&#39;&#125;,		
  /* 0x03 */	&#123;&#39;2&#39;,	&#39;@&#39;&#125;,		
  /* 0x04 */	&#123;&#39;3&#39;,	&#39;#&#39;&#125;,		
  /* 0x05 */	&#123;&#39;4&#39;,	&#39;$&#39;&#125;,		
  /* 0x06 */	&#123;&#39;5&#39;,	&#39;%&#39;&#125;,		
  /* 0x07 */	&#123;&#39;6&#39;,	&#39;^&#39;&#125;,		
  /* 0x08 */	&#123;&#39;7&#39;,	&#39;&amp;&#39;&#125;,		
  /* 0x09 */	&#123;&#39;8&#39;,	&#39;*&#39;&#125;,		
  /* 0x0A */	&#123;&#39;9&#39;,	&#39;(&#39;&#125;,		
  /* 0x0B */	&#123;&#39;0&#39;,	&#39;)&#39;&#125;,		
  /* 0x0C */	&#123;&#39;-&#39;,	&#39;_&#39;&#125;,		
  /* 0x0D */	&#123;&#39;=&#39;,	&#39;+&#39;&#125;,		
  /* 0x0E */	&#123;backspace, backspace&#125;,	
  /* 0x0F */	&#123;tab,	tab&#125;,		
  /* 0x10 */	&#123;&#39;q&#39;,	&#39;Q&#39;&#125;,		
  /* 0x11 */	&#123;&#39;w&#39;,	&#39;W&#39;&#125;,		
  /* 0x12 */	&#123;&#39;e&#39;,	&#39;E&#39;&#125;,		
  /* 0x13 */	&#123;&#39;r&#39;,	&#39;R&#39;&#125;,		
  /* 0x14 */	&#123;&#39;t&#39;,	&#39;T&#39;&#125;,		
  /* 0x15 */	&#123;&#39;y&#39;,	&#39;Y&#39;&#125;,		
  /* 0x16 */	&#123;&#39;u&#39;,	&#39;U&#39;&#125;,		
  /* 0x17 */	&#123;&#39;i&#39;,	&#39;I&#39;&#125;,		
  /* 0x18 */	&#123;&#39;o&#39;,	&#39;O&#39;&#125;,		
  /* 0x19 */	&#123;&#39;p&#39;,	&#39;P&#39;&#125;,		
  /* 0x1A */	&#123;&#39;[&#39;,	&#39;&#123;&#39;&#125;,		
  /* 0x1B */	&#123;&#39;]&#39;,	&#39;&#125;&#39;&#125;,		
  /* 0x1C */	&#123;enter,  enter&#125;,
  /* 0x1D */	&#123;ctrl_l_char, ctrl_l_char&#125;,
  /* 0x1E */	&#123;&#39;a&#39;,	&#39;A&#39;&#125;,		
  /* 0x1F */	&#123;&#39;s&#39;,	&#39;S&#39;&#125;,		
  /* 0x20 */	&#123;&#39;d&#39;,	&#39;D&#39;&#125;,		
  /* 0x21 */	&#123;&#39;f&#39;,	&#39;F&#39;&#125;,		
  /* 0x22 */	&#123;&#39;g&#39;,	&#39;G&#39;&#125;,		
  /* 0x23 */	&#123;&#39;h&#39;,	&#39;H&#39;&#125;,		
  /* 0x24 */	&#123;&#39;j&#39;,	&#39;J&#39;&#125;,		
  /* 0x25 */	&#123;&#39;k&#39;,	&#39;K&#39;&#125;,		
  /* 0x26 */	&#123;&#39;l&#39;,	&#39;L&#39;&#125;,		
  /* 0x27 */	&#123;&#39;;&#39;,	&#39;:&#39;&#125;,		
  /* 0x28 */	&#123;&#39;\&#39;&#39;,	&#39;&quot;&#39;&#125;,		
  /* 0x29 */	&#123;&#39;`&#39;,	&#39;~&#39;&#125;,		
  /* 0x2A */	&#123;shift_l_char, shift_l_char&#125;,	
  /* 0x2B */	&#123;&#39;\\&#39;,	&#39;|&#39;&#125;,		
  /* 0x2C */	&#123;&#39;z&#39;,	&#39;Z&#39;&#125;,		
  /* 0x2D */	&#123;&#39;x&#39;,	&#39;X&#39;&#125;,		
  /* 0x2E */	&#123;&#39;c&#39;,	&#39;C&#39;&#125;,		
  /* 0x2F */	&#123;&#39;v&#39;,	&#39;V&#39;&#125;,		
  /* 0x30 */	&#123;&#39;b&#39;,	&#39;B&#39;&#125;,		
  /* 0x31 */	&#123;&#39;n&#39;,	&#39;N&#39;&#125;,		
  /* 0x32 */	&#123;&#39;m&#39;,	&#39;M&#39;&#125;,		
  /* 0x33 */	&#123;&#39;,&#39;,	&#39;&lt;&#39;&#125;,		
  /* 0x34 */	&#123;&#39;.&#39;,	&#39;&gt;&#39;&#125;,		
  /* 0x35 */	&#123;&#39;/&#39;,	&#39;?&#39;&#125;,
  /* 0x36	*/	&#123;shift_r_char, shift_r_char&#125;,	
  /* 0x37 */	&#123;&#39;*&#39;,	&#39;*&#39;&#125;,    	
  /* 0x38 */	&#123;alt_l_char, alt_l_char&#125;,
  /* 0x39 */	&#123;&#39; &#39;,	&#39; &#39;&#125;,		
  /* 0x3A */	&#123;caps_lock_char, caps_lock_char&#125;
  &#125;;


  static void intr_kerboard_handler(void)&#123;

      bool ctrl_down_last=ctrl_status;
      bool shift_down_last=shift_status;
      bool caps_lock_last=caps_lock_status;

      bool break_code;
      uint16_t scancode=inb(KBD_BUF_PORT);//必须读取缓冲区数据，否则8042不再继续响应键盘中断

      //打开拓展标志，并返回，（说明要接受的扫描码不止1字节，有两字节）
      if(scancode == 0xe0)&#123;
          ext_scancode=true;
          return;
      &#125;

      if(ext_scancode)&#123;
          scancode=(0xe000|scancode);
          ext_scancode=false;
      &#125;


      //true则代表是断码，否则是通码
      break_code=((scancode&amp;0x0080)!=0);

      if(break_code)&#123;
          uint16_t make_code=(scancode&amp;=0xff7f);

          //改变状态
          if(make_code==ctrl_l_make||make_code==ctrl_r_make)&#123;
              ctrl_status=false;
          &#125;else if(make_code == shift_l_make || make_code==shift_r_make)&#123;
              shift_status=false;
          &#125;else if(make_code == alt_l_make || make_code ==alt_r_make)&#123;
              alt_status=false;
          &#125;

          return;
      &#125;else if((scancode&gt;0x00 &amp;&amp; scancode&lt;0x3b)||(scancode == alt_r_make)||(scancode ==ctrl_r_make))&#123;
          
          //shift用于判断keymap到底是要输出元素0还是元素1
          bool shift=false;


          //区分双字符键和单子符键，capslk和shift对双字符键和单字符键作用不一样
          if((scancode &lt; 0x0e) || (scancode == 0x29) || (scancode == 0x1a) || \
          (scancode == 0x1b) || (scancode == 0x2b) || (scancode == 0x27) || \
          (scancode == 0x28) || (scancode == 0x33) || (scancode == 0x34) || \
          (scancode == 0x35))&#123;

              if(shift_down_last)&#123;
                  shift = true;
              &#125;

          &#125;else&#123;  //默认是字符键
              if(shift_down_last &amp;&amp; caps_lock_last)&#123;
                  shift = false; //效果确实是这样子的 我试了一下
              &#125;else if(shift_down_last || caps_lock_last)&#123;
                  shift = true; //其中任意一个都是大写的作用
              &#125;else&#123;
                  shift = false;
              &#125; 
          &#125;


          //忽略高8位，也就是0xe0的影响
          uint8_t index=(scancode&amp;=0x00ff);

          char cur_char = keymap[index][shift];

          if(cur_char)&#123;
              put_char(cur_char);
              return;
          &#125;

          if(scancode == ctrl_l_make || scancode == ctrl_r_make)&#123;
              ctrl_status = true;
          &#125;  	
          else if(scancode == shift_l_make || scancode == shift_r_make)&#123;
              shift_status = true;
          &#125;
          else if(scancode == alt_l_make || scancode == alt_r_make)&#123;
              alt_status = true;
          &#125;
          else if(scancode == caps_lock_make)&#123;
              caps_lock_status = !caps_lock_status;
          &#125;
          
      &#125;else&#123;
          put_str(&quot;unknown key\n&quot;);
      &#125;

  &#125;

  void keyboard_init()&#123;
      put_str(&quot;keyboard init start\n&quot;);
      register_handler(0x21,intr_kerboard_handler);
      put_str(&quot;kerboard init done\n&quot;);
  &#125;
</code></pre>
</li>
</ul>
<h1 id="环形输入缓冲区"><a href="#环形输入缓冲区" class="headerlink" title="环形输入缓冲区"></a>环形输入缓冲区</h1><p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img6.png" alt="img"></p>
<p>如图是线性缓冲区的生成者与消费者示例图，生产者在前面生产，消费者在后面消费</p>
<p>我们要将线性缓冲区变成环形，如下图示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%81%EF%BC%89/img7.png" alt="img"></p>
<p>构造环形输入缓冲区是为了实现Shell命令的键入，Shell的命令是由数个字符组成，我们可以先用键盘输入(生产者),将数个字符存在缓冲区中，再用shell一次性读入（消费者）</p>
<p>实现代码如下：</p>
<ul>
<li><p>device&#x2F;ioqueue.h</p>
<pre><code>  #ifndef __DEVICE_IOQUEUE_H__
  #define __DEVICE_IOQUEUE_H__

  #include &quot;stdint.h&quot;
  #include &quot;thread.h&quot;
  #include &quot;sync.h&quot;

  #define bufsize 64

  struct ioqueue&#123;
      struct lock lock;
      struct task_struct* producer;
      struct task_struct* consumer;
      char buf[bufsize];
      int32_t head;
      int32_t tail;
  &#125;;


  void ioqueue_init(struct ioqueue* ioq);
  char ioq_getchar(struct ioqueue* ioq);
  void ioq_putchar(struct ioqueue* ioq,char byte);
  bool ioq_empty(struct ioqueue* ioq);
  bool ioq_full(struct ioqueue* ioq);

  #endif
</code></pre>
</li>
<li><p>device&#x2F;ioqueue.c</p>
<pre><code>  #include &quot;ioqueue.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;global.h&quot;
  #include &quot;debug.h&quot;


  void ioqueue_init(struct ioqueue* ioq)&#123;
      lock_init(&amp;ioq-&gt;lock);
      ioq-&gt;producer=ioq-&gt;consumer=NULL;
      ioq-&gt;head=ioq-&gt;tail=0;
  &#125;


  static int32_t next_pos(int32_t pos)&#123;
      return (pos+1)%bufsize;
  &#125;

  bool ioq_full(struct ioqueue* ioq)&#123;
      ASSERT(intr_get_status()==INTR_OFF);
      return next_pos(ioq-&gt;head)==ioq-&gt;tail;
  &#125;

  bool ioq_empty(struct ioqueue* ioq)&#123;
      ASSERT(intr_get_status()==INTR_OFF);
      return ioq-&gt;head==ioq-&gt;tail;
  &#125;


  static void ioq_wait(struct  task_struct** waiter)&#123;
      ASSERT(*waiter==NULL &amp;&amp; waiter!=NULL);
      *waiter = running_thread();
      thread_block(TASK_BLOCKED);
  &#125;

  static void wakeup(struct task_struct** waiter)&#123;
      ASSERT(*waiter!=NULL);
      thread_unblock(*waiter);
      *waiter=NULL;
  &#125;

  char ioq_getchar(struct ioqueue* ioq)&#123;
      ASSERT(intr_get_status()==INTR_OFF);

      while(ioq_empty(ioq))&#123;
          lock_acquire(&amp;ioq-&gt;lock);
          ioq_wait(&amp;ioq-&gt;consumer);
          lock_release(&amp;ioq-&gt;lock);
      &#125;

      char byte=ioq-&gt;buf[ioq-&gt;tail];
      ioq-&gt;tail=next_pos(ioq-&gt;tail);

      if(ioq-&gt;producer!=NULL)&#123;
          wakeup(&amp;ioq-&gt;producer);
      &#125;

      return byte;
  &#125;


  void ioq_putchar(struct ioqueue* ioq,char byte)&#123;
      ASSERT(intr_get_status()==INTR_OFF);

      while(ioq_full(ioq))&#123;
          lock_acquire(&amp;ioq-&gt;lock);
          ioq_wait(&amp;ioq-&gt;producer);
          lock_release(&amp;ioq-&gt;lock);
      &#125;

      ioq-&gt;buf[ioq-&gt;head]=byte;
      ioq-&gt;head=next_pos(ioq-&gt;head);

      if(ioq-&gt;consumer!=NULL)&#123;
          wakeup(&amp;ioq-&gt;consumer);
      &#125;
  &#125;
</code></pre>
</li>
<li><p>device&#x2F;keyboard.h</p>
<pre><code>  #ifndef __KEYBOARD_H__
  #define __KEYBOARD_H__

  void keyboard_init(void);

  extern struct ioqueue kbd_buf;

  #endif
</code></pre>
</li>
<li><p>device&#x2F;keyboard.c(修改)</p>
<pre><code>  #include &quot;keyboard.h&quot;
  #include &quot;print.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;io.h&quot;
  #include &quot;global.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;ioqueue.h&quot;

  #define KBD_BUF_PORT 0x60

  //定义部分字符控制键的转义字符（可直接用put_char处理）
  #define esc     &#39;\0x33&#39;     //八进制ASCII码转义
  #define backspace &#39;\b&#39;
  #define tab       &#39;\t&#39;
  #define enter       &#39;\r&#39;
  #define delete      &#39;\177&#39;  //八进制ASCII码转义

  //定义不可见字符为0
  #define char_invisible 0
  #define ctrl_l_char char_invisible
  #define ctrl_r_char char_invisible
  #define shift_l_char char_invisible
  #define shift_r_char char_invisible
  #define alt_l_char char_invisible
  #define alt_r_char char_invisible
  #define caps_lock_char char_invisible


  //定义控制字符的通码和断码
  #define shift_l_make 0x2a
  #define shift_r_make 0x36
  #define alt_l_make 0x38
  #define alt_r_make 0xe038
  #define alt_r_break 0xe0b8
  #define ctrl_l_make 0x1d
  #define ctrl_r_make 0xe01d
  #define ctrl_r_break 0xe09d
  #define caps_lock_make 0x3a


  bool ctrl_status = false,shift_status = false,alt_status = false,caps_lock_status = false,ext_scancode = false;


  //定义键盘缓冲区:
  struct ioqueue kbd_buf;


  //该二维数组的索引是扫描码，元素0代表未按下shift键时的输出字符，元素1代表按下shift键时的输出字符
  char keymap[][2] = &#123;
  /* 0x00 */	&#123;0,	0&#125;,		
  /* 0x01 */	&#123;esc,	esc&#125;,		
  /* 0x02 */	&#123;&#39;1&#39;,	&#39;!&#39;&#125;,		
  /* 0x03 */	&#123;&#39;2&#39;,	&#39;@&#39;&#125;,		
  /* 0x04 */	&#123;&#39;3&#39;,	&#39;#&#39;&#125;,		
  /* 0x05 */	&#123;&#39;4&#39;,	&#39;$&#39;&#125;,		
  /* 0x06 */	&#123;&#39;5&#39;,	&#39;%&#39;&#125;,		
  /* 0x07 */	&#123;&#39;6&#39;,	&#39;^&#39;&#125;,		
  /* 0x08 */	&#123;&#39;7&#39;,	&#39;&amp;&#39;&#125;,		
  /* 0x09 */	&#123;&#39;8&#39;,	&#39;*&#39;&#125;,		
  /* 0x0A */	&#123;&#39;9&#39;,	&#39;(&#39;&#125;,		
  /* 0x0B */	&#123;&#39;0&#39;,	&#39;)&#39;&#125;,		
  /* 0x0C */	&#123;&#39;-&#39;,	&#39;_&#39;&#125;,		
  /* 0x0D */	&#123;&#39;=&#39;,	&#39;+&#39;&#125;,		
  /* 0x0E */	&#123;backspace, backspace&#125;,	
  /* 0x0F */	&#123;tab,	tab&#125;,		
  /* 0x10 */	&#123;&#39;q&#39;,	&#39;Q&#39;&#125;,		
  /* 0x11 */	&#123;&#39;w&#39;,	&#39;W&#39;&#125;,		
  /* 0x12 */	&#123;&#39;e&#39;,	&#39;E&#39;&#125;,		
  /* 0x13 */	&#123;&#39;r&#39;,	&#39;R&#39;&#125;,		
  /* 0x14 */	&#123;&#39;t&#39;,	&#39;T&#39;&#125;,		
  /* 0x15 */	&#123;&#39;y&#39;,	&#39;Y&#39;&#125;,		
  /* 0x16 */	&#123;&#39;u&#39;,	&#39;U&#39;&#125;,		
  /* 0x17 */	&#123;&#39;i&#39;,	&#39;I&#39;&#125;,		
  /* 0x18 */	&#123;&#39;o&#39;,	&#39;O&#39;&#125;,		
  /* 0x19 */	&#123;&#39;p&#39;,	&#39;P&#39;&#125;,		
  /* 0x1A */	&#123;&#39;[&#39;,	&#39;&#123;&#39;&#125;,		
  /* 0x1B */	&#123;&#39;]&#39;,	&#39;&#125;&#39;&#125;,		
  /* 0x1C */	&#123;enter,  enter&#125;,
  /* 0x1D */	&#123;ctrl_l_char, ctrl_l_char&#125;,
  /* 0x1E */	&#123;&#39;a&#39;,	&#39;A&#39;&#125;,		
  /* 0x1F */	&#123;&#39;s&#39;,	&#39;S&#39;&#125;,		
  /* 0x20 */	&#123;&#39;d&#39;,	&#39;D&#39;&#125;,		
  /* 0x21 */	&#123;&#39;f&#39;,	&#39;F&#39;&#125;,		
  /* 0x22 */	&#123;&#39;g&#39;,	&#39;G&#39;&#125;,		
  /* 0x23 */	&#123;&#39;h&#39;,	&#39;H&#39;&#125;,		
  /* 0x24 */	&#123;&#39;j&#39;,	&#39;J&#39;&#125;,		
  /* 0x25 */	&#123;&#39;k&#39;,	&#39;K&#39;&#125;,		
  /* 0x26 */	&#123;&#39;l&#39;,	&#39;L&#39;&#125;,		
  /* 0x27 */	&#123;&#39;;&#39;,	&#39;:&#39;&#125;,		
  /* 0x28 */	&#123;&#39;\&#39;&#39;,	&#39;&quot;&#39;&#125;,		
  /* 0x29 */	&#123;&#39;`&#39;,	&#39;~&#39;&#125;,		
  /* 0x2A */	&#123;shift_l_char, shift_l_char&#125;,	
  /* 0x2B */	&#123;&#39;\\&#39;,	&#39;|&#39;&#125;,		
  /* 0x2C */	&#123;&#39;z&#39;,	&#39;Z&#39;&#125;,		
  /* 0x2D */	&#123;&#39;x&#39;,	&#39;X&#39;&#125;,		
  /* 0x2E */	&#123;&#39;c&#39;,	&#39;C&#39;&#125;,		
  /* 0x2F */	&#123;&#39;v&#39;,	&#39;V&#39;&#125;,		
  /* 0x30 */	&#123;&#39;b&#39;,	&#39;B&#39;&#125;,		
  /* 0x31 */	&#123;&#39;n&#39;,	&#39;N&#39;&#125;,		
  /* 0x32 */	&#123;&#39;m&#39;,	&#39;M&#39;&#125;,		
  /* 0x33 */	&#123;&#39;,&#39;,	&#39;&lt;&#39;&#125;,		
  /* 0x34 */	&#123;&#39;.&#39;,	&#39;&gt;&#39;&#125;,		
  /* 0x35 */	&#123;&#39;/&#39;,	&#39;?&#39;&#125;,
  /* 0x36	*/	&#123;shift_r_char, shift_r_char&#125;,	
  /* 0x37 */	&#123;&#39;*&#39;,	&#39;*&#39;&#125;,    	
  /* 0x38 */	&#123;alt_l_char, alt_l_char&#125;,
  /* 0x39 */	&#123;&#39; &#39;,	&#39; &#39;&#125;,		
  /* 0x3A */	&#123;caps_lock_char, caps_lock_char&#125;
  &#125;;


  static void intr_keyboard_handler(void)&#123;

      bool ctrl_down_last=ctrl_status;
      bool shift_down_last=shift_status;
      bool caps_lock_last=caps_lock_status;

      bool break_code;
      uint16_t scancode=inb(KBD_BUF_PORT);//必须读取缓冲区数据，否则8042不再继续响应键盘中断

      //打开拓展标志，并返回，（说明要接受的扫描码不止1字节，有两字节）
      if(scancode == 0xe0)&#123;
          ext_scancode=true;
          return;
      &#125;

      if(ext_scancode)&#123;
          scancode=(0xe000|scancode);
          ext_scancode=false;
      &#125;


      //true则代表是断码，否则是通码
      break_code=((scancode&amp;0x0080)!=0);

      if(break_code)&#123;
          uint16_t make_code=(scancode&amp;=0xff7f);

          //改变状态
          if(make_code==ctrl_l_make||make_code==ctrl_r_make)&#123;
              ctrl_status=false;
          &#125;else if(make_code == shift_l_make || make_code==shift_r_make)&#123;
              shift_status=false;
          &#125;else if(make_code == alt_l_make || make_code ==alt_r_make)&#123;
              alt_status=false;
          &#125;

          return;
      &#125;else if((scancode&gt;0x00 &amp;&amp; scancode&lt;0x3b)||(scancode == alt_r_make)||(scancode ==ctrl_r_make))&#123;
          
          //shift用于判断keymap到底是要输出元素0还是元素1
          bool shift=false;


          //区分双字符键和单子符键，capslk和shift对双字符键和单字符键作用不一样
          if((scancode &lt; 0x0e) || (scancode == 0x29) || (scancode == 0x1a) || \
          (scancode == 0x1b) || (scancode == 0x2b) || (scancode == 0x27) || \
          (scancode == 0x28) || (scancode == 0x33) || (scancode == 0x34) || \
          (scancode == 0x35))&#123;

              if(shift_down_last)&#123;
                  shift = true;
              &#125;

          &#125;else&#123;  //默认是字符键
              if(shift_down_last &amp;&amp; caps_lock_last)&#123;
                  shift = false; //效果确实是这样子的 我试了一下
              &#125;else if(shift_down_last || caps_lock_last)&#123;
                  shift = true; //其中任意一个都是大写的作用
              &#125;else&#123;
                  shift = false;
              &#125; 
          &#125;


          //忽略高8位，也就是0xe0的影响
          uint8_t index=(scancode&amp;=0x00ff);

          char cur_char = keymap[index][shift];

          if(cur_char)&#123;
              if(!ioq_full(&amp;kbd_buf))&#123;
  //               put_char(cur_char);
                  ioq_putchar(&amp;kbd_buf,cur_char);
              &#125;
              return;
          &#125;

          if(scancode == ctrl_l_make || scancode == ctrl_r_make)&#123;
              ctrl_status = true;
          &#125;  	
          else if(scancode == shift_l_make || scancode == shift_r_make)&#123;
              shift_status = true;
          &#125;
          else if(scancode == alt_l_make || scancode == alt_r_make)&#123;
              alt_status = true;
          &#125;
          else if(scancode == caps_lock_make)&#123;
              caps_lock_status = !caps_lock_status;
          &#125;
          
      &#125;else&#123;
          put_str(&quot;unknown key\n&quot;);
      &#125;

  &#125;

  void keyboard_init()&#123;
      put_str(&quot;keyboard init start\n&quot;);
      ioqueue_init(&amp;kbd_buf);
      register_handler(0x21,intr_keyboard_handler);
      put_str(&quot;kerboard init done\n&quot;);
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;interrupt.c（修改）</p>
<pre><code>  //打开主片上的IR0,接受时钟中断和键盘中断
  outb(PIC_M_DATA, 0xfc);
  outb(PIC_S_DATA, 0xff);
</code></pre>
</li>
</ul>
<p>（该main.c用两个线程AB充当消费者，键盘键入充当生产者）</p>
<ul>
<li><p>kernel&#x2F;main.c</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;
  #include &quot;debug.h&quot;
  #include &quot;memory.h&quot;
  #include &quot;thread.h&quot;
  #include &quot;console.h&quot;
  #include &quot;interrupt.h&quot;
  #include &quot;ioqueue.h&quot;
  #include &quot;keyboard.h&quot;

  void k_thread_a(void*);
  void k_thread_b(void*);

  int main(void) &#123;
  put_str(&quot;I am kernel\n&quot;);
  init_all();


  thread_start(&quot;k_thread_a&quot;,31,k_thread_a,&quot; A_&quot;);
  thread_start(&quot;k_thread_b&quot;,31,k_thread_b,&quot; B_&quot;);

  intr_enable();
  while(1);
  // while(1)&#123;
  //    console_put_str(&quot;Main &quot;);
  // &#125;;
  return 0;
  &#125;


  //在线程中运行的函数
  void k_thread_a(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      enum intr_status old_status =intr_disable();
      if(!ioq_empty(&amp;kbd_buf))&#123;
          console_put_str(para);
          char byte=ioq_getchar(&amp;kbd_buf);
          console_put_char(byte);
      &#125;
      intr_set_status(old_status);
  &#125;
  &#125;

  void k_thread_b(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      enum intr_status old_status =intr_disable();
      if(!ioq_empty(&amp;kbd_buf))&#123;
          console_put_str(para);
          char byte=ioq_getchar(&amp;kbd_buf);
          console_put_char(byte);
      &#125;
      intr_set_status(old_status);
  &#125;
  &#125;
</code></pre>
</li>
<li><p>makefile</p>
<pre><code>  BUILD_DIR = ./build
  ENTRY_POINT = 0xc0001500
  AS = nasm
  CC = gcc
  LD = ld
  LIB = -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ -I thread/ 
  ASFLAGS = -f elf

  CFLAGS = -Wall -m32 -fno-stack-protector $(LIB) -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes
  # -fno-stack-protector 闭栈保护的编译选项，栈保护作用是禁止编译器在函数的栈帧中插入栈保护符号，以防止栈溢出攻击。
  # -fno-builtin 告诉编译器不要采用内部函数，因为我们以后会自定义与内部函数同名的函数
  # -Wall 启动所有警告
  # -W 启动常见警告
  # -Wstrict-prototypes  要求函数声明中必须有参数类型，否则警告
  # -Wmissing-prototypes 要求函数必须声明，否则警告

  LDFLAGS =  -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)/kernel.map
  # -Map $(BUILD_DIR)/kernel.map  输出文件build/kernel.map。用于记录kernel符号地址

  OBJS = $(BUILD_DIR)/main.o $(BUILD_DIR)/init.o $(BUILD_DIR)/interrupt.o \
      $(BUILD_DIR)/timer.o $(BUILD_DIR)/kernel.o $(BUILD_DIR)/print.o \
      $(BUILD_DIR)/debug.o $(BUILD_DIR)/string.o $(BUILD_DIR)/memory.o \
      $(BUILD_DIR)/bitmap.o $(BUILD_DIR)/thread.o $(BUILD_DIR)/list.o \
      $(BUILD_DIR)/switch.o $(BUILD_DIR)/sync.o $(BUILD_DIR)/console.o \
      $(BUILD_DIR)/keyboard.o $(BUILD_DIR)/ioqueue.o
  # 定义目标文件名集合，用于ld时依赖文件项


  ##############     c代码编译     			###############
  $(BUILD_DIR)/main.o: kernel/main.c lib/kernel/print.h \
          lib/stdint.h kernel/init.h lib/string.h kernel/memory.h \
          thread/thread.h kernel/interrupt.h device/console.h \
          device/keyboard.h device/ioqueue.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/init.o: kernel/init.c kernel/init.h lib/kernel/print.h \
          lib/stdint.h kernel/interrupt.h device/timer.h kernel/memory.h \
          thread/thread.h device/console.h device/keyboard.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/interrupt.o: kernel/interrupt.c kernel/interrupt.h \
          lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/timer.o: device/timer.c device/timer.h lib/kernel/io.h lib/kernel/print.h \
          kernel/interrupt.h thread/thread.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/debug.o: kernel/debug.c kernel/debug.h \
          lib/kernel/print.h lib/stdint.h kernel/interrupt.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/string.o: lib/string.c lib/string.h \
          kernel/debug.h kernel/global.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/memory.o: kernel/memory.c kernel/memory.h \
          lib/stdint.h lib/kernel/bitmap.h kernel/debug.h lib/string.h \
          lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/bitmap.o: lib/kernel/bitmap.c lib/kernel/bitmap.h \
          lib/string.h kernel/interrupt.h lib/kernel/print.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/thread.o: thread/thread.c thread/thread.h \
          lib/stdint.h lib/string.h kernel/global.h kernel/memory.h \
          kernel/debug.h kernel/interrupt.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/list.o: lib/kernel/list.c lib/kernel/list.h \
          kernel/interrupt.h lib/stdint.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/sync.o: thread/sync.c thread/sync.h \
          lib/stdint.h thread/thread.h kernel/debug.h kernel/interrupt.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/console.o: device/console.c device/console.h \
          lib/kernel/print.h thread/sync.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/keyboard.o: device/keyboard.c device/keyboard.h \
          lib/kernel/print.h lib/kernel/io.h kernel/interrupt.h \
          kernel/global.h lib/stdint.h device/ioqueue.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/ioqueue.o: device/ioqueue.c device/ioqueue.h \
          kernel/interrupt.h kernel/global.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  ##############     c代码编译     			###############


  ##############    汇编代码编译    ###############
  $(BUILD_DIR)/kernel.o: kernel/kernel.S
      $(AS) $(ASFLAGS) $&lt; -o $@

  $(BUILD_DIR)/print.o: lib/kernel/print.S
      $(AS) $(ASFLAGS) $&lt; -o $@

  $(BUILD_DIR)/switch.o: thread/switch.S
      $(AS) $(ASFLAGS) $&lt; -o $@
  ##############    汇编代码编译    ###############


  ##############    链接所有目标文件    #############
  $(BUILD_DIR)/kernel.bin: $(OBJS)
      $(LD) $(LDFLAGS) $^ -o $@
  ##############    链接所有目标文件    #############


  ################  伪目标 ###############################
  .PHONY : mk_dir hd clean build all

  mk_dir:
      if [ ! -d $(BUILD_DIR) ]; then mkdir $(BUILD_DIR); fi

  hd:
      dd if=$(BUILD_DIR)/kernel.bin \
          of=/home/sparkle2/bochs/hd60M.img \
          bs=512 count=200 seek=9 conv=notrunc

  clean:
      cd $(BUILD_DIR) &amp;&amp; rm -f  ./*

  build: $(BUILD_DIR)/kernel.bin

  all: mk_dir build hd
  ################  伪目标 ###############################
</code></pre>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/29/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/29/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（九）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-29 11:02:44" itemprop="dateCreated datePublished" datetime="2023-11-29T11:02:44+08:00">2023-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-30 11:45:32" itemprop="dateModified" datetime="2023-11-30T11:45:32+08:00">2023-11-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><ul>
<li><p>进程和线程的区别：</p>
<p>  线程程是具有能动性、执行力、独立的代码块；进程就是线程的集合+资源。</p>
<p>  每个进程都有自己独立的内存空间，线程没有自己独立的内存空间，一个进程里的所有线程共享该进程内所有内存空间</p>
<p>  线程才是最基本的调度单位（进程的调度比线程更高一级），也可以称为是执行流</p>
</li>
<li><p>进程和线程的状态图</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/img1.png" alt="img"></p>
<p>  <strong>PS：图中写的是进程的状态图，但我们知道线程才是最基本的调度单位，所以我认为这也代表线程的状态图</strong></p>
</li>
<li><p>进程的身份证————PCB</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/img2.png" alt="img"></p>
<p>  左图是PCB的结构，右图是进程表（也就是PCB的集合）。PCB让我们了解一个进程的各个状态，并给出了上下文环境（PCB的结构并非是固定的，取决于程操作系统的复杂程度，一般一个PCB的大小相当于一个自然页4KB）。进程表将PCB集合存放在一个位置，这样操作系统就会在一个统一的地方查询PCB方便调度</p>
</li>
<li><p>实现线程的两种方式————内核或用户进程</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/img3.png" alt="img"></p>
<p>  用户进程的意思是，操作系统不支持线程调度（操作系统根本不知道这回事），由用户程序自己实现线程调度（线程表在用户空间）。</p>
<p>  内核进程则是操作系统本身就支持线程调度，由操作系统来负责所有进程以及线程的调用（线程表放在内核）</p>
<p>  可以说内核进程才是真正发挥出了线程的作用，我们要实现的也是内核进程</p>
</li>
</ul>
<h1 id="在内核空间实现线程"><a href="#在内核空间实现线程" class="headerlink" title="在内核空间实现线程"></a>在内核空间实现线程</h1><p>在内核实现线程的关键是PCB的构建，我们引入了三个新的结构体来构建PCB：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/img4.png" alt="img"></p>
<p>我们打算构建的PCB结构如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/img5.png" alt="img"></p>
<p>函数thread_start实现创建并运行一个线程，函数之间的逻辑关系如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/img6.png" alt="img"></p>
<p>代码如下：</p>
<ul>
<li><p>thread&#x2F;thread.h</p>
<pre><code>  #ifndef __THREAD_THREAD_H__
  #define __THREAD_THREAD_H__

  #include &quot;stdint.h&quot;

  //注意：这是定义一个函数类型 thread_func ,而不是一个函数指针类型
  //定义函数指针类型格式是：typedef void (*thread_func)(void*);
  typedef void thread_func(void*);

  enum task_status&#123;
      TASK_RUNNING,
      TASK_READY,
      TASK_BLOCKED,
      TASK_WAITING,
      TASK_HANGING,
      TASK_DIED,
  &#125;;

  //中断栈定义，用于线程中断时保护上下文环境
  struct intr_stack&#123;
      uint32_t vec_no;
      uint32_t edi;
      uint32_t esi;
      uint32_t ebp;
      uint32_t esp_dummy;

      uint32_t ebx;
      uint32_t edx;
      uint32_t ecx;
      uint32_t eax;

      uint32_t gs;
      uint32_t fs;
      uint32_t es;
      uint32_t ds;

      //CPU由低特权级进入高特权级时压入
      uint32_t err_code;

      //定义了一个函数指针
      void* (*eip)(void);
      uint32_t cs;
      uint32_t eflags;
      void* esp;
      uint32_t ss;
  &#125;;


  //线程栈
  //1、第一次运行时，eip用于存储线程中待执行的函数
  //2、在switch_to（任务切换）时，eip用于保存新任务的返回地址 
  struct thread_stack&#123;

      //ABI规定被调用函数不允许破坏ebp、ebx、edi、esi、esp，所以我们要将他们保护好（esp由调用约定保护）
      //但其实我也不知道这边的真实用途？？？
      uint32_t ebp;
      uint32_t ebx;
      uint32_t edi;
      uint32_t esi;

      void (*eip)(thread_func* func,void* func_arg);//指向线程待执行函数
      
      void (*unused_retaddr); //占位符，原本该地方放置的应该是线程待执行函数的返回地址
      thread_func* function;  //function是指向thread_func类型函数的指针
      void* func_arg;

  &#125;;


  //PCB结构
  struct task_struct&#123;
      uint32_t* self_kstack; //PCB结构中包含了线程的内核栈，该成员变量相当于栈顶指针
      enum task_status status;
      uint8_t priority;
      char name[16];
      uint32_t stack_magic; 
  &#125;;


  void thread_create(struct task_struct* pthread, thread_func function,void* func_arg);
  void init_thread(struct task_struct* pthread,char* name,int prio);
  struct task_struct* thread_start(char* name,int prio,thread_func function,void* func_arg);

  #endif
</code></pre>
</li>
<li><p>thread&#x2F;thread.c</p>
<pre><code>  #include &quot;thread.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;string.h&quot;
  #include &quot;global.h&quot;
  #include &quot;memory.h&quot;

  #define PG_SIZE 4096


  //由kernel_thread去执行function(func_arg)
  static void kernel_thread(thread_func* function,void* func_arg)&#123;
      function(func_arg);
  &#125;

  //初始化线程栈
  void thread_create(struct task_struct* pthread, thread_func function,void* func_arg)&#123;
      //预留中断栈空间和线程栈空间

      pthread-&gt;self_kstack -= sizeof(struct intr_stack);
      pthread-&gt;self_kstack -= sizeof(struct thread_stack);
      
      struct thread_stack* kthread_stack=(struct thread_stack*)pthread-&gt;self_kstack;

      kthread_stack-&gt;eip=kernel_thread;
      kthread_stack-&gt;function=function;
      kthread_stack-&gt;func_arg=func_arg;
      kthread_stack-&gt;ebp=kthread_stack-&gt;ebx=kthread_stack-&gt;esi=kthread_stack-&gt;edi=0;

  &#125;


  //初始化PCB
  void init_thread(struct task_struct* pthread,char* name,int prio)&#123;
      memset(pthread,0,sizeof(*pthread));
      strcpy(pthread-&gt;name,name);
      pthread-&gt;status=TASK_RUNNING;
      pthread-&gt;priority=prio;
      pthread-&gt;self_kstack=(uint32_t*)((uint32_t)pthread+PG_SIZE);
      pthread-&gt;stack_magic=0x19666666; //自定义的魔数

  &#125;

  //创建一个优先级为prio的线程，线程名为name，线程所执行的函数是function(func_arg)
  struct task_struct* thread_start(char* name,int prio,thread_func function,void* func_arg)&#123;
      struct task_struct* thread=get_kernel_pages(1);
      init_thread(thread,name,prio);
      thread_create(thread,function,func_arg);

      asm volatile(&quot;movl %0,%%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret&quot;::&quot;g&quot;(thread-&gt;self_kstack):&quot;memory&quot;);

      return thread;
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;main.c</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;
  #include &quot;debug.h&quot;
  #include &quot;memory.h&quot;
  #include &quot;thread.h&quot;

  void k_thread_a(void* arg);

  int main(void) &#123;
  put_str(&quot;I am kernel\n&quot;);
  init_all();


  thread_start(&quot;k_thread_a&quot;,31,k_thread_a,&quot;argA &quot;);


  while(1);
  return 0;
  &#125;


  //在线程中运行的函数
  void k_thread_a(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      put_str(para);
  &#125;
  &#125;
</code></pre>
</li>
</ul>
<h1 id="多线程调度"><a href="#多线程调度" class="headerlink" title="多线程调度"></a>多线程调度</h1><p>要实现多线程调度，我们的PCB就不能像之前那么简单了，之间的PCB只是一个简单的示范。我们现在要给PCB增加一些新的成员，相应的一些线程相关函数也要有对应的更改。</p>
<p>想要实现多线程调度的关键是维护两个队列，一个是进程就绪队列，还有一个是所有进程队列(包括被阻塞的进程)。而如果我们把整个PCB作为链表的节点来说实在是太麻烦了，不够灵活（整个链表的遍历负担也大）。所以我们需要一个轻量级的链表。</p>
<p>我们在PCB中引入新的成员：<code>struct list_elem general_tag;  //存放在一般队列中的节点</code> 和<code>struct list_elem all_list_tag; //存在在所有线程队列的节点</code>，这样的节点元素只有前指针和后指针两个元素8字节大小，维护两个这样的tag链表代替PCB链表。当然我们必须能够实现对应tag和PCB指针之间的相互转换才能真正实现该队列。        </p>
<p>新的PCB结构如以下代码：</p>
<ul>
<li><p>thread&#x2F;thread.h(部分代码)</p>
<pre><code>  //PCB结构
  struct task_struct&#123;
      uint32_t* self_kstack; //PCB结构中包含了线程的内核栈，该成员变量相当于栈顶指针
      enum task_status status;
      char name[16];
      uint8_t priority; //把优先级设置位一次执行时间片的长短，优先级越高则一次时间片越长
      uint8_t ticks;   //时间片，记录再执行几次时钟中断就将它换下
      uint32_t elapsed_ticks;  //该线程在CPU执行的总时钟中断数
      struct list_elem general_tag;  //存放在一般队列中的节点
      struct list_elem all_list_tag; //存在在所有线程队列的节点
      uint32_t* pgdir;         //进程自己页表的虚拟地址（线程没有自己的页表则该值为0）
      uint32_t stack_magic;   //该数字位于PCB结构的最高位，也就是说一旦PCB的栈顶冲破了PCB信息结构，
                              //stack_magic会最先被破坏，因此用该位判断PCB的内核栈是否越界
  &#125;;
</code></pre>
</li>
<li><p>修改后的thread&#x2F;thread.c代码</p>
<pre><code>  #include &quot;thread.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;string.h&quot;
  #include &quot;global.h&quot;
  #include &quot;memory.h&quot;
  #include &quot;interrupt.h&quot;

  #define PG_SIZE 4096


  struct task_struct* main_thread;  //主线程PCB
  struct list thread_ready_list;     //就绪队列
  struct list thread_all_list;      //所有线程队列
  static struct list_elem* thread_tag;  //用于 tag转化为PCB指针 时的中介

  extern void switch_to(struct task_struct* cur,struct task_struct* next);


  //返回当前线程的PCB指针
  //当前esp存取的是当前线程的栈顶指针，而线程的栈全在PCB中，所以取当前栈顶指针的前20位即是PCB其实地址
  struct task_struct* running_thread()&#123;
      uint32_t esp;
      asm (&quot;mov %%esp,%0&quot;:&quot;=g&quot;(esp));
      return (struct task_struct*)(esp &amp; 0xfffff000);
  &#125;

  //由kernel_thread去执行function(func_arg)
  static void kernel_thread(thread_func* function,void* func_arg)&#123;
      intr_enable();//开启中断，避免线程独占CPU
      function(func_arg);
  &#125;

  //初始化线程栈
  void thread_create(struct task_struct* pthread, thread_func function,void* func_arg)&#123;
      //预留中断栈空间和线程栈空间

      pthread-&gt;self_kstack -= sizeof(struct intr_stack);
      pthread-&gt;self_kstack -= sizeof(struct thread_stack);
      
      struct thread_stack* kthread_stack=(struct thread_stack*)pthread-&gt;self_kstack;

      kthread_stack-&gt;eip=kernel_thread;
      kthread_stack-&gt;function=function;
      kthread_stack-&gt;func_arg=func_arg;
      kthread_stack-&gt;ebp=kthread_stack-&gt;ebx=kthread_stack-&gt;esi=kthread_stack-&gt;edi=0;

  &#125;


  //初始化PCB
  void init_thread(struct task_struct* pthread,char* name,int prio)&#123;
      memset(pthread,0,sizeof(*pthread));
      strcpy(pthread-&gt;name,name);

      if(pthread==main_thread)&#123;
          pthread-&gt;status=TASK_RUNNING;
      &#125;else&#123;
          pthread-&gt;status=TASK_READY;
      &#125;
      
      pthread-&gt;self_kstack=(uint32_t*)((uint32_t)pthread+PG_SIZE);
      pthread-&gt;priority=prio;
      pthread-&gt;ticks=prio;
      pthread-&gt;elapsed_ticks=0;
      pthread-&gt;pgdir=NULL;//线程没有自己的地址空间
      pthread-&gt;stack_magic=0x19870916; //自定义的魔数，这个值一旦被不一样了，就证明栈顶越界了

  &#125;

  //创建一个优先级为prio的线程，线程名为name，线程所执行的函数是function(func_arg)
  struct task_struct* thread_start(char* name,int prio,thread_func function,void* func_arg)&#123;
      struct task_struct* thread=get_kernel_pages(1);
      init_thread(thread,name,prio);
      thread_create(thread,function,func_arg);


      //确保线程之前不在队列里
      ASSERT(!elem_find(&amp;thread_ready_list,&amp;thread-&gt;general_tag));     
      list_append(&amp;thread_ready_list,&amp;thread-&gt;general_tag);
      
      ASSERT(!elem_find(&amp;thread_all_list,&amp;thread-&gt;all_list_tag));
      list_append(&amp;thread_all_list,&amp;thread-&gt;all_list_tag);


      return thread;
  &#125;


  //完善kernel中的main的主线程
  //我怎么确定主线程在0xc009e00？？？
  static void make_main_thread(void)&#123;
      main_thread=running_thread();

      init_thread(main_thread,&quot;main&quot;,31);

      ASSERT(!elem_find(&amp;thread_all_list,&amp;main_thread-&gt;all_list_tag));
      list_append(&amp;thread_all_list,&amp;main_thread-&gt;all_list_tag);
  &#125;
</code></pre>
</li>
</ul>
<p>接下来我们要实现一些新的函数，借助新函数来完成进程调度和上下文切换，新函数之间的逻辑关系如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B9%9D%EF%BC%89/img7.png" alt="img"></p>
<p>代码如下：</p>
<ul>
<li><p>kernel&#x2F;interrupt.c </p>
<pre><code>  //为专门的中断号注册专门的中断函数
  void register_handler(uint8_t vector_no,intr_handler function)&#123;
      idt_table[vector_no]=function;
  &#125;
</code></pre>
</li>
<li><p>device&#x2F;timer.c</p>
<pre><code>  static void intr_timer_handler(void)&#123;
      struct task_struct* cur_thread =running_thread();

      //检测栈是否溢出
      ASSERT(cur_thread-&gt;stack_magic==0x19870916);


      cur_thread-&gt;elapsed_ticks++;
      ticks++;

      if(cur_thread-&gt;ticks == 0)&#123;
          schedule();
      &#125;else&#123;
          cur_thread-&gt;ticks--;
      &#125;

  &#125;
</code></pre>
<p>  <strong>PS:记得在时钟初始化上调用注册函数注册时钟中断的专门处理函数</strong></p>
</li>
<li><p>thread&#x2F;switch.S</p>
<pre><code>  [bits 32]
  section .text
  global switch_to
  switch_to:
      ;此处是返回地址
      push esi
      push edi
      push ebx
      push ebp

      mov eax,[esp+20]    ;得到栈中参数cur
      mov [eax],esp       ;保存栈顶指针esp到self_kstack;

  ;-------------以上是备份环境，下面是恢复下一个线程的环境------------

      mov eax,[esp+24]    ;得到栈中参数next
      mov esp,[eax]       ;pcb的第一个成员是self_kstack

      pop ebp
      pop ebx
      pop edi
      pop esi
      
      ret   
</code></pre>
</li>
<li><p>thread&#x2F;thread.c    </p>
<pre><code>  void schedule()&#123;
      ASSERT(intr_get_status()==INTR_OFF);

      struct task_struct* cur =running_thread();
      if(cur-&gt;status==TASK_RUNNING)&#123;
          //时间片时间到了,将cpu上的线程重置时间片后放回就绪队列尾部
          ASSERT(!elem_find(&amp;thread_ready_list,&amp;cur-&gt;general_tag));
          list_append(&amp;thread_ready_list,&amp;cur-&gt;general_tag);
          cur-&gt;ticks=cur-&gt;priority;
          cur-&gt;status=TASK_READY;
      &#125;else&#123;
          //如果是被阻塞的话，就不同特殊处理
          //因为被阻塞线程本身就不在就绪队列中
          //只需要调度新的线程进来就行了
      &#125;

      ASSERT(!list_empty(&amp;thread_ready_list));
      
      //将thread_ready_list队列中第一个就绪栈弹出，准备将其调度上CPU
      thread_tag=NULL;
      thread_tag=list_pop(&amp;thread_ready_list);
      struct task_struct* next=elem2entry(struct task_struct,general_tag,thread_tag);
      next-&gt;status=TASK_RUNNING;
      switch_to(cur,next);
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;main.c</p>
<pre><code>  #include &quot;print.h&quot;
  #include &quot;init.h&quot;
  #include &quot;debug.h&quot;
  #include &quot;memory.h&quot;
  #include &quot;thread.h&quot;

  void k_thread_a(void*);
  void k_thread_b(void*);

  int main(void) &#123;
  put_str(&quot;I am kernel\n&quot;);
  init_all();


  thread_start(&quot;k_thread_a&quot;,31,k_thread_a,&quot;argA &quot;);
  thread_start(&quot;k_thread_b&quot;,8,k_thread_b,&quot;argB &quot;);

  intr_enable();
  while(1)&#123;
      put_str(&quot;Main &quot;);
  &#125;;
  
  return 0;
  &#125;


  //在线程中运行的函数
  void k_thread_a(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      put_str(para);
  &#125;
  &#125;

  void k_thread_b(void* arg)&#123;
  //被调用的函数知道自己需要什么类型的参数，自己转换再用
  char* para=arg;

  while(1)&#123;
      put_str(para);
  &#125;
  &#125;
</code></pre>
</li>
<li><p>makefile</p>
<pre><code>  BUILD_DIR = ./build
  ENTRY_POINT = 0xc0001500
  AS = nasm
  CC = gcc
  LD = ld
  LIB = -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ -I thread/ 
  ASFLAGS = -f elf

  CFLAGS = -Wall -m32 -fno-stack-protector $(LIB) -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes
  # -fno-stack-protector 闭栈保护的编译选项，栈保护作用是禁止编译器在函数的栈帧中插入栈保护符号，以防止栈溢出攻击。
  # -fno-builtin 告诉编译器不要采用内部函数，因为我们以后会自定义与内部函数同名的函数
  # -Wall 启动所有警告
  # -W 启动常见警告
  # -Wstrict-prototypes  要求函数声明中必须有参数类型，否则警告
  # -Wmissing-prototypes 要求函数必须声明，否则警告

  LDFLAGS =  -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)/kernel.map
  # -Map $(BUILD_DIR)/kernel.map  输出文件build/kernel.map。用于记录kernel符号地址

  OBJS = $(BUILD_DIR)/main.o $(BUILD_DIR)/init.o $(BUILD_DIR)/interrupt.o \
      $(BUILD_DIR)/timer.o $(BUILD_DIR)/kernel.o $(BUILD_DIR)/print.o \
      $(BUILD_DIR)/debug.o $(BUILD_DIR)/string.o $(BUILD_DIR)/memory.o \
      $(BUILD_DIR)/bitmap.o $(BUILD_DIR)/thread.o $(BUILD_DIR)/list.o \
      $(BUILD_DIR)/switch.o
  # 定义目标文件名集合，用于ld时依赖文件项


  ##############     c代码编译     			###############
  $(BUILD_DIR)/main.o: kernel/main.c lib/kernel/print.h \
          lib/stdint.h kernel/init.h lib/string.h kernel/memory.h \
          thread/thread.h kernel/interrupt.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/init.o: kernel/init.c kernel/init.h lib/kernel/print.h \
          lib/stdint.h kernel/interrupt.h device/timer.h kernel/memory.h \
          thread/thread.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/interrupt.o: kernel/interrupt.c kernel/interrupt.h \
          lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/timer.o: device/timer.c device/timer.h lib/kernel/io.h lib/kernel/print.h \
          kernel/interrupt.h thread/thread.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/debug.o: kernel/debug.c kernel/debug.h \
          lib/kernel/print.h lib/stdint.h kernel/interrupt.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/string.o: lib/string.c lib/string.h \
          kernel/debug.h kernel/global.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/memory.o: kernel/memory.c kernel/memory.h \
          lib/stdint.h lib/kernel/bitmap.h kernel/debug.h lib/string.h \
          lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/bitmap.o: lib/kernel/bitmap.c lib/kernel/bitmap.h \
          lib/string.h kernel/interrupt.h lib/kernel/print.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/thread.o: thread/thread.c thread/thread.h \
          lib/stdint.h lib/string.h kernel/global.h kernel/memory.h \
          kernel/debug.h kernel/interrupt.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/list.o: lib/kernel/list.c lib/kernel/list.h \
          kernel/interrupt.h lib/stdint.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@

  ##############     c代码编译     			###############


  ##############    汇编代码编译    ###############
  $(BUILD_DIR)/kernel.o: kernel/kernel.S
      $(AS) $(ASFLAGS) $&lt; -o $@

  $(BUILD_DIR)/print.o: lib/kernel/print.S
      $(AS) $(ASFLAGS) $&lt; -o $@

  $(BUILD_DIR)/switch.o: thread/switch.S
      $(AS) $(ASFLAGS) $&lt; -o $@
  ##############    汇编代码编译    ###############


  ##############    链接所有目标文件    #############
  $(BUILD_DIR)/kernel.bin: $(OBJS)
      $(LD) $(LDFLAGS) $^ -o $@
  ##############    链接所有目标文件    #############


  ################  伪目标 ###############################
  .PHONY : mk_dir hd clean build all

  mk_dir:
      if [ ! -d $(BUILD_DIR) ]; then mkdir $(BUILD_DIR); fi

  hd:
      dd if=$(BUILD_DIR)/kernel.bin \
          of=/home/sparkle2/bochs/hd60M.img \
          bs=512 count=200 seek=9 conv=notrunc

  clean:
      cd $(BUILD_DIR) &amp;&amp; rm -f  ./*

  build: $(BUILD_DIR)/kernel.bin

  all: mk_dir build hd
  ################  伪目标 ###############################
</code></pre>
</li>
</ul>
<p>一定要从main函数开始，跟着流程走一遍，才能真正理解线程之间的压栈出栈和跳转。</p>
<p><strong>注意！PCB结构中的intr_stack和thread_stack只是规定了入栈出栈的顺序，二者的位置则是不固定的，并不是说二者的位置就一定固定在栈顶</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/25/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/25/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/" class="post-title-link" itemprop="url">自制简易操作系统（八）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-25 17:43:19" itemprop="dateCreated datePublished" datetime="2023-11-25T17:43:19+08:00">2023-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-28 17:20:12" itemprop="dateModified" datetime="2023-11-28T17:20:12+08:00">2023-11-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="断言assert"><a href="#断言assert" class="headerlink" title="断言assert"></a>断言assert</h1><p>断言即断定的说，是一种用来调试的手段。比如我在程序的某个地方这断定的说flag&#x3D;1（ASSERT(flag&#x3D;&#x3D;1)）,如果条件成立则无事发生，如果不成立则触发断言屏幕悬停并在屏幕上打印错误信息。断言还分为系统断言和用户断言，我们本节要通过宏定义实现系统断言。</p>
<p>断言触发时我们希望能停止中断（避免CPU中断切换任务），所以首先我们需要能灵活打开关闭中断(eflags里的’IF’位)的函数。于是我们在interrupt.c里添加了四个工具函数以实现灵活控制中断。</p>
<p>新增代码如下：</p>
<ul>
<li><p>kernel&#x2F;interrupt.h：</p>
<pre><code>  #ifndef __KERNEL_INTERRUPT_H__
  #define __KERNEL_INTERRUPT_H__

  typedef void* intr_handler;

  void idt_init(void);

  enum intr_status&#123;
      INTR_OFF,
      INTR_ON
  &#125;;

  enum intr_status intr_get_status(void);
  enum intr_status intr_set_status(enum intr_status);
  enum intr_status intr_enable(void);
  enum intr_status intr_disable(void);

  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;interrupt.c:</p>
<pre><code>  #define EFLAGS_IF 0x00000200

  //用内联汇编实现查询eflags状态
  #define GET_EFLAGS(EFLAG_VAR) asm volatile(&quot;pushfl; popl %0&quot;: &quot;=g&quot;(EFLAG_VAR))

  //开中断并返回当前状态
  enum intr_status intr_enable()
  &#123;
      if(intr_get_status() != INTR_ON)
      &#123;
          asm volatile(&quot;sti&quot;);
          return INTR_OFF;
      &#125;
      return INTR_ON;
  &#125;

  //关中断并返回当前状态
  enum intr_status intr_disable()
  &#123;
      if(intr_get_status() != INTR_OFF)
      &#123;
          asm volatile(&quot;cli&quot;);
          return INTR_ON;
      &#125;
      return INTR_OFF;
  &#125;

  //设置中断状态
  enum intr_status intr_set_status(enum intr_status status)
  &#123;
      return (status &amp; INTR_ON) ? intr_enable() : intr_disable();
  &#125;

  //获取中断状态
  enum intr_status intr_get_status()
  &#123;
      uint32_t eflags = 0;
      GET_EFLAGS(eflags);
      return (eflags &amp; EFLAGS_IF) ? INTR_ON : INTR_OFF; 
  &#125;
</code></pre>
</li>
</ul>
<p>接下来我们要用宏定义实现断言:</p>
<ul>
<li><p>kernel&#x2F;debug.h:</p>
<pre><code>  #ifndef __KERNEL_DEBUG_H__
  #define __KERNEL_DEBUG_H__

  void panic_spin(char* filename,int line,const char* func,const char*condition);

  #define PANIC(...) panic_spin(__FILE__ , __LINE__ , __func__, __VA_ARGS__)
  //(...)是可变宏参数, __VA_ARGS__预处理器专用标识符，他就相当于是可变宏参数的形参
  //__FILE__ , __LINE__ , __func__则是由系统自动提供的，分别代表文件名、行号、函数名


  //如果通过编译器定义了NDEBUG(`gcc-DNDEBUG`)就把断言清空（避免影响系统运作速度）
  //否则就在有断言的地方进行条件判断，条件为假则触发断言函数
  #ifdef NDEBUG 
  #define ASSERT(CONDITION) ((void)0)
  #else
  #define ASSERT(CONDITION) \
  if(CONDITION)&#123;&#125;        \
  else&#123; PANIC(#CONDITION); &#125;
  //#CONDITION是将CONDITION转化为字符串传入宏函数PANIC

  #endif
  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;debug.c：</p>
<pre><code>  #include&quot;debug.h&quot;
  #include&quot;../lib/kernel/print.h&quot;
  #include&quot;interrupt.h&quot;

  void panic_spin(char* filename,int line,const char* func,const char*condition)&#123;

      intr_disable();                 //关闭中断，防止cpu处理其他进程被调换

      //打印错误信息
      put_str(&quot;\n\n\n\\**********ERROR\\**********\\\n&quot;);
      put_str(&quot;Filename: &quot;);put_str(filename);put_char(&#39;\n&#39;);
      put_str(&quot;Line: &quot;); put_int(line); put_char(&#39;\n&#39;);
      put_str(&quot;Func: &quot;);put_str((char*)func);put_char(&#39;\n&#39;);
      put_str(&quot;Condition: &quot;);put_str((char*)condition);put_char(&#39;\n&#39;);
      put_str(&quot;\\**********ERROR\\**********\\\n&quot;);

      while(1);
  &#125;
</code></pre>
</li>
</ul>
<h1 id="make和makefile"><a href="#make和makefile" class="headerlink" title="make和makefile"></a>make和makefile</h1><p>之前我们都是把每一个独立的.c&#x2F;.S文件编译成.o文件，然后再一起链接。手动输入命令太过麻烦，而且如果其中一个头文件被修改过，所有引用过该头文件的文件都需要重新编译。而如果一个.o文件被修改过，所有文件都要重新链接。在复杂的系统里用人工来处理这件事是相当麻烦的，所以我们引用了make和makefile来帮助我们快捷的编译链接文件。</p>
<p>make是命令，makefile则是写规则的文件。</p>
<p>makefile里最基础的规则格式如下:</p>
<pre><code>目标文件:依赖文件
[Tab]命令
</code></pre>
<p>当我们使用命令<code>make 目标文件</code>时，系统会自动检测所有依赖文件，如果依赖文件没有新的修改，则无事发生；如果依赖文件被修改过了，则执行shell命令。shell命令一般是将所有依赖文件编译成目标文件。</p>
<p>这里不再讲述更多的makefile语法，需要的话请网上查找</p>
<p>当前的makefile文件如下：</p>
<pre><code>    BUILD_DIR = ./build
    ENTRY_POINT = 0xc0001500
    AS = nasm
    CC = gcc
    LD = ld
    LIB = -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ 
    ASFLAGS = -f elf

    CFLAGS = -Wall -m32 -fno-stack-protector $(LIB) -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes
    # -fno-stack-protector 闭栈保护的编译选项，栈保护作用是禁止编译器在函数的栈帧中插入栈保护符号，以防止栈溢出攻击。
    # -fno-builtin 告诉编译器不要采用内部函数，因为我们以后会自定义与内部函数同名的函数
    # -Wall 启动所有警告
    # -W 启动常见警告
    # -Wstrict-prototypes  要求函数声明中必须有参数类型，否则警告
    # -Wmissing-prototypes 要求函数必须声明，否则警告

    LDFLAGS =  -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)/kernel.map
    # -Map $(BUILD_DIR)/kernel.map  输出文件build/kernel.map。用于记录kernel符号地址

    OBJS = $(BUILD_DIR)/main.o $(BUILD_DIR)/init.o $(BUILD_DIR)/interrupt.o \
        $(BUILD_DIR)/timer.o $(BUILD_DIR)/kernel.o $(BUILD_DIR)/print.o \
        $(BUILD_DIR)/debug.o 
    # 定义目标文件名集合，用于ld时依赖文件项


    ##############     c代码编译     			###############
    $(BUILD_DIR)/main.o: kernel/main.c lib/kernel/print.h \
            lib/stdint.h kernel/init.h
        $(CC) $(CFLAGS) $&lt; -o $@

    $(BUILD_DIR)/init.o: kernel/init.c kernel/init.h lib/kernel/print.h \
            lib/stdint.h kernel/interrupt.h device/timer.h
        $(CC) $(CFLAGS) $&lt; -o $@

    $(BUILD_DIR)/interrupt.o: kernel/interrupt.c kernel/interrupt.h \
            lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h
        $(CC) $(CFLAGS) $&lt; -o $@

    $(BUILD_DIR)/timer.o: device/timer.c device/timer.h lib/stdint.h\
            lib/kernel/io.h lib/kernel/print.h
        $(CC) $(CFLAGS) $&lt; -o $@

    $(BUILD_DIR)/debug.o: kernel/debug.c kernel/debug.h \
            lib/kernel/print.h lib/stdint.h kernel/interrupt.h
        $(CC) $(CFLAGS) $&lt; -o $@
    ##############     c代码编译     			###############


    ##############    汇编代码编译    ###############
    $(BUILD_DIR)/kernel.o: kernel/kernel.S
        $(AS) $(ASFLAGS) $&lt; -o $@

    $(BUILD_DIR)/print.o: lib/kernel/print.S
        $(AS) $(ASFLAGS) $&lt; -o $@
    ##############    汇编代码编译    ###############


    ##############    链接所有目标文件    #############
    $(BUILD_DIR)/kernel.bin: $(OBJS)
        $(LD) $(LDFLAGS) $^ -o $@
    ##############    链接所有目标文件    #############


    ################  伪目标 ###############################
    .PHONY : mk_dir hd clean build all

    mk_dir:
        if [ ! -d $(BUILD_DIR) ]; then mkdir $(BUILD_DIR); fi

    hd:
        dd if=$(BUILD_DIR)/kernel.bin \
            of=/home/sparkle2/bochs/hd60M.img \
            bs=512 count=200 seek=9 conv=notrunc

    clean:
        cd $(BUILD_DIR) &amp;&amp; rm -f  ./*

    build: $(BUILD_DIR)/kernel.bin

    all: mk_dir build hd
    ################  伪目标 ###############################
</code></pre>
<h1 id="实现自己的字符串操作函数"><a href="#实现自己的字符串操作函数" class="headerlink" title="实现自己的字符串操作函数"></a>实现自己的字符串操作函数</h1><ul>
<li><p>lib&#x2F;string.h</p>
<pre><code>  #ifndef __LIB_STRING_H
  #define __LIB_STRING_H

  #include &quot;stdint.h&quot;
  #define NULL 0

  void memset(void* dst_,uint8_t value,uint32_t size);
  void memcpy(void* dst_,const void* src_,uint32_t size);
  int memcmp(const void* a_,const void* b_, uint32_t size);
  char* strcpy(char* dst_,const char* src_);
  uint32_t strlen(const char* str);
  int8_t strcmp(const char* a,const char* b);
  char* strchr(const char* str,const char ch);
  char* strrchr(const char* str,const uint8_t ch);
  char* strcat(char* dst_,const char* src_);
  char* strchrs(const char* str,uint8_t ch);
  #endif
</code></pre>
</li>
<li><p>lib&#x2F;string.c</p>
<pre><code>  #include&quot;string.h&quot;
  #include&quot;global.h&quot;
  #include&quot;debug.h&quot;

  //将dst_起始的size个字节置为value
  void memset(void* dst_,uint8_t value,uint32_t size)&#123;
      ASSERT(dst_!=NULL);
      uint8_t* dst =(uint8_t*)dst_;
      while(size-- &gt;0)&#123;
          *dst++=value;
      &#125;
  &#125;

  //将src_起始的size个字复制到dst_
  void memcpy(void* dst_,const void* src_,uint32_t size)
  &#123;
      ASSERT(dst_ != NULL &amp;&amp; src_ != NULL);
      uint8_t* dst = dst_;
      const uint8_t* src = src_;
      while((size--) &gt; 0)
          *dst++= *src++;
      return;
  &#125;

  //连续比较地址a和地址b开头的size字节，若相等则返回0，a&gt;b返回1，a&lt;b返回-1
  int memcmp(const void* a_,const void* b_, uint32_t size)
  &#123;
      const char* a = a_;
      const char* b = b_;
      ASSERT(a != NULL || b != NULL);
      while((size--) &gt; 0)
      &#123;
          if(*a != *b)	return (*a &gt; *b) ? 1 : -1;
          a++;
          b++;
      &#125;
      return 0;
  &#125;


  //将字符串从src_复制到dst_
  char* strcpy(char* dst_,const char* src_)
  &#123;
      ASSERT(dst_ != NULL &amp;&amp; src_ != NULL);
      char* dst = dst_;
      while((*(dst_++) = *(src_++) ));
      return dst;     
  &#125;

  //返回字符串长度
  uint32_t strlen(const char* str)
  &#123;
      ASSERT(str != NULL);
      const char* ptr = str;
      while(*(ptr++));
      return (ptr - str - 1);             //例如一个字 1 &#39;\0&#39; ptr会指向&#39;\0&#39;后面一位
  &#125;


  //比较两个字符串，a&gt;b返回1，a&lt;b返回-1，a==b返回0
  int8_t strcmp(const char* a,const char* b)
  &#123;
      ASSERT(a != NULL &amp;&amp; b != NULL);
      while(*a!=0 &amp;&amp; *a == *b)
      &#123;
          a++,b++;
      &#125;   
      return (*a &lt; *b) ? -1 : (*a &gt; *b) ; 
  &#125;

  //从左到右查找字符串str中首次出现的字符ch的地址
  char* strchr(const char* str,const char ch)
  &#123;
      ASSERT(str != NULL);
      while(*str)
      &#123;
          if(*str == ch)
              return (char*)str;
          str++;
      &#125; 
      return NULL;
  &#125;

  //从后往前查找字符串str中首次出现字符ch的地址
  char* strrchr(const char* str,const uint8_t ch)
  &#123;
      ASSERT(str != NULL);
      const char* last_chrptr = NULL;
      while(*str != 0)
      &#123;
          if(ch == *str)	
              last_chrptr = str;
          str++;
      &#125;
      return (char*)last_chrptr;   
  &#125;

  //将字符串src_拼接到dst_后，返回拼接的串地址
  char* strcat(char* dst_,const char* src_)
  &#123;
      ASSERT(dst_ != NULL &amp;&amp; src_ != NULL);
      char* str = dst_;
      while(*(str++));
      str--;
      while((*str++ = *src_++));
      return dst_;
  &#125;

  //在字符串str中查找字符ch出现的次数
  char* strchrs(const char* str,uint8_t ch)
  &#123;
      ASSERT(str != NULL);
      uint32_t ch_cnt = 0;
      const char*p =str;
      while(*p!=0)&#123;
          if(*p==ch)&#123;
              ch_cnt++;
          &#125;
          p++;
      &#125;
      return ch_cnt
  &#125;
</code></pre>
</li>
</ul>
<h1 id="位图bitmap以及函数实现"><a href="#位图bitmap以及函数实现" class="headerlink" title="位图bitmap以及函数实现"></a>位图bitmap以及函数实现</h1><p>我们引入一种数据结构用于资源管理：位图</p>
<p>位图是一个线性数组，其中每一位都代表着对应的物理页(4KB)是否空闲，如下图所示：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/img1.png" alt="img"></p>
<p>bitmap的数据结构以及工具代码如下：</p>
<ul>
<li><p>lib&#x2F;kernel&#x2F;bitmap.h</p>
<pre><code>  #ifndef __KERNEL_BITMAP_H__
  #define __KERNEL_BITMAP_H__

  #include &quot;global.h&quot;

  #define BITMAP_MASK 1
  struct bitmap&#123;
      uint32_t btmp_bytes_len;
      uint8_t* btmp_ptr;
  &#125;;

  void bitmap_init(struct bitmap* btmp);
  bool bitmap_scan_test(struct bitmap*btmp,uint32_t bit_idx);
  int bitmap_scan(struct bitmap*btmp,uint32_t cnt);
  void bitmap_set(struct bitmap* btmp,uint32_t bit_idx,int8_t value);

  #endif
</code></pre>
</li>
<li><p>lib&#x2F;kernel&#x2F;bitmap.c</p>
<pre><code>  #include&quot;bitmap.h&quot;
  #include&quot;stdint.h&quot;
  #include&quot;string.h&quot;
  #include&quot;print.h&quot;
  #include&quot;interrupt.h&quot;
  #include&quot;debug.h&quot;

  void bitmap_init(struct bitmap* btmp)&#123;
      memset(btmp-&gt;btmp_ptr,0,btmp-&gt;btmp_bytes_len);
  &#125;


  //返回btmp中第bit_idx位的状态
  bool bitmap_scan_test(struct bitmap*btmp,uint32_t bit_idx)&#123;
      uint32_t byte_idx=bit_idx/8;
      uint32_t bit_remainder=bit_idx%8;
      return btmp-&gt;btmp_ptr[byte_idx] &amp; (BITMAP_MASK&lt;&lt;bit_remainder);
  &#125;

  //返回btmp里第一个连续cnt字节的空闲空间的起始地址,找不到则返回-1
  int bitmap_scan(struct bitmap*btmp,uint32_t cnt)&#123;
      uint32_t free_byte_idx=0;   //用于记录空闲位所在字节

      while((0xff==btmp-&gt;btmp_ptr[free_byte_idx])&amp;&amp;(free_byte_idx&lt;btmp-&gt;btmp_bytes_len))&#123;
          free_byte_idx++;
      &#125;

      ASSERT(free_byte_idx&lt;btmp-&gt;btmp_bytes_len);
      if(free_byte_idx == btmp-&gt;btmp_bytes_len)&#123;
          return -1;
      &#125;

      int free_bit_idx=0;
      while( (uint8_t)(BITMAP_MASK&lt;&lt;free_bit_idx) &amp; btmp-&gt;btmp_ptr[free_byte_idx] )&#123;
          free_bit_idx++;
      &#125;

      int free_bit_idx_strat=free_byte_idx*8+free_bit_idx;
      if(cnt==1)&#123;
          return free_bit_idx_strat;
      &#125;

      uint32_t bit_leftover=btmp-&gt;btmp_bytes_len*8-free_bit_idx_strat;

      uint32_t next_bit=free_bit_idx_strat+1;
      uint32_t count=1; //用于记录找到空闲位的个数

      free_bit_idx_strat=-1;//假设找不到连续的字节那就返回-1

      while(bit_leftover--)&#123;
          if(!(bitmap_scan_test(btmp,next_bit)))&#123;
              count++;
          &#125;else&#123;
              count=0;
          &#125;

          if(count==cnt)&#123;
              free_bit_idx_strat=next_bit-cnt+1;
              break;
          &#125;
          next_bit++;
      &#125;
      return free_bit_idx_strat;

  &#125;

  void bitmap_set(struct bitmap* btmp,uint32_t bit_idx,int8_t value)&#123;
      ASSERT((value==0) ||(value==1));
      uint32_t byte_idx =bit_idx/8;
      uint32_t bit_remainder=bit_idx%8;

      if(value)&#123;
          btmp-&gt;btmp_ptr[byte_idx] |= (BITMAP_MASK&lt;&lt;bit_remainder);
      &#125;else&#123;
          btmp-&gt;btmp_ptr[byte_idx] &amp;= (BITMAP_MASK&lt;&lt;bit_remainder);
      &#125;

  &#125;
</code></pre>
</li>
</ul>
<h1 id="内存管理系统"><a href="#内存管理系统" class="headerlink" title="内存管理系统"></a>内存管理系统</h1><h2 id="内存池规划"><a href="#内存池规划" class="headerlink" title="内存池规划"></a>内存池规划</h2><p>分页机制下有了虚拟地址和物理地址，操作系统有责任把这两种地址分别管理，并通过页表将这两类地址关联。为了实现内存管理，我们需要实现一个数据结构————内存池</p>
<p>我们打算将物理内存划分为两个内存池，一半用于内核，一半用于用户。并使用内核物理内存池和用户物理内存池来分配物理地址。</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/img2.png" alt="img"></p>
<p>而对于每一个进程，我们都需要一个虚拟用户内存池来分配虚拟地址给进程；也需要一个虚拟内核内存池来分配虚拟地址给内核。</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/img3.png" alt="img"></p>
<p>接下来我们要实现memory.h和memory.c文件，在这两个文件里实现内核物理内存池、用户物理内存池以及一个虚拟内核内存池（现在一个进程都没有，自然不需要虚拟内核用户池）</p>
<p>memory.c里引入了两种新数据结构：pool(物理内存池)、virtual_addr(虚拟内存池)</p>
<p>两种数据结构的构造以及3个内存池的初始化请看以下代码和图片：</p>
<ul>
<li><p>memory.c的代码逻辑（五步走）：</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/img5.png" alt="img"></p>
</li>
<li><p>执行完mem_init()后的物理低端1MB内存布局：</p>
<p>  <img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/img4.png" alt="img"></p>
</li>
<li><p>kernel&#x2F;memory.h:</p>
<pre><code>  #ifndef __KERNEL_MEMORY_H__
  #define __KERNEL_MEMORY_H__

  #include &quot;stdint.h&quot;
  #include &quot;bitmap.h&quot;


  //虚拟地址池
  struct virtual_addr&#123;
      struct bitmap vaddr_bitmap;
      uint32_t vaddr_start;
  &#125;;

  extern struct pool kernel_pool,user_pool;

  void men_init(void);


  #endif
</code></pre>
</li>
<li><p>kernel&#x2F;memory.c:</p>
<pre><code>  #include &quot;memory.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;print.h&quot;

  #define PG_SIZE 4096

  //0xc009f00是内核栈栈顶，0xc009e00分给内核主线程PCB,0xc009a00~0xc009e00这四个页的空间大小全给位图(可管理一共512MB空间)
  #define MEM_BITMAP_BASE 0xc009a000
  #define K_HEAP_START 0xc0100000


  //物理内存池
  struct pool&#123;
      struct bitmap pool_bitmap;
      uint32_t phy_addr_start;
      uint32_t pool_size;
  &#125;;

  struct pool kernel_pool,user_pool;

  struct virtual_addr kernel_vaddr;

  static void mem_pool_init(uint32_t all_mem)&#123;
      put_str(&quot; mem_pool_init start\n&quot;);

      //从物理地址0x100000开始往上，一共有一个页目录和255个页表，总共256个页表
      uint32_t page_table_size=PG_SIZE*256;
      //加上0x100000后就是我们可以使用的物理地址起始地址
      uint32_t used_mem=page_table_size+0x100000;

      uint32_t free_mem=all_mem-used_mem;
      uint16_t all_free_pages=free_mem/PG_SIZE;
      
      uint16_t kernel_free_pages=all_free_pages/2;
      uint16_t user_free_pages=all_free_pages-kernel_free_pages;

      //一字节位图可以代表8页
      uint32_t kbm_length=kernel_free_pages/8;
      uint32_t ubm_length=user_free_pages/8;

      uint32_t kp_start=used_mem;
      uint32_t up_start=kp_start+kernel_free_pages*PG_SIZE;

      kernel_pool.phy_addr_start=kp_start;
      user_pool.phy_addr_start=up_start;

      kernel_pool.pool_size=kernel_free_pages*PG_SIZE;
      user_pool.pool_size=user_free_pages*PG_SIZE;

      kernel_pool.pool_bitmap.btmp_bytes_len=kbm_length;
      user_pool.pool_bitmap.btmp_bytes_len=ubm_length;

      kernel_pool.pool_bitmap.btmp_ptr=(void*)MEM_BITMAP_BASE;
      user_pool.pool_bitmap.btmp_ptr=(void*)(MEM_BITMAP_BASE+kbm_length);

      put_str(&quot;       kernel_pool_bitmap_start:&quot;);
      put_int((int)kernel_pool.pool_bitmap.btmp_ptr);
      put_str(&quot;   kernel_pool_phy_addr_start:&quot;);
      put_int((int)kernel_pool.phy_addr_start);
      put_str(&quot;\n&quot;);

      put_str(&quot;       user_pool_bitmap_start:&quot;);
      put_int((int)user_pool.pool_bitmap.btmp_ptr);
      put_str(&quot;   user_pool_phy_addr_start:&quot;);
      put_int((int)user_pool.phy_addr_start);
      put_str(&quot;\n&quot;);

      bitmap_init(&amp;kernel_pool.pool_bitmap);
      bitmap_init(&amp;user_pool.pool_bitmap);

      
      //初始化内核虚拟内存池
      kernel_vaddr.vaddr_bitmap.btmp_bytes_len=kbm_length;
      kernel_vaddr.vaddr_bitmap.btmp_ptr=(void*)(MEM_BITMAP_BASE+kbm_length+ubm_length);
      kernel_vaddr.vaddr_start=K_HEAP_START;
      bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);
      put_str(&quot;   mem_pool_init done\n&quot;);
      
  &#125;


  void mem_init()&#123;
      put_str(&quot;mem_init start\n&quot;);
      uint32_t mem_bytes_total=(*(uint32_t*)(0xb03));//我们计算出来的地址存到0xb03里
      mem_pool_init(mem_bytes_total);
      put_str(&quot;mem_init done\n&quot;);
  &#125;
</code></pre>
</li>
</ul>
<h2 id="内存管理系统第一步，分配内存页"><a href="#内存管理系统第一步，分配内存页" class="headerlink" title="内存管理系统第一步，分配内存页"></a>内存管理系统第一步，分配内存页</h2><p>我们已经完成内存池的规划以及初始化函数，现在我们要实现malloc函数（我们实现的malloc函数只能以页为单位分配），实现系统调用分配内存。</p>
<p>malloc_page的逻辑如下：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/img6.png" alt="img"></p>
<p>其中page_table_add(vaddr,page_phyaddr)的逻辑较为复制，因此绘制其流程图：</p>
<p><img src="/img/%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AB%EF%BC%89/img7.png" alt="img"></p>
<p>代码如下：</p>
<ul>
<li><p>kernel&#x2F;memory.c(增加部分):</p>
<pre><code>  #include &quot;memory.h&quot;
  #include &quot;stdint.h&quot;
  #include &quot;print.h&quot;
  #include &quot;bitmap.h&quot;
  #include &quot;global.h&quot;
  #include &quot;debug.h&quot;
  #include &quot;string.h&quot;


  #define PDE_IDX(addr)   ((addr &amp; 0xffc00000)&gt;&gt;22)
  #define PTE_IDX(addr)   ((addr &amp; 0x003ff000)&gt;&gt;12)

  #define PG_SIZE 4096



  //  内核/用户 向虚拟内存池申请连续个pg_cnt个虚拟地址，成功返回地址起点，失败返回-1
  static void* vaddr_get(enum pool_flags pf,uint32_t pg_cnt)&#123;
      int vaddr_start=0,bit_idx_start=-1;
      uint32_t cnt=0;
      if( pf ==PF_KERNEL)&#123;
          bit_idx_start=bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap,pg_cnt);
          if(bit_idx_start==-1)&#123;
              return NULL;
          &#125;
          while(cnt&lt;pg_cnt)&#123;
              bitmap_set(&amp;kernel_vaddr.vaddr_bitmap,bit_idx_start+cnt++,1);
          &#125;
          vaddr_start=kernel_vaddr.vaddr_start+bit_idx_start*PG_SIZE;
      &#125;else&#123;
          //用户内存池，将来实现
      &#125;
      return (void*)vaddr_start;
  &#125;

  // 内核/用户 向物理内存池申请连续1页，成功返回地址起点，失败返回-1
  static void* palloc(struct pool* m_pool)&#123;
      int bit_idx_start=bitmap_scan(&amp;m_pool-&gt;pool_bitmap,1);
      if(bit_idx_start==-1)&#123;
          return NULL;
      &#125;
      bitmap_set(&amp;m_pool-&gt;pool_bitmap,bit_idx_start,1);
      uint32_t page_phyaddr=((bit_idx_start*PG_SIZE)+m_pool-&gt;phy_addr_start);
      return (void*)page_phyaddr;
  &#125;

  //得到虚拟地址vaddr对应的pte指针
  uint32_t* pte_ptr(uint32_t vaddr)&#123;
      //该公式见第五章关于页目录自映射
      uint32_t* pte=(uint32_t*)(0xffc00000+ ((vaddr &amp; 0xffc00000)&gt;&gt;10)+PTE_IDX(vaddr)*4);
      return pte;
  &#125;

  //得到虚拟地址vaddr对应的pde指针
  uint32_t* pde_ptr(uint32_t vaddr)&#123;
      //该公式见第五章关于页目录自映射
      uint32_t* pde=(uint32_t*)((0xfffff000) + PDE_IDX(vaddr)*4);
      return pde;
  &#125;


  //建立从虚拟地址到物理地址的映射
  static void page_table_add(void* _vaddr,void* _page_phyaddr)&#123;
      uint32_t vaddr=(uint32_t)_vaddr,page_phyaddr=(uint32_t)_page_phyaddr;

      //指针本身就是虚拟地址
      uint32_t* pde=pde_ptr(vaddr);
      uint32_t* pte=pte_ptr(vaddr);


      if(*pde &amp; 0x00000001)&#123;
          ASSERT(!(*pte &amp; 0x00000001));
          if(!(*pte &amp; 0x00000001))&#123;
              *pte=(page_phyaddr|PG_US_U|PG_RW_W|PG_P_1);
          &#125;else&#123;
              PANIC(&quot;pte repeat&quot;);
              *pte=(page_phyaddr|PG_US_U|PG_RW_W|PG_P_1);
          &#125;
      &#125;else&#123;
          //这儿为页表申请地址，pde_phyaddr记录的其实是页表的其实地址
          uint32_t pde_phyaddr=(uint32_t)palloc(&amp;kernel_pool);
          *pde=(pde_phyaddr|PG_US_U|PG_RW_W|PG_P_1);
          
          memset((void*)((int)pte &amp; 0xfffff000),0,PG_SIZE);

          ASSERT(!(*pte &amp; 0x00000001));

          *pte=(page_phyaddr|PG_US_U|PG_RW_W|PG_P_1);
      &#125;

  &#125;

  //实现自己的以页为单位分配空间的malloc函数,成功返回起始虚拟地址,失败返回NULL
  void* malloc_page(enum pool_flags pf,uint32_t pg_cnt)&#123;

      //分配的页不能超过真实物理内存的一半（16MB，我们取整就是3840页）
      ASSERT(pg_cnt&gt;0 &amp;&amp; pg_cnt&lt;3840);

      void* vaddr_start = vaddr_get(pf,pg_cnt);
      if(vaddr_start==NULL)&#123;
          return NULL;
      &#125;

      uint32_t vaddr=(uint32_t)vaddr_start,cnt=pg_cnt;

      struct pool* mem_pool=pf &amp; PF_KERNEL? &amp;kernel_pool:&amp;user_pool;

      while(cnt-- &gt;0)&#123;
          void* page_phyaddr =palloc(mem_pool);
          if(page_phyaddr==NULL)&#123;
              return NULL;
          &#125;
          page_table_add((void*)vaddr,page_phyaddr);
          vaddr+=PG_SIZE;
      &#125;
      
      return vaddr_start;
  &#125;


  //从内核物理内存池里获取pg_cnt页内存，成功则返回虚拟地址
  void* get_kernel_pages(uint32_t pg_cnt)&#123;

      void* vaddr=malloc_page(PF_KERNEL,pg_cnt);

      //将申请的空间请0
      if(vaddr!=NULL)&#123;
          memset(vaddr,0,pg_cnt*PG_SIZE);
      &#125;
      return vaddr;
  &#125;
</code></pre>
</li>
<li><p>kernel&#x2F;memory.h:</p>
<pre><code>  #ifndef __KERNEL_MEMORY_H__
  #define __KERNEL_MEMORY_H__

  #include &quot;stdint.h&quot;
  #include &quot;bitmap.h&quot;

  //虚拟地址池
  struct virtual_addr&#123;
      struct bitmap vaddr_bitmap;
      uint32_t vaddr_start;
  &#125;;

  enum pool_flags&#123;
      PF_KERNEL=1,
      PF_USER=3
  &#125;;

  #define PG_P_1      1
  #define PG_P_0      0
  #define PG_Rw_R     0
  #define PG_RW_W     2
  #define PG_US_S     0
  #define PG_US_U     4


  extern struct pool kernel_pool,user_pool;


  void mem_init(void);
  uint32_t* pte_ptr(uint32_t vaddr);
  uint32_t* pde_ptr(uint32_t vaddr);
  void* malloc_page(enum pool_flags pf,uint32_t pg_cnt);
  void* get_kernel_pages(uint32_t pg_cnt);

  #endif
</code></pre>
</li>
</ul>
<h2 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h2><p>最后可以通过<code>info tab</code>来查看新建立的映射是否正确,并且可以通过<code>page 页虚拟地址</code>来查看该线性页落到哪一个物理页上</p>
<ul>
<li><p>makefile(更新过):</p>
<pre><code>  BUILD_DIR = ./build
  ENTRY_POINT = 0xc0001500
  AS = nasm
  CC = gcc
  LD = ld
  LIB = -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ 
  ASFLAGS = -f elf

  CFLAGS = -Wall -m32 -fno-stack-protector $(LIB) -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes
  # -fno-stack-protector 闭栈保护的编译选项，栈保护作用是禁止编译器在函数的栈帧中插入栈保护符号，以防止栈溢出攻击。
  # -fno-builtin 告诉编译器不要采用内部函数，因为我们以后会自定义与内部函数同名的函数
  # -Wall 启动所有警告
  # -W 启动常见警告
  # -Wstrict-prototypes  要求函数声明中必须有参数类型，否则警告
  # -Wmissing-prototypes 要求函数必须声明，否则警告

  LDFLAGS =  -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)/kernel.map
  # -Map $(BUILD_DIR)/kernel.map  输出文件build/kernel.map。用于记录kernel符号地址

  OBJS = $(BUILD_DIR)/main.o $(BUILD_DIR)/init.o $(BUILD_DIR)/interrupt.o \
      $(BUILD_DIR)/timer.o $(BUILD_DIR)/kernel.o $(BUILD_DIR)/print.o \
      $(BUILD_DIR)/debug.o $(BUILD_DIR)/string.o $(BUILD_DIR)/memory.o \
      $(BUILD_DIR)/bitmap.o
  # 定义目标文件名集合，用于ld时依赖文件项


  ##############     c代码编译     			###############
  $(BUILD_DIR)/main.o: kernel/main.c lib/kernel/print.h \
          lib/stdint.h kernel/init.h lib/string.h kernel/memory.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/init.o: kernel/init.c kernel/init.h lib/kernel/print.h \
          lib/stdint.h kernel/interrupt.h device/timer.h kernel/memory.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/interrupt.o: kernel/interrupt.c kernel/interrupt.h \
          lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/timer.o: device/timer.c device/timer.h lib/stdint.h\
          lib/kernel/io.h lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/debug.o: kernel/debug.c kernel/debug.h \
          lib/kernel/print.h lib/stdint.h kernel/interrupt.h
      $(CC) $(CFLAGS) $&lt; -o $@

  $(BUILD_DIR)/string.o: lib/string.c lib/string.h \
          kernel/debug.h kernel/global.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/memory.o: kernel/memory.c kernel/memory.h \
          lib/stdint.h lib/kernel/bitmap.h kernel/debug.h lib/string.h \
          lib/kernel/print.h
      $(CC) $(CFLAGS) $&lt; -o $@
      
  $(BUILD_DIR)/bitmap.o: lib/kernel/bitmap.c lib/kernel/bitmap.h \
          lib/string.h kernel/interrupt.h lib/kernel/print.h kernel/debug.h
      $(CC) $(CFLAGS) $&lt; -o $@
  ##############     c代码编译     			###############


  ##############    汇编代码编译    ###############
  $(BUILD_DIR)/kernel.o: kernel/kernel.S
      $(AS) $(ASFLAGS) $&lt; -o $@

  $(BUILD_DIR)/print.o: lib/kernel/print.S
      $(AS) $(ASFLAGS) $&lt; -o $@
  ##############    汇编代码编译    ###############


  ##############    链接所有目标文件    #############
  $(BUILD_DIR)/kernel.bin: $(OBJS)
      $(LD) $(LDFLAGS) $^ -o $@
  ##############    链接所有目标文件    #############


  ################  伪目标 ###############################
  .PHONY : mk_dir hd clean build all

  mk_dir:
      if [ ! -d $(BUILD_DIR) ]; then mkdir $(BUILD_DIR); fi

  hd:
      dd if=$(BUILD_DIR)/kernel.bin \
          of=/home/sparkle2/bochs/hd60M.img \
          bs=512 count=200 seek=9 conv=notrunc

  clean:
      cd $(BUILD_DIR) &amp;&amp; rm -f  ./*

  build: $(BUILD_DIR)/kernel.bin

  all: mk_dir build hd
  ################  伪目标 ###############################
</code></pre>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
