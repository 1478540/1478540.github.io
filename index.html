<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sparkle&#39;s Space">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sparkle&#39;s Space">
<meta property="og:description" content="If there is no torchlight in the future, I will be the only light.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Sparkle">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sparkle's Space</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sparkle's Space</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sparkle"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sparkle</p>
  <div class="site-description" itemprop="description">If there is no torchlight in the future, I will be the only light.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/21/%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AD%A6/" class="post-title-link" itemprop="url">系统思维学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-10-21 21:38:41 / Modified: 23:08:06" itemprop="dateCreated datePublished" datetime="2024-10-21T21:38:41+08:00">2024-10-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h1><p>最近我从一本书《系统之美》(德内拉.梅多斯)学到些知识，再加上平时自己多有感悟，于是打算做一个总结梳理。同时本文也是对我今后思维决策的引导。</p>
<h1 id="何为系统思维？"><a href="#何为系统思维？" class="headerlink" title="何为系统思维？"></a>何为系统思维？</h1><p>将万事万物看成一个系统进行分析，从而快速掌握事物本质。</p>
<h1 id="何为系统？"><a href="#何为系统？" class="headerlink" title="何为系统？"></a>何为系统？</h1><ul>
<li><p>系统可分为三要素：目标、要素、连接</p>
<ul>
<li><p>要素：系统的组成单位</p>
</li>
<li><p>连接：要素之间的关联</p>
</li>
<li><p>目标：系统存在的目的（各要素目标可能与系统整体相同也可能不同）</p>
</li>
</ul>
</li>
<li><p>每一个系统都可看作是更小的子系统(模块)的连接体</p>
</li>
<li><p>系统可根据侧重点分为动态系统和静态系统，关键在于系统的中流量是否重要</p>
</li>
</ul>
<h1 id="动态系统"><a href="#动态系统" class="headerlink" title="动态系统"></a>动态系统</h1><p>如果系统中存在流量概念且流量对其自身影响巨大，那么我们应该将其作为动态系统进行分析（例如：工厂经营、理财）</p>
<ul>
<li><p>存量：系统中要素的容量</p>
</li>
<li><p>流量：存量的变化（增加或者减少）</p>
</li>
<li><p>时间延迟：存量的改变是存在时间延迟的（不容忽视）</p>
</li>
<li><p>变化因素：影响流量的因素</p>
</li>
<li><p>回路：当变化后的存量会反馈作用到变化因素上时便形成回路。回路分为调解回路和增强回路，调节回路会使系统存量趋于稳定值，增强回路则使系统存量趋于极端(更多&#x2F;更少)</p>
</li>
</ul>
<p>分析动态系统时我们常常要借助<code>流量图</code>，一个简单的室内温度调节系统的流量图如下：</p>
<p><img src="/img/%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AD%A6/img1.png" alt="img"></p>
<ul>
<li>PS：其中方块表示存量、云表示流量、箭头表示变化因素的作用&#x2F;连接</li>
</ul>
<p>仔细分析流量图有助于我们掌握动态系统的本质，找到可以改变系统的杠杆点，通过调整系统结构(例如构建新的回路)来优化系统</p>
<p>分析动态系统应该先画流量图，然后重点关注其中的<code>回路</code>和<code>流量</code>，不要忘记存量的变化是存在时间延迟的。</p>
<h1 id="静态系统"><a href="#静态系统" class="headerlink" title="静态系统"></a>静态系统</h1><p>如果系统中流量概念可以忽视，那么我们应该将其作为静态系统进行分析（例如：看一本书、学习一项技能）</p>
<p>静态系统的分析重点是关注<code>模块(子系统)之间的逻辑结构</code>，也就是各个模块之间是如何相互关联的，模块往往可以视为一个系统继续拆分成更小的模块的组合，最后一层层拆分成不可分割的原子。</p>
<h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><ol>
<li><p>明确唯一核心目标</p>
<p> 越清晰越好，一旦确定不可更换</p>
</li>
<li><p>信息收集</p>
<p> 围绕 唯一核心目标 进行信息收集，越是全面准确的信息，越是有助于系统的构建</p>
</li>
<li><p>系统构建</p>
<p> 开始构建相应的系统。</p>
<p> <code>不关注具体细节的实现！</code></p>
<p> 过早地关注细节为迷失在繁杂的系统中</p>
</li>
<li><p>落实细节</p>
<p> 最后再落实到细节，而且并非落实到每一步细节</p>
<p> 只落实到尽可能少量的、关键的细节（奉行<code>最小可行性方案原则</code>，只落实实现核心目标所<code>必不可少</code>的细节，多一点都不要）</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/14/Electronic-pulse-monitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/14/Electronic-pulse-monitor/" class="post-title-link" itemprop="url">数电课设：红外线心率计(数电部分)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-10-14 14:29:33 / Modified: 15:32:34" itemprop="dateCreated datePublished" datetime="2024-10-14T14:29:33+08:00">2024-10-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本项目设计电路并焊接红外线心率计（数电部分）</p>
<p>红外线心率计就是通过红外线传感器检测出手指中动脉血管的微弱波动，由计数器计算出每分钟波动的次数。</p>
<p>本项目中，模电部分不需要我们实际操作，我们只需要完成<code>由门控电路控制3位计数器并进行译码、驱动、显示的部分</code>。</p>
<p>具体工作模块如下：</p>
<p><img src="/img/Electronic-pulse-monitor/img1.png" alt="img"></p>
<h1 id="门控电路"><a href="#门控电路" class="headerlink" title="门控电路"></a>门控电路</h1><p>门控电路用 555 接成<code>单稳态触发器</code>,作用是控制计数器的启停，并控制每次测量的时间</p>
<p>门控电路的电路图如下：</p>
<p><img src="/img/Electronic-pulse-monitor/img2.png" alt="img"></p>
<p>具体过程是，按下开关形成向下的边沿，LED灯亮起，2脚电压为0，低于1&#x2F;3Vcc，3脚输出高电平，计数器开始计数，此时电解电容开始充电；当电压达到2&#x2F;3Vcc时，3脚输出低电平，计数器停止计数，电容放电回到低电平，返回稳定状态，定时结束。</p>
<h1 id="三位计数电路"><a href="#三位计数电路" class="headerlink" title="三位计数电路"></a>三位计数电路</h1><p>由 MC14553 组成的 3 位计数电路对输入的方波进行计数，并把计数结果以 BCD 码（使用4位二进制表示一位十进制的方式，常见的有8421码、2421码、5421码，本项目采用8421码）的形式输出。引脚功能如下：</p>
<p><img src="/img/Electronic-pulse-monitor/img3.png" alt="img"></p>
<p>三位计数电路图如下：</p>
<p><img src="/img/Electronic-pulse-monitor/img4.png" alt="img"></p>
<h1 id="译码、驱动、显示电路"><a href="#译码、驱动、显示电路" class="headerlink" title="译码、驱动、显示电路"></a>译码、驱动、显示电路</h1><p>3 位计数电路、译码、驱动、显示电路的作用是把计数器输出的计数结果显示在 3 位数码管上。其中译码器CD4543具体引脚功能如下：</p>
<p><img src="/img/Electronic-pulse-monitor/img5.png" alt="img"></p>
<p>数码管abcdefg对应的7个LED如下图所示：</p>
<p><img src="/img/Electronic-pulse-monitor/img7.png" alt="img"></p>
<p>PS：共阳极电路代表所有LED阳极被连接到一起，通过控制各自的阴极电平来点亮LED,低电平有效。共阴极电路代表所有LED阴极被连接到一起，通过控制各自的阳极电平来点亮LED,高电平有效。</p>
<h1 id="整体电路图如下："><a href="#整体电路图如下：" class="headerlink" title="整体电路图如下："></a>整体电路图如下：</h1><p><img src="/img/Electronic-pulse-monitor/img6.png" alt="img"></p>
<h1 id="附加部分：NE555（不懂就跳过）"><a href="#附加部分：NE555（不懂就跳过）" class="headerlink" title="附加部分：NE555（不懂就跳过）"></a>附加部分：NE555（不懂就跳过）</h1><p>555定时器芯片一般不单独使用，而是构成单稳态触发器、多谐振荡器和施密特触发器等多种电路综合应用。</p>
<p>NE555内部电路图如下：<br><img src="/img/Electronic-pulse-monitor/img10.png" alt="img"></p>
<p>各个引脚的功能如下：</p>
<p><img src="/img/Electronic-pulse-monitor/img8.png" alt="img"></p>
<ul>
<li>1脚：接地。</li>
<li>2脚：输入端Trigger，该脚会判断其电压是否小于1&#x2F;3 Vcc。</li>
<li>3脚：输出端Output。</li>
<li>4脚：清零端Reset。正常工作时应接高电平。</li>
<li>5脚：控制电压端。一般不使用，应通过一只0.01μF（103）瓷片电容接地，以防引入高频干扰。</li>
<li>6脚：输入端Threshold，该脚会判断其电压是否大于2&#x2F;3 Vcc。</li>
<li>7脚：放电端Discharge。</li>
<li>8脚：外接电源Vcc，范围为4.5V~16V，一般用5V。</li>
</ul>
<p>输出端3脚的电平与输入的关系如下表所示：</p>
<p><img src="/img/Electronic-pulse-monitor/img9.png" alt="img"></p>
<p>如果不想了解具体的工作原理，只需要知道以下几点即可：</p>
<ul>
<li>1脚接地，8脚接电源，4脚大部分情况下也接电源</li>
<li>5脚通过一个0.01μF电容接地，也可以悬空（不建议）</li>
<li>2、6、7脚根据不同应用有不同接法</li>
<li>3脚是输出</li>
</ul>
<p>如果不想真正了解具体的工作原理，需要看懂以下电路图：</p>
<ul>
<li>555内部电路图</li>
<li>555组成的单稳态触发器、施密特触发器、多谐振荡器等电路图</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/10/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/10/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">智能小车实现分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-10-10 15:23:38 / Modified: 17:52:20" itemprop="dateCreated datePublished" datetime="2024-10-10T15:23:38+08:00">2024-10-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>导师制项目基于51单片机的智能循迹小车，包含黑线循迹、超声波避障、红外线遥控3大功能。</p>
<p>本文对该项目涉及外设以及具体的功能实现进行一个整合分析</p>
<h1 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h1><p>主控芯片：STC89C52</p>
<p>小车车体：清翔电子的QX-A51两驱智能小车组件</p>
<p>电源：使用18650锂电池作为电源，负责提供电能给各个模块。LM7805三端稳压器提供稳定的5V直流电压，</p>
<p>电机驱动模块：使用L293D芯片作为电机驱动芯片，负责驱动两个TT减速电机，搭配两个车轮和一个定向轮，改变小车的速度和方向。</p>
<p>黑线循迹模块：使用两组RPR220一体化反射式光电传感器作为循迹传感器，使用LM324芯片用作电压比较模块芯片，负责检测地面上的黑线并输出高低电平信号。</p>
<p>超声波避障模块：使用HC-SR04超声波传感器作为避障传感器，负责检测前方是否有障碍物。</p>
<p>红外遥控模块：迷你红外遥控器发送红外光信号，使用HS0038红外接收探头接受红外光信号，并在单片机内部进行解码后输出指令或数据信号。</p>
<h1 id="PWM（脉宽调制）实现小车变速"><a href="#PWM（脉宽调制）实现小车变速" class="headerlink" title="PWM（脉宽调制）实现小车变速"></a>PWM（脉宽调制）实现小车变速</h1><ul>
<li><p>PWM（脉宽调制）</p>
<p> 利用微处理器的数字输出，来形成想要的波形。</p>
<p> 利用PWM实现小车变速，其实就是输出一段波形，高电平持续时间关闭电机，低电平时间开启电机，则占空比越大车速越慢。</p>
</li>
<li><p>占空比</p>
<p>  脉冲信号中高电平持续时间与整个周期时间的比率</p>
</li>
<li><p>PWM信号频率</p>
<p>  PWM的信号频率通常取决于应用需求和电机特性。对于智能小车的电机控制，100Hz是一个常见且合理的选择。因此波形的周期是<code>1/100Hz=10ms</code></p>
</li>
<li><p>单片机晶振频率&#x2F;时钟周期</p>
<p>  该单片机的晶振频率为11.0592MHz，则其时钟周期为<code>1/11.0592MHz=0.0904us</code></p>
</li>
<li><p>机器周期&#x2F;计时器每变化一次所需时间</p>
<p>  51系列单片机的机器周期等于12个时钟周期，于是<code>0.0904us*12=1.085us</code></p>
</li>
<li><p>定时器初始值</p>
<p>  我们希望占空比变化范围在<code>1/256~1</code>之间，所以需要波形周期10ms分为256份，每份是39.0625us</p>
<p>  又知计时器每变化一次所需时间为1.085us，则39.0625us需要计数约36次</p>
<p>  设置定时器为8位重装模式（每逢计数到256溢出后重新设置为初值），则定时器初值应该设置为<code>256-36=220</code></p>
</li>
<li><p>实现小车变速</p>
<p>  这样一来，定时器每一次触发中断，就说明时间走完256份周期中的一份。</p>
<p>  设置一个计数标志位count，每一次中断count+1。</p>
<p>  当count达到阈值X（阈值X&#x2F;256&#x3D;占空比）时启动小车电机，当count达到255时关闭小车电机并置0，由此实现变速</p>
</li>
<li><p>结果</p>
<p>  阈值X的设定应该在0~170之间较为合理，阈值过高则会导致小车电机输出时间过短，扭矩不够</p>
</li>
</ul>
<h1 id="红外循迹模块"><a href="#红外循迹模块" class="headerlink" title="红外循迹模块"></a>红外循迹模块</h1><ul>
<li><p>红外线在不同颜色的物体表面具有不同的反射性质，照射到黑线上时，会被黑线吸收，从而导致探测器接受红外光较弱；当红外线照射到白色地面上时，会被反射回来，探测器接受红外光较强</p>
</li>
<li><p>RPR220红外探照头以及LM324电压电路如下</p>
</li>
</ul>
<p><img src="/img/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/img1.png" alt="img"></p>
<p>智能小车一上电RPR220内部红外光发射，经由物体反射回光电三极管。当所接受到的红外光越强(即未接触黑线)则IN1与IN2两处电流越大。如图3所示，IN1与IN2将会接入LM324电压比较模块里与T1和T2处进行电压比较。如果T1&gt;IN1则P3.2输出1，T2&gt;IN2，则P3.3输出1；反之则都输出0。也就是说T1和T2的电压强度将会成为衡量是否接触黑线的标准，二者的电压强度可通过电位器RW3和RW4进行调节，调节到合适的强度使得小车可以准确识别黑线。</p>
<h1 id="超声波避障"><a href="#超声波避障" class="headerlink" title="超声波避障"></a>超声波避障</h1><p>HC-SR04超声波测距模块是一种基于超声波反射原理的测距传感器，它由一个超声波发射器、一个超声波接收器和一个控制电路组成。</p>
<p><img src="/img/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/img2.png" alt="img"></p>
<p>HC-SR04工作原理：当向TRIG引脚输入一个10us以上的高电平信号时，模块会自动发射8个40kHz的方波信号。当发射的超声波遇到障碍物时，会被反射回来，被接收器检测到。接收到反射回来的超声波时，模块会向ECHO引脚输出一个与超声波往返时间成正比的高电平信号。而通过测量ECHO引脚输出的高电平信号的持续时间，就可以根据声速计算出超声波从发射到返回的时间，进而得到距离障碍物的距离</p>
<h1 id="红外遥控"><a href="#红外遥控" class="headerlink" title="红外遥控"></a>红外遥控</h1><p>NEC协议是一种常用的红外遥控通信协议，它采用脉冲位置调制（PPM），利用脉冲之间的时间间隔来区分“0”和“1”。</p>
<p><img src="/img/%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/img3.png" alt="img"></p>
<p>NEC协议的数据帧格式如图4所示，包括引导码、用户码、用户反码、数据码和数据反码。用户码和用户反码用来校验发送者的身份，数据码和数据反码用来传输按键信息。NEC协议的特点有以下几点：数据帧长度为32位，每个字节从最低位开始发送。引导码由9ms的低电平和4.5ms的高电平组成，用来标志数据帧的开始。逻辑“0”由560us的低电平和560us的高电平组成，逻辑“1”由560us的低电平和1680us的高电平组成。结束码由560us的低电平组成，用来标志数据帧的结束，因此在程序设计中可通过信号时间长短来解析数据帧。</p>
<p>外部中断0（INT0）被配置为下降沿触发模式，当HS0038接受到红外信号时会产生一个下降沿信号，从而触发外部中断0。</p>
<p>定时器0则设置为8位重装模式，初始值为0，也就是每<code>256*1.085us=277.76us</code>中断一次，并使IRtime++</p>
<p>使用外部中断(INT0)来捕获每一次红外信号下降沿、使用定时器0来记录每两次外部中断(INT0)之间的时间间隔IRtime、因此每一次外部中断(INT0)都可以通过访问IRtime来获取上一个红外信号方波持续时间（获取完数据后需给IRtime置0，保证下一次计数的正确性）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/01/SimpleOS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/01/SimpleOS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">SimpleOS-文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-01-01 10:29:13" itemprop="dateCreated datePublished" datetime="2024-01-01T10:29:13+08:00">2024-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-10-09 17:42:32" itemprop="dateModified" datetime="2024-10-09T17:42:32+08:00">2024-10-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整体设计方案"><a href="#整体设计方案" class="headerlink" title="整体设计方案"></a>整体设计方案</h1><p>本文件系统仿照Linux的ext2文件系统设计</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img7.png" alt="img"></p>
<h2 id="文件的读写单位——块"><a href="#文件的读写单位——块" class="headerlink" title="文件的读写单位——块"></a>文件的读写单位——块</h2><p>硬盘的读写单位是扇区，但是由于硬盘读写速度较慢，所以当我们读写文件时，不是一个一个扇区进行读写，而是凑齐数个扇区一起读写，我们将其称为块。</p>
<p>因此 块是文件的读写单位， 一个块包含数个扇区（一定是扇区的整数倍）</p>
<h2 id="文件的本质——inode"><a href="#文件的本质——inode" class="headerlink" title="文件的本质——inode"></a>文件的本质——inode</h2><p>文件其实就是存储在硬盘上的数据，并且是以块为单位进行读写</p>
<p>我们关注文件，本质上是关注<code>数据在硬盘上存储的块的组织方式</code>（数据块在硬盘上是不连续的）</p>
<p>FAT文件系统曾采用<code>链式结构</code>进行组织（每个块的最后存储下一个块的地址），但由于访问文件中某一个块时都得从头遍历，最终放弃使用该文件系统</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img11.png" alt="img"></p>
<p>UINX操作系统采用<code>索引结构inode</code>进行组织，后来Linux的ext2文件系统也是模仿该组织形式，本项目同样采用索引结构inode</p>
<p>索引结构说简单点就是一个数组，每一个元素就是每一个块，比起链式结构来说，访问某个特定的块无需从头遍历</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img12.png" alt="img"></p>
<p>所以现在看来inode就是一个数组，数组元素就是块地址，我们根据数组的索引可以方便的寻找到对应块的地址</p>
<p>然而真正的inode并非这么简单，它还需要扩展两点</p>
<ul>
<li><p>文件过大怎么办？——引入间接块索引表指针</p>
<pre><code>  假设我们一个indoe包含15个索引项，其中前面12个是直接块指针。当一个文件大小小于等于12块时就可以只使用前12个索引项解决问题。

  当文件大小超越12个块了怎么办？

  我们把第13个索引项作为一级间接块索引表指针，它指向一级间接块索引表（单独占一个块），而一级间接块索引表上面又存储着256个直接块地址。于是文件最大可达12+256=268个块

  当文件超越268个块了怎么办？

  我们把第14个索引项作为二级间接块索引表指针，它指向256个一级间接块索引表指针，于是文件最大可达12+256+256*256个块

  文件大小还是太大了怎么办？

  我们把第15个索引项作为三级间接块索引表指针，它指向256个二级间接块索引表指针，于是文件最大可达12+256+256*256+256*256*256个块

  一般的文件无法超越这个大小。再大的文件就只能呢使用mv命令分割成数个小文件
</code></pre>
</li>
<li><p>inode真的只是一个数组吗？</p>
<pre><code>  其实不然，inode最核心的部分确实是块数组。但inode的本质其实是文件的元信息。除了包含块数组（描述文件存储位置），还包含一些其他的元信息，例如：i结点编号（inode的唯一编号）、文件大小、权限、创建时间、属主等等
</code></pre>
</li>
</ul>
<p>结合上述两点扩展，现在真正的inode如下图所示：</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img13.png" alt="img"></p>
<h2 id="所有文件的集合——inode数组"><a href="#所有文件的集合——inode数组" class="headerlink" title="所有文件的集合——inode数组"></a>所有文件的集合——inode数组</h2><p>一个inode就是一个文件，我们将所有inode的编号作为索引，inode地址作为元素，构成一个inode数组。</p>
<p>现在所有的inode地址信息都集合在inode数组里了，只需要提供inode编号，我就可以去查找具体的inode</p>
<h2 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h2><p>文件包含两大类：目录文件 和 普通文件</p>
<p>日常口语中的文件大多指的是普通文件，但本文讨论的文件既包括普通文件也包括目录文件</p>
<p>目录也是文件？对的，在ext2文件系统中，目录文件和普通文件一样都算文件，它们的真面目也都是<code>inode</code></p>
<p>唯一的区别就是数据块存储的内容不同。目录文件的数据块存储的内容是<code>目录项</code>,而普通文件的数据块存储的内容是<code>普通数据</code>。</p>
<p>二者对外表现都是inode，也就是说，在没有外来信息（上级目录）提供帮助的情况下，一个inode就是一个inode,你永远无法区分它到底是目录文化还是普通文件。</p>
<p>PS：<code>目录项</code>是什么？目录项是目录文件下的单位表项，它将inode编号、文件名、文件类型三者关联起来，如图：</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img14.png" alt="img"></p>
<h2 id="完整的FCB——inode-目录项"><a href="#完整的FCB——inode-目录项" class="headerlink" title="完整的FCB——inode+目录项"></a>完整的FCB——inode+目录项</h2><p>FCB全称是文件控制块，只要是用于管理、控制文件相关信息的数据结构都称为FCB</p>
<p>ext2文件系统里的FCB包含inode和目录项两大数据结构，也就是说只凭借二者就可以完整的组织起所有的文件</p>
<p>inode和目录项的关系参照下图：</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img15.png" alt="img"></p>
<pre><code>    我们假设inode1是根目录，是一切最开始的文件。由于根目录文件的位置是固定不动的，所以我们能确定它是目录文件而不会混淆，根目录文件里的数据块存储的理所当然是一系列目录项。
    
    而目录项上记载了文件的类型、文件名称、inode编号

    我们的inode2类型是普通文件，所以我们可以根据inode编号2在inode数组中查找到对应的inode地址。然后根据块指针找到硬盘上对应的数据块，并读取数据块上的普通数据

    我们的inode3类型是目录文件，所以我们可以根据inode编号3在inode数组中查找到对应的inode地址。然后根据块指针找到硬盘上的对应块，并读取数据块上的目录项
</code></pre>
<p>现在，假设我们有一串完整的文件地址，例如：<code>D:\CodeSet\myBlog\source\img\SimpleOS-7-文件系统\img11.png</code><br>我们就可以根据上诉方法一步一步递归查找，最后寻找到正确的文件</p>
<h2 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="文件系统的布局"></a>文件系统的布局</h2><p>一个文件系统就是一个分区，而每一个硬盘分区的空间大小是有限的。不论是inode还是用于存储数据的空闲块都需要占据同一个分区的空间。因此，一个分区所拥有的inode和空闲块都是有限的，而且需要使用<code>位图</code>数据结构进行管理。</p>
<p>综上，一个文件系统需要inode位图、空闲块位图、inode数组、固定的根目录位置，以及还需要一个用来描述该文件系统元信息的<code>超级块</code></p>
<p>文件系统在磁盘上的布局如下图所示：</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img16.png" alt="img"></p>
<p>其中<code>超级块</code>的结构如下图所示：</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img17.png" alt="img"></p>
<p>至此，整个文件系统的布局已经完整，文件之间的组织方式也已经清晰，大体上如下图：</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img2.png" alt="img"></p>
<p>PS:一个操作系统具有多个分区，也就是多个文件系统，但初始化时往往只会挂载一个主要的文件系统，也就是当前文件系统</p>
<h2 id="进程间的文件操作"><a href="#进程间的文件操作" class="headerlink" title="进程间的文件操作"></a>进程间的文件操作</h2><p>众所周知，一个电脑允许多个进程，一个进程又允许多次打开同一个文件或者打开多个不同的文件。并对文件进行操作。</p>
<p>我们该如何处理 多进程 与 多文件 之间的关联问题？</p>
<p>为此，我们引入了如下概念：文件描述符、文件结构、文件表、inode缓冲队列</p>
<p>它们之间的逻辑关系如下图所示：</p>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img3.png" alt="img"></p>
<ul>
<li><p>文件结构file</p>
<pre><code>  文件结构file用于记录文件操作（光标偏移量等），每次打开一个文件同时就会产生一个文件结构file，多次打开该文件就会产生多个文件结构。

  文件结构file如下图所示：
</code></pre>
</li>
</ul>
<p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img18.png" alt="img"></p>
<ul>
<li><p>文件表</p>
<pre><code>  文件表就是文件结构file集成的数组。文件表用于记录系统打开的文件（不能超过规定的系统最大打开文件数）

  文件表存在于内存当中。每当系统初始化后（主文件系统已挂载），系统内存将会申请文件表所需的空间，并为数组的每一个元素置NULL，直到有文件被打开时，文件表会填写相应的文件结构file并返回下标（一般来说下表0被留给标准输入、1被留给标准输出、2被留给标准错误）。
</code></pre>
</li>
<li><p>inode缓冲队列</p>
<pre><code>  每一个被挂载的分区都会初始化自己的indoe缓冲队列，它是该分区所有被打开的文件inode组成的缓冲队列（同一个文件被打开多次的情况下，也只会有唯一一个inode存在该队列，只不过该inode上记载着被打开的次数）

  inode缓冲队列也是存在于内存当中。
</code></pre>
</li>
<li><p>文件描述符</p>
<pre><code>  每一个PCB（进程控制块）都会有一个文件描述符数组，用于记录该进程打开的文件（不能超过规定的进程最大打开文件数）。

  该文件描述符数组存储的元素即是相对应的文件结构在文件表中的下标
</code></pre>
</li>
</ul>
<p>当一个进程需要打开一个新文件时会经历如下步骤：</p>
<pre><code>    1. 进程提供新文件的inode号作为参数调用函数

    2. 检测inode缓冲队列中是否存在该inode，如果存在则inode记录的文件打开次数加一，如果不存在则从硬盘里寻找该inode并加入缓冲队列
    
    3. 从文件表file_table中获取一个空闲位,并填入新构建的文件结构file(指向inode),然后返回该文件结构在文件表中的下标

    4. 进程PCB取得下标，存储在文件描述符数组中，并返回对应的文件描述符数组下标（即文件描述符）

    5. 调用函数结束，取得一个文件描述符
</code></pre>
<p>当一个进程需要修改一个已经打开的文件时会经历如下步骤：</p>
<pre><code>    1. 进程提供 需要修改文件的 文件描述符 作为参数调用函数

    2. 根据文件描述符在PCB中寻找到对应文件结构在文件表里的下标

    3. 根据下标在文件表里取得对应的文件结构

    4. 根据文件结构在inode缓冲队列里找到对应的inode

    5. 根据inode的块指针修改磁盘上对应空间的数据
</code></pre>
<h2 id="文件检索的关键-和"><a href="#文件检索的关键-和" class="headerlink" title="文件检索的关键 . 和 .."></a>文件检索的关键 . 和 ..</h2><p>任何一个目录下都需要两个子目录 . 和 ..</p>
<p>. 代表当前目录， .. 代表父目录，二者有助于文件系统的导航</p>
<p>具体的实现就是在当前目录下的目录项中将.和..添加进去</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><pre><code>/* 分区结构:一个分区就是一个文件系统 */
struct partition &#123;
    uint32_t start_lba;		    // 起始扇区
    uint32_t sec_cnt;		    // 扇区数
    struct disk* my_disk;	    // 分区所属的硬盘
    struct list_elem part_tag;	// 用于队列中的标记，用于将分区形成链表进行管理
    char name[8];		        // 分区名称

    struct super_block* sb;	    // 本分区的超级块
    struct bitmap block_bitmap;	// 块位图
    struct bitmap inode_bitmap;	// inode位图
    struct list open_inodes;	// 本分区打开的inode缓冲队列
&#125;;

/* 超级块：文件系统元信息的配置文件 */
struct super_block &#123;
    uint32_t magic;		            // 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型

    uint32_t sec_cnt;		        // 本分区总共的扇区数
    uint32_t inode_cnt;		        // 本分区中inode数量
    uint32_t part_lba_base;	        // 本分区的起始lba地址

    uint32_t block_bitmap_lba;	    // 块位图本身起始扇区地址
    uint32_t block_bitmap_sects;    // 扇区位图本身占用的扇区数量

    uint32_t inode_bitmap_lba;	    // i结点位图起始扇区lba地址
    uint32_t inode_bitmap_sects;	// i结点位图占用的扇区数量

    uint32_t inode_table_lba;	    // i结点表起始扇区lba地址
    uint32_t inode_table_sects;	    // i结点表占用的扇区数量

    uint32_t data_start_lba;	    // 数据区开始的第一个扇区号
    uint32_t root_inode_no;	        // 根目录所在的I结点号
    uint32_t dir_entry_size;	    // 目录项大小

    uint8_t  pad[460];		        // 加上460字节,凑够512字节1扇区大小
    
&#125; __attribute__ ((packed));

/* inode：文件的实质 */
struct inode &#123;
    uint32_t i_no;                  // inode编号

    uint32_t i_size;                //当此inode是普通文件时,i_size是指普通文件大小
                                    //若此inode是目录,i_size是指该目录下所有目录项大小之和*/

    uint32_t i_open_cnts;           // 记录此文件被打开的次数
    bool write_deny;	            // 写文件不能并行,进程写文件前检查此标识
                        
    uint32_t i_sectors[13];         // i_sectors[0-11]是直接块,
                                    // i_sectors[12]用来存储一级间接块指针
    struct list_elem inode_tag;     //用于文件缓冲队列中
&#125;;

/* 文件结构 */
struct file
&#123;
    uint32_t fd_pos;        // 记录当前文件操作的偏移地址，文件尾为-1
    uint32_t fd_flag;       // 文件操作标识符
    struct inode *fd_inode;
&#125;;

/* 目录结构 */
struct dir &#123;
    struct inode* inode;   
    uint32_t dir_pos;	    // 记录在目录内的偏移
    uint8_t dir_buf[512];   // 目录的数据缓存
&#125;;

/* 目录项结构 */
struct dir_entry &#123;
    char filename[MAX_FILE_NAME_LEN];   // 普通文件或目录名称
    uint32_t i_no;		                // 普通文件或目录对应的inode编号
    enum file_types f_type;	            // 文件类型
&#125;;
</code></pre>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><h2 id="fs-fs-c"><a href="#fs-fs-c" class="headerlink" title="fs&#x2F;fs.c"></a>fs&#x2F;fs.c</h2><pre><code>//------------------------文件系统初始化相关函数---------------------------------------

/*
@brief: 在磁盘上搜索文件系统，落没有则格式化分区创建文件系统
@detail:1.遍历整个磁盘，对每个已存在的分区创建文件系统
        2.挂载默认分区
        3.将当前分区的根目录打开
        4.初始化文件表
@param: 无
@retval:无
*/
void filesys_init();

/*
@brief: 初始化part分区的元信息,创建文件系统
@detail:初始化超级块、空闲块位图、inode位图、inode数组、根目录并全部写入磁盘
@param: 略
@retval:无
*/
static void partition_format(struct partition* part);

/*
@brief: 挂载名为part_name(arg)的分区
@detail:将硬盘中的超级块、空闲块位图、inode位图全部读取到内存中
        给cur_part赋值
@param: 略
@retval:无
*/
static bool mount_partition(struct list_elem *pelem, int arg);

//------------------------文件系统初始化相关函数---------------------------------------


//------------------------路径解析相关函数-----------------------

/*
@brief: 将最上层路径名称解析出来，存储到name_store,并返回子路径
@param: 略
@retval:无
*/
static char *path_parse(char *pathname, char *name_store);

/*
@brief: 返回路径深度
@param: 略
@retval:无
*/
int32_t path_depth_cnt(char *pathname);

/*
@brief: 搜索文件路径pathname,找到则返回其inode号,否则返回-1
@param: search_record:记录搜索过程中的父路径
@retval:无
@PS：   调用该函数后，会打开目标文件的父目录，并不会关闭，需要调用者关闭该目录
*/
static int search_file(const char *pathname, struct path_search_record *searched_record);

//------------------------路径解析相关函数-----------------------


//-------------------------系统调用-普通文件相关-------------------------

/*
@brief: 打开或创建普通文件
@detail：   1.先搜索该普通文件是否存在
            2.存在则打开，不存在则创建并打开
@param: flags:文件操作标识符
@retval:成功后,返回文件描述符,否则返回-1
*/
int32_t sys_open(const char *pathname, uint8_t flags);

/*
@brief: 关闭文件描述符fd指向的文件
@detail：   1.调用file_close()关闭普通文件;
            2.PCB-&gt;fd_table[fd]=-1;令文件描述符对应的数组可用
@param: flags:文件操作标识符
@retval:成功返回0,否则返回-1
*/
int32_t sys_close(int32_t fd)

/*
@brief: 将buf中连续count个字节写入文件描述符fd
@param: 略
@retval:成功则返回写入的字节数,失败返回-1
*/
int32_t sys_write(int32_t fd, const void *buf, uint32_t count);

/*
@brief: 从文件描述符fd指向的文件中读取count个字节到buf
@param: 略
@retval:若成功则返回读出的字节数,到文件尾则返回-1
*/
int32_t sys_read(int32_t fd, void *buf, uint32_t count);

/*
@brief: 重置用于文件读写操作的偏移指针(重置为:offset+文件指针位置)
@param: whence:文件指针位置标识符
        offset:相对于文件指针位置的偏移量
@retval:成功时返回新的偏移量,出错时返回-1
*/
int32_t sys_lseek(int32_t fd, int32_t offset, uint8_t whence);

/*
@brief: 删除普通文件(普通文件已打开则删除失败)
@param: 略
@retval:成功返回0,失败返回-1 
*/
int32_t sys_unlink(const char *pathname);
//-------------------------系统调用-普通文件相关-------------------------


//-------------------------系统调用-目录文件相关-------------------------

/*
@brief: 创建目录文件(并不打开)
@detail:1.申请inode位图，并同步到磁盘
        2.申请block位图，并同步到磁盘(先分配一个块就够用)
        3.往inode指向的数据块写入目录项&#39;.&#39;和&#39;..&#39;
        4.要将本目录的inode初始化，并同步到磁盘(无需申请内存空间)
        5.将关于本目录的目录项写入父目录数据块(写入磁盘)
        6.父目录inode更新大小并同步到磁盘
@param: pathname:目录文件路径
@retval:成功返回0,失败返回-1 
*/
int32_t sys_mkdir(const char *pathname);

/*
@brief: 打开目录文件，并返回目录指针
@detail:调用dir_open()来打开目录
        （目录打开只涉及part-&gt;open_inodes不涉及文件表、文件描述符数组等）
@param: 略
@retval:成功返回目录指针,失败返回-1 
*/
struct dir *sys_opendir(const char *name);

/*
@brief: 关闭目录
@detail:调用dir_close()来关闭目录
@param: 略
@retval:成功返回0,失败返回-1
*/
int32_t sys_closedir(struct dir *dir);

/*
@brief: 根据dir当前偏移位置，读取一个目录项，并更新偏移位置(调用dir_read()实现)
@param: 略
@retval:成功后返回其目录项地址,到目录尾时或出错时返回NULL
*/
struct dir_entry *sys_readdir(struct dir *dir);

/*
@brief: 把目录dir的指针dir_pos置0
@param: 略
@retval:无
*/
void sys_rewinddir(struct dir *dir);

/*
@brief: 删除空目录(调用dir_remove()实现)
@param: 略
@retval:成功时返回0,失败时返回-1
*/
int32_t sys_rmdir(const char *pathname);
//-------------------------系统调用-目录文件相关-------------------------


//-------------------------系统调用-cwd相关-------------------------

/*
@brief: 获得父目录的inode编号(利用目录项目&#39;..&#39;)
@param: 略
@retval:无
*/
static uint32_t get_parent_dir_inode_nr(uint32_t child_inode_nr, void *io_buf);

/*
@brief: 在inode编号为p_inode_nr的目录中查找inode编号为c_inode_nr的子目录的名字，将名字存入缓冲区path. 
@param: 略
@retval:成功返回0,失败返-1
*/
static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char *path, void *io_buf);

/*
@brief: 把当前工作目录绝对路径写入buf, size是buf的大小. 
@detail:根据PCB-&gt;cwd_inode_nr一层层向上追溯求得当前工作目录路径
@param: 略
@retval:成功返回buf,失败返NULL
*/
char *sys_getcwd(char *buf, uint32_t size);

/*
@brief: 更改当前工作目录为绝对路径path 
@detail:实质是修改PCB-&gt;cwd_inode_nr
@param: 略
@retval:成功则返回0,失败返回-1
*/
int32_t sys_chdir(const char *path);
//-------------------------系统调用-cwd相关-------------------------


//-------------------------系统调用-文件属性相关-------------------------
/*
@brief: 在buf中填充文件结构相关信息 
@param: 略
@retval:成功时返回0,失败返回-1
*/
int32_t sys_stat(const char *path, struct stat *buf);

//-------------------------系统调用-文件属性相关-------------------------


//------------------------转换函数----------------------
/*
@brief: 将文件描述符转化为文件表的下标
@param: 略
@retval:无
*/
static uint32_t fd_local2global(uint32_t local_fd);

//------------------------转换函数----------------------
</code></pre>
<h2 id="fs-dir-c"><a href="#fs-dir-c" class="headerlink" title="fs&#x2F;dir.c"></a>fs&#x2F;dir.c</h2><pre><code>/*
@brief: 打开根目录
@detail:1.利用inode_open()打开根目录
        2.并给root_dir赋值
@param: 略
@retval:无
*/
void open_root_dir(struct partition *part);

/*
@brief: 在分区part上打开节点号为inode_no的目录并返回目录指针 
@detail:1.利用inode_open()打开目录文件
        2.给目录结构pdir申请空间，初始化并返回
        （目录打开只涉及part-&gt;open_inodes不涉及文件表、文件描述符数组等）
@param: 略
@retval:无
*/
struct dir *dir_open(struct partition *part, uint32_t inode_no);

/*
@brief: 关闭目录
@detaili:1.利用inode_close()关闭目录，根目录不能被关闭
        2.释放目录结构dir的空间
@param: 略
@retval:无
*/
void dir_close(struct dir *dir);

/*
@brief: 在目录中寻找指定目录项
@detail:在part分区内的pdir目录内寻找包含name文件或目录的目录项
@param: 略
@retval:找到后返回true并将其目录项存入dir_e,否则返回false
*/
bool search_dir_entry(struct partition *part, struct dir *pdir, const char *name, struct dir_entry *dir_e);

/*
@brief: 在内存中初始化目录项p_de
@param: 略
@retval:无
*/
void create_dir_entry(char *filename, uint32_t inode_no, uint8_t file_type, struct dir_entry *p_de);

/*
@brief:     将目录项p_de写入父目录parent_dir中(直接写入磁盘)
@param:     io_buf:主调函数提供的缓冲区
@retval:    成功返回true，失败返回false
@PS：       父目录的inode.size更改过了，但并没有同步到磁盘的inode_table里！！
            调用者要负责把父目录的inode同步到磁盘
*/
bool sync_dir_entry(struct dir *parent_dir, struct dir_entry *p_de, void *io_buf);

/*
@brief: 把分区part目录pdir中关于inode_no的目录项删除（会将更新过的父目录inode写入磁盘）
@param: 略
@retval:成功返回true，失败返回false
*/
bool delete_dir_entry(struct partition *part, struct dir *pdir, uint32_t inode_no, void *io_buf);

/*
@brief: 根据dir当前偏移位置，读取一个目录项，并更新偏移位置
@param: 略
@retval:成功返回目录项，失败返回NULL
*/
struct dir_entry *dir_read(struct dir *dir);

/*
@brief: 判断目录是否为空
@detail:目录为空则代表目录中只含有.和..两个目录项
@param: 略
@retval:空返回true,非空返回false
*/
bool dir_is_empty(struct dir *dir);

/*
@brief: 移除目录child_dir
@detail:1.调用delete_dir_entry在父目录中移除本目录的目录项
        2.调用inode_release()回收本目录的inode
@param: 略
@retval:成功返回目录项，失败返回NULL
*/
int32_t dir_remove(struct dir *parent_dir, struct dir *child_dir);
</code></pre>
<h2 id="fs-inode-c"><a href="#fs-inode-c" class="headerlink" title="fs&#x2F;inode.c"></a>fs&#x2F;inode.c</h2><pre><code>/*
@brief: 打开并返回part分区里目标inode节点
        两个重要的功能：一个是打开inode、一个是返回inode节点
@detail:1.现在inode缓冲区队列中寻找该inode，若已打开则增加inode-&gt;i_open_cnts并返回inode
        2.没找到就去磁盘中寻找该inode读取到内存里，并放到inode缓冲区队列，返回inode
@param: part:目标分区
        inode_no:要打开的inode节点的i_no号
@retval:无
*/
struct inode *inode_open(struct partition *part, uint32_t inode_no);

/*
@brief: 关闭inode
@detail:1.减少inode-&gt;i_open_cnts
        2.inode-&gt;i_pen_cnts减少后若为0，则将从inode缓冲队列里去除，并释放为inode分配的空间
@param: 略
@retval:无
*/
void inode_close(struct inode *inode)

/*
@brief: 初始化new_inode，为其赋值
@param: 略
@retval:无
*/
void inode_init(uint32_t inode_no, struct inode *new_inode)


/*
@brief: 定位inode在扇区的位置
@detail:在part里获取inode所在的扇区和扇区内的偏移量并存到inode_pos中
@param: 略
@retval:无
*/
static void inode_locate(struct partition *part, uint32_t inode_no, struct inode_position *inode_pos);

/*
@brief: 将inode写入到磁盘的分区part中
@param: 略
@retval:无
*/
void inode_sync(struct partition *part, struct inode *inode, void *io_buf);


/*
@brief: 回收inode
@detail:1.回收分配给inode的所有block(修改block_bitmap)
        2.回收inode(修改inode_bitmap)
        3.调用inode_delete删除硬盘上的inode数据（可以不用这步）
        4.确保该inode完全关闭
@param: 略
@retval:无
*/
void inode_release(struct partition *part, uint32_t inode_no);

/*
@brief: 将硬盘分区part上的对应的inode清除(修改磁盘上的inode_table)
@param: inode_no:要清楚的inode号
@retval:无
*/
void inode_delete(struct partition *part, uint32_t inode_no, void *io_buf);
</code></pre>
<h2 id="fs-file-c"><a href="#fs-file-c" class="headerlink" title="fs&#x2F;file.c"></a>fs&#x2F;file.c</h2><pre><code>//------------------------文件表 文件描述符数组 相关操作-----------------------

/*
@brief: 从文件表file_table中获取一个空闲位
@param: 无
@retval:成功返回文件表下标,失败返回-1 
@PS:如果file_table[fd_idx].fd_inode == NULL，则判断文件结构可用
*/
int32_t get_free_slot_in_global(void);

/*
@brief: 将全局描述符(文件表下标)安装到进程或线程自己的文件描述符数组fd_table中 
@param: globa_fd_idx:文件表的下标（全局文件描述符）
@retval:成功返回文件描述符(文件描述符数组的下标),失败返回-1
*/
int32_t pcb_fd_install(int32_t globa_fd_idx);

//------------------------文件表 文件描述符数组 相关操作-----------------------


//---------------------------位图操作-------------------------
/*
@brief: 从inode位图里分配一个inode结点 (内存操作)
@param: 略
@retval:返回节点号i_no(就是inode在位图中的位置)
*/
int32_t inode_bitmap_alloc(struct partition *part);

/*
@brief: 从block位图里分配1个空闲块(1扇区),返回其扇区地址(内存操作)
@param: 略
@retval:略
*/
int32_t block_bitmap_alloc(struct partition *part);

/*
@brief: 同步内存里的位图结构到磁盘上
@detail:将内存中bitmap第bit_idx位所在的512字节同步到硬盘
@param: btmp_type:标识是inode位图还是block位图
@retval:略
*/
void bitmap_sync(struct partition *part, uint32_t bit_idx, uint8_t btmp_type);
//---------------------------位图操作-------------------------


//-------------------------------普通文件相关操作--------------------------------
/*
@brief: 创建并打开普通文件(磁盘操作)
@detail:1.创建new_inode(修改inode位图、inode分配内存、inode初始化)
        2.修改父目录(对应目录项写入父目录(写入磁盘)，修改父目录inode.size)
        3.同步 父目录inode、new_inode、inode位图
        4.打开该文件(添加到file_table、PCB中的fd_table、Part中的open_inodes)
@param: flag:文件操作标识符
@retval:成功则返回文件描述符,否则返回-1
*/
int32_t file_create(struct dir *parent_dir, char *filename, uint8_t flag);

/*
@brief: 打开编号为inode_no的inode对应的普通文件
@detail:1.修改file_table
        2.修改PCB-&gt;fd_table
        3.调用inode_open()修改part-&gt;open_inodes
@param: 略
@retval:成功则返回文件描述符,否则返回-1
*/
int32_t file_open(uint32_t inode_no, uint8_t flag);

/*
@brief: 关闭文件结构
@detail:1.调用inode_close()修改part-&gt;open_inodes
        2. file-&gt;fd_inode = NULL; 使文件结构可用
@param: file:要关闭的文件结构
@retval:失败返回-1，成功返回0
@PS:没有将PCB中的文件描述符数组对应位置-1！！！
    调用者要负责将PCB-&gt;fd_table[]置-1
*/
int32_t file_close(struct file *file);

/*
@brief: 把buf中的count个字节写入file
@param: 略
@retval:成功则返回写入的字节数,失败则返回-1
*/
int32_t file_write(struct file *file, const void *buf, uint32_t count);

/*
@brief: 从文件file中读取count个字节写入buf
@param: 略
@retval:返回读出的字节数,若到文件尾则返回-1
*/
int32_t file_read(struct file *file, void *buf, uint32_t count);
//-------------------------------普通文件相关操作--------------------------------
</code></pre>
<h1 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a>关键函数说明</h1><h2 id="文件系统初始化函数"><a href="#文件系统初始化函数" class="headerlink" title="文件系统初始化函数"></a>文件系统初始化函数</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img6.png" alt="img"></p>
<h2 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img4.png" alt="img"></p>
<h2 id="工作路径相关函数"><a href="#工作路径相关函数" class="headerlink" title="工作路径相关函数"></a>工作路径相关函数</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img5.png" alt="img"></p>
<h2 id="fs-file-c-file-create"><a href="#fs-file-c-file-create" class="headerlink" title="fs&#x2F;file.c&#x2F;file_create()"></a>fs&#x2F;file.c&#x2F;file_create()</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img8.png" alt="img"></p>
<h2 id="fs-file-c-file-write"><a href="#fs-file-c-file-write" class="headerlink" title="fs&#x2F;file.c&#x2F;file_write()"></a>fs&#x2F;file.c&#x2F;file_write()</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img9.png" alt="img"></p>
<h2 id="fs-file-c-file-read"><a href="#fs-file-c-file-read" class="headerlink" title="fs&#x2F;file.c&#x2F;file_read()"></a>fs&#x2F;file.c&#x2F;file_read()</h2><p><img src="/img/SimpleOS-7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/img10.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/31/SimpleOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/31/SimpleOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">SimpleOS-内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-31 09:31:53" itemprop="dateCreated datePublished" datetime="2023-12-31T09:31:53+08:00">2023-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-09-12 10:19:39" itemprop="dateModified" datetime="2024-09-12T10:19:39+08:00">2024-09-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整体设计方案"><a href="#整体设计方案" class="headerlink" title="整体设计方案"></a>整体设计方案</h1><p>内存管理模块整体方案如下：</p>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img6.png" alt="img"></p>
<p>物理内存池划分如下：</p>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img1.png" alt="img"></p>
<p>虚拟内存池划分如下：</p>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img2.png" alt="img"></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><pre><code>//物理内存池
struct pool&#123;
    struct bitmap pool_bitmap;  //物理内存池位图
    uint32_t phy_addr_start;    //管理空间起始地址
    uint32_t pool_size;         //管理空间长度

    struct lock lock;           //进程申请物理内存时需要上锁
&#125;;

//虚拟内存池
struct virtual_addr&#123;
    struct bitmap vaddr_bitmap; //虚拟内存池位图
    uint32_t vaddr_start;       //管理空间起始地址
&#125;;

/* 内存块 */
struct mem_block &#123;
    struct list_elem free_elem;
&#125;;

/* 内存块描述符 */
struct mem_block_desc &#123;
    uint32_t block_size;		 // 内存块大小
    uint32_t blocks_per_arena;	 // 本arena中可容纳此mem_block的数量.
    struct list free_list;	 // 目前可用的mem_block链表
&#125;;

/* 内存仓库arena元信息 */
struct arena &#123;
    struct mem_block_desc* desc;	 // 此arena关联的mem_block_desc
    uint32_t cnt;
    bool large;		                // large为ture时,cnt表示的是页框数。否则cnt表示空闲mem_block数量
&#125;;
</code></pre>
<p><img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img5.png" alt="img"></p>
<p>内存池提供以页为单位的内存空间<br>对于每一页内存空间都由元信息arena来组织，并将剩余空间切分成小块<br>每一个元信息arena组织的内存仓库 都按照块的大小有着相应的mem_block_desc<br>由mem_block_desc中的free_list来串起所有同一大小的空闲内存块</p>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><ul>
<li><p>kernel&#x2F;memory.c</p>
<pre><code>  //-------------------------------------内存系统初始化相关函数---------------------------

  /*
  @brief: 初始化内存相关数据结构(内存池、内存仓库、内存块描述符)
  @param: 无
  @retval:无
  */
  void mem_init();

  /*
  @brief: 内存池初始化(物理内核内存池、物理用户内存池、虚拟内核内存池)
  @param: all_mem:物理内存总量
  @retval:无
  */
  static void mem_pool_init(uint32_t all_mem);

  /*
  @brief: 初始化内存块描述符数组(管理7种不同的内存块描述符(16、32、64、128、256、512、1024))
  @param: desc_array：要初始化的内存块描述符数组
  @retval:无
  */
  void block_desc_init(struct mem_block_desc* desc_array);

  //-------------------------------------内存系统初始化相关函数---------------------------

  //-------------------------------------内存分配相关函数---------------------------

  /*
  @brief: 分配pg_cnt页的内存空间
  @param: pf:内存池类型标识符(内核/用户)
          pg_nct:申请分配的页数
  @retval:成功返回起始虚拟地址,失败返回NULL
  */
  void* malloc_page(enum pool_flags pf,uint32_t pg_cnt);

  /*
  @brief: 向虚拟内存池申请pg_cnt页的空间
  @param: pf:内存池类型标识符(内核/用户)
          pg_nct:申请分配的页数
  @retval:成功返回起始虚拟地址,失败返回NULL
  */
  static void* vaddr_get(enum pool_flags pf,uint32_t pg_cnt);

  /*
  @brief: 向物理内核/用户内存池申请1页空间，
  @param: m_pool:申请的物理内存池(用户/内核)
  @retval:成功返回地址起点，失败返回-1
  */
  static void* palloc(struct pool* m_pool);

  /*
  @brief: 建立从虚拟地址到物理地址的映射(以页为单位)(建立相应的页表/页目录)
  @param: _vaddr:虚拟地址
          _page_phyaddr:物理地址
  @retval:无
  */
  static void page_table_add(void* _vaddr,void* _page_phyaddr);

  /*
  @brief: 给内核分配pg_cnt页内存，
  @param: 略
  @retval:成功则返回虚拟地址，失败返回NULL
  */
  void* get_kernel_pages(uint32_t pg_cnt);

  /*
  @brief: 给用户分配pg_cnt页内存，
  @param: 略
  @retval:成功则返回虚拟地址，失败返回NULL
  */
  void* get_user_pages(uint32_t pg_cnt);

  /*
  @brief: 在堆(即内存池)中申请size字节内存(灵活申请)
  @param: 略
  @retval:无
  */
  void* sys_malloc(uint32_t size);

  /*
  @brief: 给指定虚拟地址分配一页内存
  @param: pf:内存池表示符
          vaddr:指定虚拟地址
  @retval:成功则返回虚拟地址，失败返回NULL
  */
  void* get_a_page(enum pool_flags pf,uint32_t vaddr);
  //-------------------------------------内存分配相关函数---------------------------
              
  //-------------------------------------内存回收相关函数---------------------------

  /*
  @brief: 释放 内核/用户 内存池种以虚拟地址vaddr为起点的cnt个物理页框 
  @param: pf:内存池标识符
          _vaddr:要回收的虚拟地址
          pg_cnt:要回收的页数
  @retval:无
  */
  void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt);


  /*
  @brief: 将1张物理页回收到物理内存池，实质就是清除物理内存池中位图的位
  @param: pg_pyh_addr:要回收页的物理地址
  @retval:无
  */
  void pfree(uint32_t pg_phy_addr);

  /*
  @brief: 将以_vaddr起始的连续pg_cnt个虚拟页回收到虚拟内存池，实质就是清除虚拟内存池中位图的位
  @param: pf:内存池标识符
          _vaddr:要回收的虚拟地址
          pg_cnt:要回收的页数
  @retval:无
  */
  static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt)

  /*
  @brief: 解除页表中虚拟地址vaddr的映射,实质是将vaddr对应的pte存在位置0
  @param: 略
  @retval:无
  */
  static void page_table_pte_remove(uint32_t vaddr);

  /*
  @brief: 回收ptr指向的内存块(内存块大小由arena指出)
  @param: 略
  @retval:无
  */
  void sys_free(void* ptr);

  //-------------------------------------内存回收相关函数---------------------------

  //------------------------------工具函数-----------------------------------------

  /*
  @brief: 返回虚拟地址映射的物理地址 
  @param: 略
  @retval:略
  */
  uint32_t addr_v2p(uint32_t vaddr);

  /*
  @brief: 返回arena中第idx个内存块的地址
  @param: 略
  @retval:略
  */
  static struct mem_block* arena2block(struct arena* a, uint32_t idx);

  /*
  @brief: 返回内存块b所在的arena地址
  @param: 略
  @retval:略
  */
  static struct arena* block2arena(struct mem_block* b);

  /*
  @brief: 得到虚拟地址vaddr对应的pte指针
  @param: 略
  @retval:略
  */
  uint32_t* pte_ptr(uint32_t vaddr);

  /*
  @brief: 得到虚拟地址vaddr对应的pde指针
  @param: 略
  @retval:略
  */
  uint32_t* pde_ptr(uint32_t vaddr)

  //------------------------------工具函数-----------------------------------------
</code></pre>
</li>
</ul>
<h1 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a>关键函数说明</h1><ul>
<li><p>kernel&#x2F;memory.c&#x2F;内存分配相关函数</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img3.png" alt="img"></p>
</li>
<li><p>kernel&#x2F;memory.c&#x2F;内存回收相关函数</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img8.png" alt="img"></p>
</li>
<li><p>kernel&#x2F;memory.c&#x2F;page_table_add()</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img4.png" alt="img"></p>
</li>
<li><p>kernel&#x2F;memory.c&#x2F;sys_malloc()</p>
<p>  <img src="/img/SimpleOS-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img7.png" alt="img"></p>
</li>
</ul>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="pool-virtual-addr"><a href="#pool-virtual-addr" class="headerlink" title="pool-virtual_addr"></a>pool-virtual_addr</h2><h2 id="arena-mem-block-desc"><a href="#arena-mem-block-desc" class="headerlink" title="arena-mem_block_desc"></a>arena-mem_block_desc</h2><h1 id="工具图表"><a href="#工具图表" class="headerlink" title="工具图表"></a>工具图表</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/30/SimpleOS-Boot%E5%BC%95%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/30/SimpleOS-Boot%E5%BC%95%E5%AF%BC/" class="post-title-link" itemprop="url">SimpleOS-Boot引导</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-30 15:45:05" itemprop="dateCreated datePublished" datetime="2023-12-30T15:45:05+08:00">2023-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-10-10 19:12:46" itemprop="dateModified" datetime="2024-10-10T19:12:46+08:00">2024-10-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整体设计方案"><a href="#整体设计方案" class="headerlink" title="整体设计方案"></a>整体设计方案</h1><p><img src="/img/SimpleOS-2-Boot/img4.png" alt="img"></p>
<p>如图电脑的启动后接力棒的第一棒从BIOS开始，第二棒MBR负责把硬盘上的loader加载到内存里，第三棒loader处理完5个子功能后把接力棒正式交给内核。</p>
<p>我们在本模块所做的事，就是构建具备上述功能的MBR以及loader。</p>
<p>在了解MBR和loader的设计之前请先了解<a href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%8E%E7%AB%AF%E7%89%A9%E7%90%86%E5%86%85%E5%AD%981MB%E5%B8%83%E5%B1%80">实模式下低端物理内存1MB的布局</a></p>
<h2 id="MBR设计"><a href="#MBR设计" class="headerlink" title="MBR设计"></a>MBR设计</h2><p>MBR只需要负责加载loader到相应位置即可</p>
<p>MBR的程序代码分为三个部分：</p>
<ol>
<li><p>寄存器初始化（包括栈顶指针初始化）</p>
</li>
<li><p>调用函数loader_ready_proc()（寄存器传参）</p>
<p> PS：请先了解<a href="#lba28%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">LBA28相关知识</a></p>
</li>
<li><p>loader_ready_proc()的具体实现（功能是装载loader,也就是把loader写入磁盘相应位置）</p>
<p> PS：请先了解<a href="#%E7%A3%81%E7%9B%98%E5%86%99%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">磁盘写入相关知识</a></p>
</li>
<li><p>保证MBR一共512字节，并最后两字节必须是0x55和0xaa，使得BIOS能够检测并识别</p>
</li>
</ol>
<h2 id="loader设计"><a href="#loader设计" class="headerlink" title="loader设计"></a>loader设计</h2><p>loader要负责做的事情可多了，大致可分为六个部分</p>
<ol>
<li><p>数据段</p>
<p> loader程序的数据段里存放着GDT等重要数据结构，安排如下图所示</p>
<p> <img src="/img/SimpleOS-2-Boot/img22.png" alt="img"></p>
</li>
<li><p>计算内存大小并存储到0xb00（也就是total_men_bytes标号处）</p>
<p> 我们模仿Linux获取内存的方法，调用BIOS中断0x15的三个子功能（0xe820、0xe801、0x88）去获取内存（一种失败了就接着使用另外一种，直到成功）</p>
<p> 0xb00则是我们安排在loader.S数据段的一个固定位置,当然如果你喜欢也可以存放在其他位置。</p>
<p> 注意：我们使用BIOS中断0x15时，该中断会以ARDS数据结构（描述内存段大小的信息）的形式，返回数个ARDS，所以我们需要在loader.S中划分一块缓冲区用于临时存放返回的ARDS</p>
</li>
<li><p>从实模式切换到保护模式</p>
<p> PS：请先了解<a href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">保护模式相关知识点</a>,以及<a href="#%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F">如何从实模式进入保护模式</a></p>
</li>
<li><p>构建内核页表页目录，开启分页机制</p>
<p> PS：请先了解<a href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6">分页机制</a></p>
<p> 我们所要建立的满足可以自举证的分页模型如下图所示</p>
<p> <img src="/img/SimpleOS-2-Boot/img11.png" alt="img"></p>
<ol>
<li><p>物理空间中低端1MB用于存放内核代码，紧接着0x100000~0x200000这1MB空间用于存放255个页表+1个页目录，每个页表&#x2F;页目录都刚好是一个4KB自然页大小，每个页表项&#x2F;页目录项则占4字节大小</p>
</li>
<li><p>虚拟空间<code>0x00~0x100000</code>和<code>0xc0000000~0xc0100000</code>两个区间都被映射到物理空间的低端1MB内核代码区间</p>
</li>
<li><p>PD[1023]指向页目录本身，为的是实现在开启分页机制后还能正确访问页表和页目录</p>
<p> 如果虚地址高10位全为1、虚地址中10位全为0，就把PD[0]当成自己的页表项，最终指向物理页地址0x101000<br> 如果虚地址高10位全为1、虚地址中10位全为1，就把PD[1023]当成自己的页表项,最终指向物理页地址0x100000<br> 如果虚地址高10位全为1、虚地址中10位处于一定范围内，就把PD[768]~PD[1022]当成自己的页表项目，最终指向物理地址0x101000及以上空间</p>
<p> 总结出不变的规律：</p>
<ul>
<li>要获取页目录表物理地址：让虚位高20位地址全为1，低12位全为0，即0xfffff000。这就是页目录自身的起始物理地址</li>
<li>要访问页目录中的页目录项，即获取页表物理地址：使虚拟地址为0xfffffxxx,其中xxx是页目录项的索引*4</li>
<li>访问页表中的页表项:虚拟地址公式为 0x3ff&lt;&lt;22+中间10位&lt;&lt;12+低12位（中间10位是页表的索引，低12位为页表内的偏移地址）</li>
</ul>
</li>
</ol>
</li>
<li><p>加载kernel到内存中</p>
<p> 将硬盘从0x9开始占据200扇区的kernel代码读取到内存0x70000起始处</p>
</li>
<li><p>初始化kernel</p>
<p> PS：请先了解<a href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96">加载并初始化内核相关知识</a>以及<a href="#elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">elf文件格式</a></p>
</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>无</p>
<h1 id="函数表"><a href="#函数表" class="headerlink" title="函数表"></a>函数表</h1><ul>
<li><p>boot&#x2F;mbr.S</p>
<pre><code>  /*
  @brief: 该函数负责把磁盘上的loader装载到内存里(汇编函数/寄存器传参)
  @param: loader_start_sector是loader的LBA28扇区地址
          loader_base_addr是内存起始地址
          sector_cnt是移动的扇区数目
  @retval:无
  */
  void loader_ready_proc(loader_start_sector,loader_base_addr,sector_cnt);
</code></pre>
</li>
<li><p>boot&#x2F;loader.S</p>
<pre><code>  /*
  @brief: 该函数负责5件事分布如下：(汇编函数)
          1. 计算内存并存储到0xb00
          2. 从实模式到保护模式
          3. 构建内核页表页目录，开启分页机制
          4. 加载kernel到内核中
          5. 初始化kernel
  @param: 无
  @retval:无
  */
  void loader_start();
</code></pre>
</li>
</ul>
<h1 id="关键函数说明"><a href="#关键函数说明" class="headerlink" title="关键函数说明"></a>关键函数说明</h1><p>无</p>
<h1 id="背景知识-工具图表"><a href="#背景知识-工具图表" class="headerlink" title="背景知识&#x2F;工具图表"></a>背景知识&#x2F;工具图表</h1><h2 id="实模式下低端物理内存1MB布局"><a href="#实模式下低端物理内存1MB布局" class="headerlink" title="实模式下低端物理内存1MB布局"></a>实模式下低端物理内存1MB布局</h2><p><img src="/img/SimpleOS-2-Boot/img46.png" alt="img"></p>
<ol>
<li><p>我们整个SimpleOS的代码实际上只会装载到<code>0x500~0x9FBFF</code>这块内存区间（包括两块空闲的可用区域，和一块由BIOS确定的MBR区域）</p>
</li>
<li><p>512字节的MBR将会被BIOS强制装载到<code>0x7C00~0x7DFF</code>，（MBR只负责加载loader，运行过一次就没用了，之后可以被其他代码覆盖）</p>
</li>
<li><p>2048字节的loader规划在可用区间<code>0x900~0x1100</code>（loader是内核的起点，安排在离0x500近一点的地方，为之后的内核文件腾出足够的空间。至于和0x500之间存在的一点间隔存储个人决策，可以忽略）</p>
</li>
<li><p>200扇区kernel.bin，将其装载在<code>0x70000~0x89000</code>可用区域,（内核代码应该装载在可用空间的尽可能高位，为内核映像文件腾出位置）</p>
</li>
<li><p>保护模式下一些虚地址分配</p>
<ul>
<li><p>0xc0001500(虚地址)作为内核代码的入口</p>
</li>
<li><p>一般来说可用空间的上界限0xc009fc00是最好的栈顶，但是为了让内存的每一块都形成4KB的自然页，所以栈顶最好取4KB的整数倍，因此栈顶设置为<code>0xc009f000</code></p>
</li>
<li><p><code>0xc009e000~0xc009f000</code>4KB空间分配给内核主线程PCB</p>
</li>
<li><p><code>0xc009a000~0xc009e000</code>这四个页的空间(可管理一共512MB空间)大小全给位图(物理内核内存池位图、物理用户内存池位图、虚拟内核内存池位图)</p>
</li>
</ul>
</li>
</ol>
<h2 id="LBA28相关知识"><a href="#LBA28相关知识" class="headerlink" title="LBA28相关知识"></a>LBA28相关知识</h2><p>LBA28是用28位比特来描述一个扇区的地址的一种方式</p>
<p>其中前24位分别写在3个8位寄存器LBAlow、LBAmid、LBAhigh，最后4位写在device寄存器里</p>
<h2 id="磁盘写入相关知识"><a href="#磁盘写入相关知识" class="headerlink" title="磁盘写入相关知识"></a>磁盘写入相关知识</h2><h3 id="硬盘并行接口-PATA"><a href="#硬盘并行接口-PATA" class="headerlink" title="硬盘并行接口-PATA"></a>硬盘并行接口-PATA</h3><p>PATA接口的线缆也称IDE线</p>
<p>一个主盘提供了两个IDE插槽，这两个插槽称为两个通道，IDE0叫Primary通道，IDE1叫Secondary通道</p>
<p>每一个IDE线都可以挂载两块硬盘，一个主盘(master),一个从盘(slave)</p>
<h3 id="硬盘操作方法"><a href="#硬盘操作方法" class="headerlink" title="硬盘操作方法"></a>硬盘操作方法</h3><p>当我们要读取硬盘时，我们要先在控制寄存器里写入 读取命令字，然后才能从相关寄存器里读取到所需要的数据</p>
<p>而当我们需要写入硬盘时，我们要先在相关寄存器里写入数据，然后再向控制寄存器里写入 写入命令字，即完成写入</p>
<h3 id="硬盘控制器主要的端口寄存器"><a href="#硬盘控制器主要的端口寄存器" class="headerlink" title="硬盘控制器主要的端口寄存器"></a>硬盘控制器主要的端口寄存器</h3><p><img src="/img/SimpleOS-2-Boot/img2.png" alt="img"></p>
<p>Command Block registers用于向硬盘驱动器写入命令字或者从硬盘控制器里活得硬盘状态</p>
<p>Control Block registers用于控制硬盘状态</p>
<ol>
<li><p>data寄存器用于管理数据</p>
</li>
<li><p>Error寄存器用于记录失败时的错误信息&#x2F;Feature寄存器用于部分命令需要指定额外参数</p>
</li>
<li><p>Sector count寄存器用来指定带读取&#x2F;写入的扇区数目</p>
</li>
<li><p>3个8位的LBA寄存器用于记录LBA28地址的低24位（高4位记录在device寄存器）</p>
</li>
<li><p>Command寄存器用于写入操作时存放命令字，可使用命令字如下：</p>
<p> identify：0xEC （硬盘识别）<br> read sector：0x20 （读扇区）<br> write sector：0x30（写扇区）</p>
</li>
<li><p>device寄存器是杂项，status寄存器用于给出硬盘状态信息，具体信息见下图</p>
<p> <img src="/img/SimpleOS-2-Boot/img3.png" alt="img"></p>
</li>
</ol>
<h3 id="与端口交互的in-out指令"><a href="#与端口交互的in-out指令" class="headerlink" title="与端口交互的in&#x2F;out指令"></a>与端口交互的in&#x2F;out指令</h3><ol>
<li><p>in指令用于从端口中读取数据，格式如下：</p>
<pre><code> in al,dx
 in ax,dx
</code></pre>
<p> 只要使用in指令，源操作数必须是dx(存放端口号)，而目的操作数是用al，还是ax取决于dx端口指代的寄存器是8位宽还是16位宽</p>
</li>
<li><p>out 指令用于往端口中写数据，格式如下：</p>
<pre><code> out dx,al
 out dx,ax
 out 立即数,al
 out 立即数,ax
</code></pre>
<p> out指令的源操作数是ax还是al取决于目标端口指代的寄存器是8位宽还是16位宽，源操作数可以是立即数直接给出端口号，也可以用dx（存放端口号）</p>
</li>
</ol>
<h3 id="硬盘操作约定顺序"><a href="#硬盘操作约定顺序" class="headerlink" title="硬盘操作约定顺序"></a>硬盘操作约定顺序</h3><ol>
<li>先选择通道，往该通道的sector cout寄存器写入待操作的扇区数</li>
<li>往通道上的三个LBA写入扇区地址LBA28的低24位</li>
<li>往device写入LBA28的高4位，指定主从盘，并选择LBA寻址模式</li>
<li>第四步往该通道的command寄存器写入命令（一旦写入立即执行）</li>
<li>读取status寄存器，判断硬盘工作是否完成</li>
<li>将硬盘数据读出(如果是写硬盘则无需这步)</li>
</ol>
<h2 id="保护模式概述"><a href="#保护模式概述" class="headerlink" title="保护模式概述"></a>保护模式概述</h2><h3 id="为什么要有保护模式-实模式的缺点"><a href="#为什么要有保护模式-实模式的缺点" class="headerlink" title="为什么要有保护模式(实模式的缺点)"></a>为什么要有保护模式(实模式的缺点)</h3><ol>
<li><p>实模式下用户程序和操作系统同一等级，而且逻辑地址就是物理地址，用户程序可以随意修改段基址访问所有内存，不安全</p>
</li>
<li><p>实模式16位寄存器决定访问超过64KB的内存区域要切换段基址、麻烦</p>
</li>
<li><p>一次只能运行一个程序，无法充分利用计算机资源</p>
</li>
<li><p>只有20条地址线，最大可用内存的寻址范围只有1MB，不够用</p>
</li>
</ol>
<h3 id="保护模式的特点"><a href="#保护模式的特点" class="headerlink" title="保护模式的特点"></a>保护模式的特点</h3><ol>
<li><p>应用程序只能访问虚拟地址，虚拟地址由处理器和操作系统协作转换后才显示真正的物理地址</p>
</li>
<li><p>保护模式的运行环境是32位，寄存器、数据线、地址线也相应都被扩展到32位，指令格式也有了相应的扩展（允许32位源操作数）</p>
</li>
<li><p>保护模式不再使用中断向量表、段基址寄存器这些概念。取而代之的是段选择子寄存器、全局描述符、中断描述符表、各种门结构</p>
</li>
<li><p>保护模式引入了特权级的概念，应用程序不再和操作系统拥有同一特权级</p>
</li>
</ol>
<h3 id="保护模式的扩展"><a href="#保护模式的扩展" class="headerlink" title="保护模式的扩展"></a>保护模式的扩展</h3><ol>
<li><p>寄存器扩展：</p>
<p> <img src="/img/SimpleOS-2-Boot/img18.png" alt="img"></p>
<p> 保护模式下寄存器、地址线和数据总线都扩展到32位，内存寻址空间可达4GB，段内寻址空间也可达4GB。也就是说对内存的访问甚至可以让段基址&#x3D;0，只由一个记录偏移量的寄存器来访问内存，这也就是所谓的平坦模型</p>
<p> 另外一提：保护模式抛弃基址这个概念，而是在内存里放入一个全局描述符表，每一个表项都是一个段描述符，用来描述各个内存段的起始地址、大小、权限等信息。段寄存器保护的也不再是段基址了，而是“选择子”，选择子本质上就是全局描述符表中的索引，就像是数组下标一样的东西。</p>
</li>
<li><p>寻址扩展：</p>
<p> <img src="/img/SimpleOS-2-Boot/img19.png" alt="img"></p>
<p> 如图所示保护模式的寻址方式更加灵活多变，不仅在基址寄存器(所有通用寄存器都可)和变址寄存器(处理esp外的所有通用寄存器都可)有了更多选择外，还引入了比例因子</p>
</li>
<li><p>运行模式反转：</p>
<p> 由于32位CPU兼容保护模式和实模式，所以如果你在保护模式下使用实模式的命令，或者在实模式下使用保护模式的命令，都会触发运行模式反转，将会在二进制机器码前加上相应的反转前缀。</p>
<p> 注意：模式反转前缀只对单条指令有效，效果并非是全局的</p>
<pre><code> [bit 16] ;告诉编译器接下来的代码是实模式
 [bit 32] ;告诉编译器接下来的代码是保护模式
</code></pre>
<ul>
<li><p>操作数反转前缀 0x66</p>
<p>  <img src="/img/SimpleOS-2-Boot/img20.png" alt="img"></p>
<p>  如图上半部分是代码，下半部分是编译后的机器指令</p>
<p>  第三行在[bit 16]实模式下使用了eax，触发了保护模式转换，因此机器码前加了前缀0x66</p>
<p>  第五行在[bit 32]保护模式下使用了ax，触发了实模式转换，因此机器码前加了前缀0x66</p>
</li>
<li><p>寻址方式反转前缀 0x67</p>
<p>  <img src="/img/SimpleOS-2-Boot/img21.png" alt="img"></p>
<p>  第四行在[bit 16]实模式下同时使用了保护模式的32位源操作数和更加灵活的寻址方式，触发模式转换，机器码添加了前缀0x66、0x67</p>
</li>
</ul>
</li>
<li><p>指令扩展</p>
<p> 指令扩展后允许32位寄存器和32位源操作数</p>
</li>
</ol>
<h2 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h2><p>从实模式到保护模式我们要执行四个步骤：</p>
<ol>
<li><p>打开A20地址线</p>
</li>
<li><p>加载GDT</p>
</li>
<li><p>将CR0的PE位置1</p>
</li>
<li><p>使用jump指令更新流水线，避免指令出错</p>
</li>
</ol>
<p>对于这三个步骤的讲解请看下文</p>
<h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>到了保护模式下，内存段不再是简单用寄存器加载即可用，而是需要提前把段定义好才可使用。全局描述符就是用来存储对每个段描述的表，全局描述符中的每一个表项包含段描述符，段描述符就是对一个段的描述，64位段描述符格式如下：</p>
<p><img src="/img/SimpleOS-2-Boot/img12.png" alt="img"></p>
<ol>
<li><p>段基址：</p>
<p> 每个段都有32位的段基址，在段描述符中被拆分成三块存储。</p>
<p> 为什么被拆分成三块？为的是兼容，实模式下段基址是16位，80286有关短暂的24位段基址，而现在则是32位段基址，为了兼容原本应该连续存放的段基址被拆分为16-8-8的形式。</p>
<p> 当需要查看段基址时，硬件会把三个分散的段基址取出来并拼接在一起得到一个完整的32位段基址。</p>
<p> <strong>PS：现在知道为什么有那么多屎山代码了，为了兼容旧时代的程序，屎山代码将成为每一个持续发展产品的最终归宿！</strong></p>
</li>
<li><p>段界限：</p>
<p> 段界限表示段边界的扩展最值，20位段界限被拆分为两部分(当然又是为了兼容)。</p>
<p> 段界限是一个单位量，单位要么是1字节，要么是4KB(单位由G段决定)。也就是说段的最大寻址范围要么是1*2^20&#x3D;1MB；要么是2*12*2^20&#x3D;4GB。(注意寻址范围!&#x3D;空间)</p>
<p> 实际的段界限边界值&#x3D;(描述符中段界限+1)*(段界限的粒度大小：4KB&#x2F;1Byte)-1</p>
</li>
<li><p>S字段和type字段：</p>
<p> <img src="/img/SimpleOS-2-Boot/img13.png" alt="img">   </p>
<p> S字段只有1位：S&#x3D;0 则说明是系统段(凡是硬件允许需要用到的东西，程序入口、调用门之类);S&#x3D;1 则说明是非系统段(凡是软件运行需要的东西，数据、代码、栈都是数据段)</p>
<p> type字段有4位：type字段只有在S确认后才有意义，X区分代码段和数据段，R代表是否可读，W代表是否可写，C代表是否一致，E代表向上扩展(E&#x3D;0,低地址到高地址)或向下扩展(E&#x3D;1，高地址到低地址)，A代表是否被CPU读过（CPU访问过则置1）</p>
</li>
<li><p>DPL（Descriptor Privilege Level）</p>
<p> 2位的DPL字段表示特权级，特权级从0~3,数字越低特权级越高，操作系统是0级，一般应用程序是3级</p>
</li>
<li><p>P字段（Present）：</p>
<p> 1位P表示段是否存在，有时候内存不够时，保护模式下CPU可能会按页(4KB)的单位将内存换到磁盘里，此时相当于该段不存在，即P&#x3D;0;</p>
</li>
<li><p>AVL字段（Avaliable）:</p>
<p> 1位AVL字段代表该段是否可用，是否可用是对用户来说，对操作系统来说可随意访问此位</p>
</li>
<li><p>L字段：</p>
<p> 1位L字段，L&#x3D;1表示代码段是64位，L&#x3D;0表示代码段是32位，我们在32位地址下编程将其设置为0即可</p>
</li>
<li><p>D&#x2F;B字段：</p>
<p> 1位D&#x2F;B字段指定有效地址及操作数大小，对不同段的意义不同</p>
<ul>
<li><p>如果针对代码段，D&#x3D;0时指令中有效地址和操作数是16位，指令有效地址用IP寄存器；D&#x3D;1时指令中有效地址和操作数是32位，指令有效地址用EIP寄存器</p>
</li>
<li><p>如果针对栈段，B&#x3D;0时栈使用SP寄存器，栈最大寻址范围为2^16；B&#x3D;1时栈使用ESP寄存器，栈最大寻址范围为2^32</p>
</li>
</ul>
</li>
<li><p>G段：</p>
<p> 1位G段用来指定段界限的单位大小，G&#x3D;0时，段界限的单位时1字节；G&#x3D;1时，段界限的单位是4KB</p>
</li>
</ol>
<h3 id="全局描述符号GDT、选择子以及GDTR寄存器"><a href="#全局描述符号GDT、选择子以及GDTR寄存器" class="headerlink" title="全局描述符号GDT、选择子以及GDTR寄存器"></a>全局描述符号GDT、选择子以及GDTR寄存器</h3><ol>
<li><p>GDT(Global Descriptor Table)相当于是段描述符的数组，每一表项都是一个段描述符</p>
</li>
<li><p>选择子是什么？选择子由三部分组成，如下图：</p>
<p> <img src="/img/SimpleOS-2-Boot/img14.png" alt="img"></p>
<p> 0~1位用来存储RPL，即特权级；第2位是TI(Table Indicator)，用来表示选择子是GDT还是LDT的索引；3~5位是描述符的索引值，就是数组下表</p>
<p> <strong>PS：我们注意到索引一共是13位，也就是说一个GDT最多有2^13&#x3D;8192个表项</strong></p>
</li>
<li><p>LDT(Local Descriptor Table)是局部描述符，一个任务对应一个LDT，但它在现实中应用很少，我们的系统中也未用到LDT</p>
</li>
<li><p>GDTR(Global Descriptor Table Register)是用来指向GDT的寄存器，GDT存储在内存中，GDTR存储的则是GDT的地址。</p>
<p> <img src="/img/SimpleOS-2-Boot/img15.png" alt="img"></p>
<p> 如图所示是GDTR的结构，48位寄存器前16位是GDT以字节为单位的界限，后32位是GDT在内存中的起始地址</p>
<p> <strong>GDT界限范围有16位，也就是占有2^16个字节，而一个表项占有8字节，一个GDT一共可以存储2^16&#x2F;8&#x3D;8192个表项，和上面结论相符合</strong></p>
</li>
<li><p>ldgt(load Gloabal Descriptor Table)指令用来加载GPT，一般情况下从实模式进入保护模式我们需要使用命令ldgt来初始化GPTR，不仅如此，在保护模式中我们也可以使用ldgt命令来修改GPTR的值。ldgt的指令格式是：lgdt 48位内存数据</p>
</li>
<li><p>段描述符与内存的关系</p>
<p> <img src="/img/SimpleOS-2-Boot/img16.png" alt="img"></p>
<p> 如图可知，段描述符指向内存的各个地方。但是GDT的第0个段描述符是不可用的，因为GDT是用选择子来索引的，如果选择子忘记初始化就默认为0，这样选择子相当于索引到不可用的段描述符，而不会索引到其他内存空间。</p>
</li>
</ol>
<h3 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h3><ol>
<li><p>实模式下的地址回绕</p>
<p> 实模式下有20根地址线，也就是说最多可以索引1MB空间。实模式下我们用<code>16位段基址:16位偏移量</code>的形式来计算物理地址，我们发现假设16位段基址是0xFFFF，16位地址量是0xFFFF，最终计算得到的物理地址应该是：0xFFFF*16+0xFFFF&#x3D;0x10FFEF,我们发现这个地址已经超出了20位地址线所能传输的最大范围0xFFFFF。那当我们在实模式下访问超出0xFFFFF物理地址范围的空间时会发生什么事吗？其实并不会发生太糟糕的事，由于硬件原因，超出20位地址线的位将被舍弃，当你访问超过0x100000时就相当于访问0x00000,访问0x10FFEF时就相当于访问0x0FFEF。这个特点就叫做地址回绕。</p>
</li>
<li><p>32位CPU也要兼容地址回绕</p>
<p> 实模式下地址回绕的特性被许多程序员视为优点加以利用编程，但是保护模式却没有地址回绕这个问题。所以为了满足32位CPU必须兼容保护模式和实模式的特点，我们必须让32位CPU也要具备可以自由使用地址回绕的特点。</p>
<p> 我们知道32位CPU有32位的地址线，IBM在键盘控制器上的一些输出线来控制第21根地址线(A20)的有效性，成为A20Gate。</p>
<p> 如果A20Gate&#x3D;1，当访问0x100000~0x10FFEF之间的地址将会正常访问</p>
<p> 如果A20Gate&#x3D;0，当访问0x100000~0x10FFEF之间的地址将会触发地址回绕特性</p>
</li>
<li><p>打开A20地址线</p>
<p> 因此，当我们想从实模式进入保护模式时，我们必须打开A20Gate才能让保护模式的程序正常运行，打开A20地址总线的方式是将端口0x92的第一位置1，代码如下：</p>
<pre><code> in al,0x92
 or al,0000_0010B
 out 0x92,al
</code></pre>
</li>
</ol>
<h3 id="保护模式的开关-CRO寄存器的PE位"><a href="#保护模式的开关-CRO寄存器的PE位" class="headerlink" title="保护模式的开关,CRO寄存器的PE位"></a>保护模式的开关,CRO寄存器的PE位</h3><p>想从实模式进入保护模式，我们还差最后一步。控制寄存器CRx是CPU的窗口，既可以用来展示CPU内部状态，又可以用来控制CPU运行机制。这次我们要用到CR0寄存器的PE（Protection Eanble）位，CR0寄存器构造如下图所示：</p>
<p><img src="/img/SimpleOS-2-Boot/img17.png" alt="img"></p>
<p>右上方是CR0格式位，下方则是对每个位的描述，我们目前只需要关注PE位就行了，将PE位置1，让CPU知道我们要进入保护模式了，代码如下：</p>
<pre><code>mov eax,cr0
or eax,0x00000001
mov cr0,eax
</code></pre>
<h3 id="为什么使用远跳转指令来清空流水线"><a href="#为什么使用远跳转指令来清空流水线" class="headerlink" title="为什么使用远跳转指令来清空流水线"></a>为什么使用远跳转指令来清空流水线</h3><p>我们使用<code>jmp dword SELECTOR_CODE:p_mode_start</code>来更新流水线，究竟是为什么？</p>
<ol>
<li><p>段描述缓冲寄存器未更新</p>
<p> 32位CPU兼容保护模式和实模式，段缓存寄存器在实模式下和保护模式下都有用。实模式下：段描述缓冲寄存器用于缓存段基址，保护模式下：段描述缓冲寄存器缓存段描述符。只有当CPU重新引用一个段后，段描述缓冲寄存器才会更新。</p>
<p> 当我们从实模式到保护模式后，我们的段描述缓存寄存器存在的还是实模式下用的20位段基址，这当然是不行的。所以我们指令跳转到<code>SELECTOR_CODE:p_mode_start</code>相当于重新引用一个段，让它更新。</p>
</li>
<li><p>流水线中指令译码错误</p>
<p> 从实模式到保护模式，一开始我们是16位指令，后来是32位指令。因为CPU的流水线技术提前被加载进流水线的32位指令可能会被译码错误成16位指令。因此我们使用无条件跳转指令jmp,跳转过后会自动清空流水线，避免译码错误。</p>
</li>
<li><p>dword</p>
<p> dword则是让编译器将<code>p_mode_start</code>当成32位操作数处理保证得到正确的地址</p>
</li>
</ol>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><h3 id="为什么要分页？"><a href="#为什么要分页？" class="headerlink" title="为什么要分页？"></a>为什么要分页？</h3><p>我们只有4GB的内存空间，但我们想让每一个程序都拥有（或者以为自己拥有）4GB的内存空间，于是有了分页机制。</p>
<ol>
<li><p>分页机制是在内存分段的基础上进行的</p>
</li>
<li><p>分页机制的核心思想是：通过映射，可以使连续的线性地址与任意物理内存地址相关联，逻辑上连续的线性地址其对应的物理地址可以不连续</p>
</li>
<li><p>一个程序它申请4GB的内存空间，实际上它并不是每时每刻都需要全部的4GB内存空间，大部分时候它都只在使用其中一两小部分的内存空间。我们将该4GB的内存空间分成好多个等大小的块（页），然后根据一个映射规则将当前有用到的块映射到物理内存中，这样4GB的物理内存就可以同时被接受多个程序享用。</p>
</li>
</ol>
<h3 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h3><ol>
<li><p>分页</p>
<p> 内存分段机制下的内存访问示意图如下：</p>
<p> <img src="/img/SimpleOS-2-Boot/img23.png" alt="img"></p>
<p> 我们在实模式下提供段基址，或者是在保护模式下提供的选择子加上另外提供的偏移量，在段部件的处理下形成了线性地址。在还没开启分页机制的情况下，这个线性地址就是真实的物理地址</p>
<p> 分页机制下的内存访问示意图如下：</p>
<p> <img src="/img/SimpleOS-2-Boot/img24.png" alt="img"></p>
<p> 如果打开了分页机制，线性地址还要经过页部件(负责检索页表的部件)的处理，然后才变成了真正的物理地址。我们把没经过页部件处理的线性地址叫做虚拟地址</p>
<p> 分页机制的作用在于：</p>
<ul>
<li><p>将线性地址转换成物理地址</p>
</li>
<li><p>用大小相等的页代替大小不相等的段</p>
</li>
</ul>
<p> 如下图所示：</p>
<p> <img src="/img/SimpleOS-2-Boot/img25.png" alt="img"></p>
<p> 在分段的基础上，将虚拟空间中的段划分为一块块大小相等的页然后映射到任意物理地址空间里</p>
</li>
<li><p>映射</p>
<p> 我们把存储映射关系的数据结构叫做页表（页表也是存储在内存中），页表中的每一项叫做页表项(记录着页对应的物理地址)，一个页表项需要4字节的大小来描述，页表与物理内存之间的关系如下图所示：</p>
<p> <img src="/img/SimpleOS-2-Boot/img26.png" alt="img"></p>
<p> 线性地址和物理地址之间的映射有多种可选择的方案</p>
<p> 比如最简单的是逐字节映射，虚拟空间中的每一个字节对应到物理空间地址上的每一个字节，那么4GB的虚拟空间对应的页表就得有4G个页表项，每个页表项需要4字节，则一共需要16GB空间大小的页表。为了扩展4GB的内存空间而使用了16GB内存空间这明显是不合适的，所以我们要找到一个合适的映射关系，使得分页机机制即能实现，也不会占用太大的额外内存空间。</p>
<p> 最终决定的合适的映射方案是：每4KB大小的空间作为一页。也就是说4GB的内存空间一共可以划分成4GB&#x2F;4KB&#x3D;1M个页，一张页表就得含有1M个页表项，总大小为4MB（就空间耗费而言可以接受）</p>
</li>
<li><p>从线性地址到物理地址</p>
<p> 现在我们如何从线性地址定位到物理地址呢？</p>
<ul>
<li><p>首先页表是存在内存中的，页表的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页表的位置了</p>
</li>
<li><p>然后我们要定位到具体的页表项，<code>取出线性地址的高20位作为索引*4（因为每个页表项占据4字节）+CR3中页表的起始物理地址=目标页表项的地址</code>。找到了页表项也就相当于找到了该页对应的物理地址</p>
</li>
<li><p>最后我们把<code>线性地址低12位作为偏移量+页物理地址=线性地址对应的真正物理地址</code></p>
</li>
</ul>
<p> 线性地址到物理地址转换的全过程如图所示：</p>
<p> <img src="/img/SimpleOS-2-Boot/img27.png" alt="img"></p>
</li>
</ol>
<h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p>一级页表的大小有4MB，这个大小虽然可以接受但不够灵活，我们需要保证内存里有一整块连续的4MB空间。而且每一个进程对应一个页表，当电脑同时运行多个进程的同时页表就会占据很大的空间。我们希望能更节约空间，于是有了二级页表机制</p>
<p>二级页表将原本一共有1M个页表项的大页表分成1k个每个包含1K个页表项的小页表。小页表的空间是1K*4Byte&#x3D;4KB，刚好小页表的大小也是一个页。这样这些1K个小页表就可以灵活得分散到内存空间各个地方里了。但是为了找到这些小页表，我们需要一张页目录(页表的页表),页目录的每一项叫做页目录项（一个页目录项大小也是4字节，一共是1K项），每一项记录着对应小页表的物理地址。真巧！页目录的大小刚刚好也是1K*4Byte&#x3D;4KB(就是一个页的大小)。</p>
<p>二级页表内存分布如下图所示：</p>
<p><img src="/img/SimpleOS-2-Boot/img28.png" alt="img"></p>
<p>这样做有什么好处吗？我们发现二级页表并没有让真正的页表所占用空间变少（只是把它们拆散了），反而多出了一个4KB大小的页目录。但实际上，这样做以后，小页表不仅不需要连续的大空间，而且也可以像普通的页一样在使用频率少的情况下被从内存换到磁盘上，只在需要用的时候才取回来。用4KB空间换取的灵活能带来更多好处。</p>
<p>如何从线性地址定位到物理地址（二级页表）？</p>
<ul>
<li><p>同样也是放在内存中的页目录变成了起点，页目录的起始物理地址我们会放置在CR3控制器中，这样CPU就知道页目录的位置了</p>
</li>
<li><p>我们先取线性地址的高10位*4（页目录项也是4字节）定位到页目录中相对应的页目录项，找到了页目录项就相当于找到了对应页表的物理地址</p>
</li>
<li><p>将线性地址的中间10位*4+对应页表的物理地址找到了页表项，找到了页表项就相当于找到了页的物理地址</p>
</li>
<li><p>将线性地址的最后12位+页的物理地址&#x3D;线性地址对应的真正物理地址</p>
</li>
</ul>
<p>线性地址到物理地址（二级页表）转换的全过程如图所示：</p>
<p><img src="/img/SimpleOS-2-Boot/img29.png" alt="img"></p>
<h3 id="页目录项、页表项以及CR3格式"><a href="#页目录项、页表项以及CR3格式" class="headerlink" title="页目录项、页表项以及CR3格式"></a>页目录项、页表项以及CR3格式</h3><p>页目录项和页表项的格式如下：</p>
<p><img src="/img/SimpleOS-2-Boot/img30.png" alt="img"></p>
<p>页目录基址寄存器(CR3)格式如下：</p>
<p><img src="/img/SimpleOS-2-Boot/img31.png" alt="img"></p>
<ol>
<li><p>为什么页目录项的页表物理地址只有20位而不是32位？因为内存是以4KB每页为单位划分的，因此只要20位地址就可以找到对应的页表了</p>
</li>
<li><p>为什么页表的物理页地址也只有20位？这20位足够索引到内存中的对应页了，剩下的12位是段内偏移量由线性地址的最后12位组成</p>
</li>
<li><p>AVL是Available位，表示可用，是给软件看的。操作系统可以不管该位</p>
</li>
<li><p>G，全局位。G&#x3D;1，则代表缓存在TLB（页表缓冲寄存器）中了，可以不用经过地址转换，直接通过TLB取值</p>
</li>
<li><p>PAT（Page Attribute Table）此位比较复杂，直接置0即可</p>
</li>
<li><p>D(Dirty)脏位，CPU对一个页进行写操作时，对应的页表项D位置1，表示该页已被修改过</p>
</li>
<li><p>A（Accessd）访问位，每当CPU访问过该页时，对应的A位置1。过一段时间后由操作系统同一置0，操作系统可以通过置0的频率来判断该页是否被经常使用</p>
</li>
<li><p>PCD(Page-level Cache Disable)页表高速缓冲禁止位，别管那么多，置0就行</p>
</li>
<li><p>PWT（Page-level Write-Through）页级通写位，别管那么多，置0就行</p>
</li>
<li><p>US（User&#x2F;Supervisor）普通用户&#x2F;超级用户位，为1表示User级，任意特权程序可访问。为0表示Supervisor级，特权级别3的程序不可访问</p>
</li>
<li><p>RW（Read&#x2F;Write）1表示可读可写，0表示可读不可写</p>
</li>
<li><p>P（Present） 存在位，P&#x3D;0表示该表不在物理内存中</p>
</li>
</ol>
<h3 id="启用分页机制的步骤"><a href="#启用分页机制的步骤" class="headerlink" title="启用分页机制的步骤"></a>启用分页机制的步骤</h3><p>启用分页机制要做三件事：</p>
<ol>
<li><p>准备好页目录以及页表</p>
</li>
<li><p>将页目录地址写入控制寄存器cr3</p>
</li>
<li><p>寄存器cr0的PG位置1</p>
</li>
</ol>
<h3 id="什么是可以自举的分页模型？"><a href="#什么是可以自举的分页模型？" class="headerlink" title="什么是可以自举的分页模型？"></a>什么是可以自举的分页模型？</h3><p>当我们想要访问一个物理地址时，我们给出的线性地址将会经过页部件的转换（页目录和页表的查询）后指向真实的物理地址。</p>
<p>现在有一个问题，如果我想要在开启分页机制的情况下修改现有的分表&#x2F;页目录，我该怎么做？</p>
<p>你可能已经发现问题所在了，我们给出的线性地址都是经过页表&#x2F;页目录的映射后才指向真实的物理地址。但是如果我想访问页表和页目录，我给出的地址也是会经过页表&#x2F;页目录的映射后指向其他地方。所以我们需要可以自举的分页模型，也就是说给出的线性地址经过经过页部件转换后可以真正指向目标页表&#x2F;页目录的物理地址。</p>
<p>接下来我们为loader构建的分页模型就是一个可以自举的分页模型</p>
<h2 id="加载内核并初始化"><a href="#加载内核并初始化" class="headerlink" title="加载内核并初始化"></a>加载内核并初始化</h2><h3 id="加载内核并初始化的步骤"><a href="#加载内核并初始化的步骤" class="headerlink" title="加载内核并初始化的步骤"></a>加载内核并初始化的步骤</h3><p>我们将告别汇编，用C编写内核文件kernel.bin,用C编写将会和之前有以下区别：</p>
<p><img src="/img/SimpleOS-2-Boot/img32.png" alt="img"></p>
<p>加载内核要做的事如下：</p>
<ol>
<li><p>用C编写并使用gcc编译链接得到kernel.bin文件，然后用dd指令将kernel.bin文件放到磁盘里</p>
</li>
<li><p>修改loader.S，负责把kernel.bin文件加载到合适的位置(执行完第三步kernel.bin就没用了)</p>
</li>
<li><p>修改loader.S，负责初始化内核，即通过elf头文件信息 将kernel.bin文件里的每个段分别放置在elf头文件指定位置(elf中包含头文件，我们总不能把头文件里的元信息也放置到CPU上执行，所以需要拆解)</p>
</li>
<li><p>跳转到kernel的程序入口地址，loader.S交出最后一棒接力棒</p>
</li>
</ol>
<h3 id="内核文件的内存布局"><a href="#内核文件的内存布局" class="headerlink" title="内核文件的内存布局"></a>内核文件的内存布局</h3><p>我们要讲内核加载到内存的哪里？请看下图低端1MB内存布局里三个打勾的位置：</p>
<p><img src="/img/SimpleOS-2-Boot/img33.png" alt="img"></p>
<p>三个打勾的位置将会是我们内核存放的地方（加载在0x7c00的MBR的工作已经做完了，可以被覆盖。加载在0x900的loader里面包含gdt设置，不能被覆盖），从上述加载内核的步骤看我们需要两个地方来存储内核。</p>
<p>第一个地方存储kernel.bin(对应第2步)</p>
<p>第二个地方存储被loader.S处理后的真正的内核映像文件(对应第三步)</p>
<p>kernel.bin应尽量位于高地址，给不断增长的kernel映像文件腾出空间。预计kernel.bin不会超过100kb，计划存储在0x70000（0x70000~0x9fbff有190KB）。</p>
<p>kernel被处理后的映像文件应该尽量放在低地址同时不能覆盖loader。预计loader大小不会超过2000字节,0x900+2000&#x3D;0x10d0,取一个整数为kernel的映像文件地址0x1500。</p>
<p>上述我们说的都是物理地址，由于我们开启了分页机制后，写代码时里要将物理地址转化为虚拟地址，相应的两个虚拟地址分别是0xc0070000和0xc0001500</p>
<p>在加载完内核后，我们还需要选择一个新的地方作为内核代码的栈顶，可用空间的顶部0x9fc00作为栈顶是最合适的。但是由于pcb（后面章节讲）要求4KB对齐，所以栈顶既要接近0x9fc00又要是4KB的整数倍,所以我们选择了0x9f000作为内核代码的栈顶，转化为虚拟地址即是0xc009f000</p>
<h2 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h2><h3 id="elf文件布局"><a href="#elf文件布局" class="headerlink" title="elf文件布局"></a>elf文件布局</h3><p>elf文件&#x3D;二进制可执行文件+头文件(存储元信息)</p>
<p>一个elf文件的逻辑布局如下图：</p>
<p><img src="/img/SimpleOS-2-Boot/img34.png" alt="img"></p>
<p>物理布局如下图：</p>
<p><img src="/img/SimpleOS-2-Boot/img35.png" alt="img"></p>
<p>关于这两图我们要讲几点：</p>
<ol>
<li><p>Section和Segment的区别：</p>
<p> Section是写代码时为了更清楚的逻辑划分，程序员将代码主动划分为一节一节。（汇编语言中的section、segment关键字本质上划分的都是节）</p>
<p> Segment是编译器将相同类型的Section集合在一起形成了段，如代码段、数据段。（经过编译器链接后，我们才称为段）</p>
</li>
<li><p>我们关注的重点：</p>
<p> 大部分的Section经过编译器链接后成为了Segment，我们关注的重点在Segment，我们所要做的就是根据elf头文件的指示，将每一个Segment放到它该去的地方</p>
</li>
</ol>
<h3 id="elf-header结构"><a href="#elf-header结构" class="headerlink" title="elf header结构"></a>elf header结构</h3><p>elf格式的数据类型（它们就和int、double一样，只关注字节大小就好了）</p>
<p><img src="/img/SimpleOS-2-Boot/img36.png" alt="img"></p>
<p>elf header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/SimpleOS-2-Boot/img37.png" alt="img"></p>
<p>elf header具体数据成员意义描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:e_phoff、e_phentisize、e_phnum）：</p>
<ol>
<li><p>e_ident</p>
<p> <img src="/img/SimpleOS-2-Boot/img38.png" alt="img"></p>
</li>
<li><p>e_type</p>
<p> <img src="/img/SimpleOS-2-Boot/img39.png" alt="img"></p>
</li>
<li><p>e_machine</p>
<p> <img src="/img/SimpleOS-2-Boot/img40.png" alt="img"></p>
</li>
<li><p>others</p>
<p> <img src="/img/SimpleOS-2-Boot/img41.png" alt="img"></p>
</li>
</ol>
<h3 id="program-table-header结构"><a href="#program-table-header结构" class="headerlink" title="program table header结构"></a>program table header结构</h3><p>program table header的数据结构(该数据结构的布局是重点，我们关注每个字段的字节偏移，这样loader.S就可以读取它需要的字段了)</p>
<p><img src="/img/SimpleOS-2-Boot/img42.png" alt="img"></p>
<p>program table header的成员描述（重在会查表应用，而且大部分时候我们只使用其中关键的几项:p_offset、p_vaddr、p_mensz）：</p>
<ol>
<li><p>p_type<br> <img src="/img/SimpleOS-2-Boot/img43.png" alt="img"></p>
</li>
<li><p>p_flags<br> <img src="/img/SimpleOS-2-Boot/img44.png" alt="img"></p>
</li>
<li><p>others<br> <img src="/img/SimpleOS-2-Boot/img45.png" alt="img"></p>
</li>
</ol>
<p>实例：请参照<code>操作系统真相象还原</code>P218-5.3.4；我们可以使用命令<code>readelf -e &#39;文件名&#39;</code>来查看一个elf文件的头的具体数据,也可以使用<code>hd &#39;文件名&#39;</code>来查看一个elf文件的十六进制形式</p>
<h1 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h1><p>见连接如下：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">VScode编码不一致问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 22:15:24" itemprop="dateCreated datePublished" datetime="2023-11-04T22:15:24+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:19:23" itemprop="dateModified" datetime="2023-11-06T11:19:23+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文描述并解决在VSCode里遇到的控制台编码与文件编码不一致导致的乱码问题</p>
<h1 id="VSCode控制台介绍"><a href="#VSCode控制台介绍" class="headerlink" title="VSCode控制台介绍"></a>VSCode控制台介绍</h1><p>VSCode里不止只有1个控制台，如下图所示：</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img1.png" alt="img"></p>
<p>图中一共有四个控制台，可通过终端窗口右上角的<code>+</code>进行调整</p>
<ul>
<li><p>PowerShell：VSCode默认采用PowerShell，功能上比cmd更为强大，兼容cmd命令的同时有自己扩展的指令集，用来管理Windows系统和应用程序，执行复杂的脚本和自动化任务。</p>
</li>
<li><p>Git Bash：Git Bash是Git自带的一个终端模拟器，兼容cmd命令的同时扩展了Linux命令和git命令，它可以在Windows上模拟Bash环境（Linux的控制台）。适合习惯使用Linux的用户。</p>
</li>
<li><p>JavaScript调试终端：可以让你在VSCode中直接运行和调试JavaScript代码，而不需要额外的配置或者浏览器。</p>
</li>
<li><p>Command Prompt：基于Dos的传统的cmd命令行，cmd不兼容上述控制台，只能用来执行一些基本的命令和批处理文件。</p>
</li>
</ul>
<p>除了上述四个控制台外，还有在调试代码时跳出的针对不同语言不同的控制台，例如：用于调试C++&#x2F;C代码的cppdbg；用于调试python代码的python Debug Console等等，可以在调试代码时，查看终端窗口右上角的小标题来确定你现在使用的是哪一个控制台</p>
<p>注意：不同的控制台使用的编码是独立不相互影响的，千万不要使用A控制台却去调整B控制台的编码</p>
<h1 id="VSCode文件编码介绍"><a href="#VSCode文件编码介绍" class="headerlink" title="VSCode文件编码介绍"></a>VSCode文件编码介绍</h1><p>VSCode当前文件编码格式可以查看右下角</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img2.png" alt="img"></p>
<p>如图，当前文件编码是UTF-8</p>
<p>如果想要修改该文件编码，可以点击图中的UTF-8</p>
<p><img src="/img/VSCode%E7%BC%96%E7%A0%81%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/img3.png" alt="img"></p>
<p>先选择通过目标编码方式保存，再通过目标编码方式打开，这样就成功修改了当前文件的编码格式</p>
<h1 id="常见的编码介绍"><a href="#常见的编码介绍" class="headerlink" title="常见的编码介绍"></a>常见的编码介绍</h1><ul>
<li><p>GBK：针对中文的编码（国内cmd默认的编码方式），在国家标准GB2312的基础上扩展的，向下兼容GB2312，但在国外并不常用。代码是936</p>
</li>
<li><p>UTF-8：UTF-8是一种针对多语言的编码，它包含了全世界所有国家需要用到的字符，基于Unicode字符集的，向下兼容ASCII，在国际上通行。代码是65001</p>
</li>
</ul>
<h1 id="如何查看并改变控制台编码"><a href="#如何查看并改变控制台编码" class="headerlink" title="如何查看并改变控制台编码"></a>如何查看并改变控制台编码</h1><p>在控制台里输入以下命令可以查看当前控制台编码格式：</p>
<pre><code>chcp
</code></pre>
<p>在控制台里输入以下命令可临时转化当前控制台编码格式：</p>
<pre><code>chcp &#39;编码代码&#39;
</code></pre>
<p>综上，只要保证文件和控制台编码格式相同，就不会出现乱码问题</p>
<h1 id="本文尚未解决的问题"><a href="#本文尚未解决的问题" class="headerlink" title="本文尚未解决的问题"></a>本文尚未解决的问题</h1><p>本文只提供了临时更改控制台编码的方法，并没有提供更改各个控制台默认编码的方法</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sparkle">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sparkle's Space">
      <meta itemprop="description" content="If there is no torchlight in the future, I will be the only light.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Sparkle's Space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">个人博客创建指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-04 15:23:38" itemprop="dateCreated datePublished" datetime="2023-11-04T15:23:38+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 11:16:01" itemprop="dateModified" datetime="2023-11-06T11:16:01+08:00">2023-11-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>&emsp;&emsp;这篇文章记录我第一次创建个人博客的过程，使用了Github个人账户域名，开源免费的Hexo博客框架以及Next主题。</p>
<h1 id="安装Git和Node-js"><a href="#安装Git和Node-js" class="headerlink" title="安装Git和Node.js"></a>安装Git和Node.js</h1><p>Git 是一种分布式版本控制系统，即，代码的本地克隆就是一个完整的版本控制存储库。 通过这些功能齐全的本地存储库，无论脱机还是远程都能轻松工作。 开发人员会在本地提交其工作，然后再将存储库的副本与服务器上的副本进行同步。（Github就是搭配Git使用的用于存储代码的克隆库）</p>
<p>Node.js可以让JavaScript脱离浏览器运行，它是一个开源、跨平台的JavaScript运行时环境，可以用来开发高性能的 Web 服务器和网络应用。</p>
<p>搭建个人博客为何需要安装Git和Node.js?我们基于Hexo搭建博客，Hexo必须依赖Node.js提供的环境运行。而Git并非是搭建个人博客的必备，但我们仍然推荐下载Git，使用Git的相关命令来从Hexo下载Next主题。</p>
<ol>
<li><p>从官网上安装Git并配置相关环境变量（PS：安装完Git后你可以使用Git Bash作为命令行窗口调用命令，Git Bash上可以使用Linux格式的命令，但由于Git Bash上安装下载无法看到进度条的问题，我个人更推荐用cmd来进行操作，本文后续无特殊声明命令行全采用cmd）</p>
</li>
<li><p>绑定Git和Github账号，在cmd里输入以下命令：</p>
<pre><code> git config --global user.name “Your Name”
 git config --global user.email email@example.com
 :: 其中Your Name和email@example.com替换成上面注册时的账户名和邮箱
</code></pre>
</li>
<li><p>从官网上安装Node.js并配置相关环境变量</p>
</li>
<li><p>执行完上述步骤可以用以下命令测试是否安装成功：</p>
<pre><code> git version
 node -v
 npm -v
</code></pre>
<p> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture1.png" alt="img"></p>
</li>
</ol>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>hexo是一个基于Node.js的静态博客框架，它可以让您使用Markdown（或其他渲染引擎）编写文章，并在几秒内生成静态网页。</p>
<p>npm是Node.js 的默认程序包管理器，它可以让您从 npm 服务器下载、安装、上传和管理 Node.js 的模块或包。模块或包是一些可以重用的代码，可以实现一些特定的功能或提供一些特定的服务</p>
<p>使用npm安装Hexo，命令如下：</p>
<pre><code>npm install -g hexo-cli
</code></pre>
<h1 id="创建博客网站"><a href="#创建博客网站" class="headerlink" title="创建博客网站"></a>创建博客网站</h1><p>所有的准备工作都做好了后，现在需要生成一个文件夹作为个人博客网站的根目录，在你希望放置个人博客文件夹的地方使用如下命令：</p>
<pre><code>hexo init myBlog
:: 其中myBlog就是你的个人博客网站根目录，可以取自己喜欢的名字
cd myBlog
npm install
</code></pre>
<p>如果上面工作都没有出错的化，现在你的个人博客已经搭建成功了，你可以在个人博客根目录下输入以下命令在本地预览效果：</p>
<pre><code>hexo s
</code></pre>
<p><img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture2.png" alt="img"></p>
<p>并且我们可以在根目录下的_config.yml里对个人博客的初始设置进行配置，例如：姓名、标题等个性化设置</p>
<h1 id="选择你喜欢的主题"><a href="#选择你喜欢的主题" class="headerlink" title="选择你喜欢的主题"></a>选择你喜欢的主题</h1><p>大家可以去<a target="_blank" rel="noopener" href="https://hexo.io/themes/">Hexo官网</a>去寻找喜欢的主题下载下来，每个主题都可以点击预览，并且可以点击查看使用说明文档</p>
<p>我使用的<a target="_blank" rel="noopener" href="https://github.com/next-theme/hexo-theme-next">Next主题</a>是较为受欢迎的一款，风格简约大气</p>
<p>下载主题有两种方法，这边只介绍使用一种，在个人博客文件根目录下使用命令：</p>
<pre><code>git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
<p>如果下载成功则根目录下会出现该文件夹 &#x2F;themes&#x2F;next</p>
<p>我们就可以在NexT文件夹里的_config.yml里对该主题的一些设定进行配置，但这种方法存在弊端，官方推荐的配置方法以及具体的操作可以查看<a target="_blank" rel="noopener" href="https://theme-next.js.org/docs/theme-settings/custom-pages">NexT官方说明文档</a></p>
<h1 id="将个人博客部署到Github上"><a href="#将个人博客部署到Github上" class="headerlink" title="将个人博客部署到Github上"></a>将个人博客部署到Github上</h1><p>Github能且仅能使用一个同名仓库的代码托管一个静态站点.</p>
<ol>
<li><p>在Github上创建一个名为：<code>用户名.github.io</code>的仓库</p>
</li>
<li><p>使用以下命令配置SSH钥匙：</p>
<pre><code> git config --global user.name &quot;用户名&quot;
 git config --global user.email &quot;邮箱地址&quot;
 ::之前已经配置过可直接输入第三条命令 
 ssh-keygen -t rsa -C &#39;上面的邮箱&#39;
</code></pre>
<p> 可在<code>C:\Users\用户名\.ssh\id_rsa.pub</code>文件里查看SSH公钥</p>
</li>
<li><p>首次使用还须使用以下命令确认并添加主机到本机SSH可信列表：</p>
<pre><code> ssh -T git@github.com
 ::若返回 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功
</code></pre>
</li>
<li><p>登陆Github添加刚刚生成的SSH key，在下图中Key部分处放入SSH公钥内容<br> <img src="/img/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%8C%87%E5%8D%97/picture3.png" alt="img"></p>
</li>
<li><p>在根目录底下_config.xml文件拉到最底部添加如下配置：</p>
<pre><code> deploy :
 type: git
 repo: https://github.com/1478540/1478540.github.io.git
 # repo是你的仓库地址
 branch: master
</code></pre>
</li>
<li><p>安装一个部署插件：</p>
<pre><code> npm install hexo-deployer-git --save
</code></pre>
</li>
<li><p>生成相应的博客文件并部署：</p>
<pre><code>hexo g 
::g是generate，生成相应文件
hexo d
::d则是部署，部署完以后就可以通过Github账户域名访问个人博客了
</code></pre>
</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>文章发布可以通过命令<code>hexo new &#39;文章标题&#39;</code>,也可以直接在<code>/sourse/_posts</code>文件夹下创建.md文件，文件的具体的编写可以使用<a target="_blank" rel="noopener" href="https://markdown.com.cn/basic-syntax/images.html">makedown语法</a></p>
<p>本文学习于B站教程<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.880.my_history.page.click&vd_source=ed3f2c04c40cfc2a1c4f1c34717b21df">[教程]Hexo &amp; Github搭建自己的专属博客</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sparkle</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
